


SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


CREATE SCHEMA IF NOT EXISTS "public";


ALTER SCHEMA "public" OWNER TO "pg_database_owner";


COMMENT ON SCHEMA "public" IS 'standard public schema';



CREATE TYPE "public"."ledger_account_code" AS ENUM (
    'Sales_Revenue',
    'Accounts_Receivable_COD',
    'Cash_In_Transit',
    'Cash_On_Hand',
    'Delivery_Income',
    'VAT_Payable'
);


ALTER TYPE "public"."ledger_account_code" OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."_apply_ar_open_item_credit"("p_invoice_id" "uuid", "p_amount" numeric) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_amt numeric := greatest(coalesce(p_amount, 0), 0);
  v_new_open numeric;
begin
  if p_invoice_id is null or v_amt <= 0 then
    return;
  end if;

  update public.ar_open_items
  set
    open_balance = greatest(0, open_balance - v_amt),
    status = case when greatest(0, open_balance - v_amt) = 0 then 'closed' else status end,
    closed_at = case when greatest(0, open_balance - v_amt) = 0 then now() else closed_at end
  where invoice_id = p_invoice_id
    and status = 'open';
end;
$$;


ALTER FUNCTION "public"."_apply_ar_open_item_credit"("p_invoice_id" "uuid", "p_amount" numeric) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."_assign_po_number"("p_date" "date") RETURNS "text"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  declare
    v_seq bigint;
    v_date date;
  begin
    v_date := coalesce(p_date, current_date);
    v_seq := nextval('public.purchase_order_number_seq'::regclass);
    return concat('PO-', to_char(v_date, 'YYMMDD'), '-', lpad(v_seq::text, 6, '0'));
  end
  $$;


ALTER FUNCTION "public"."_assign_po_number"("p_date" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."_compute_promotion_price_only"("p_promotion_id" "uuid", "p_customer_id" "uuid", "p_bundle_qty" numeric) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_bundle_qty numeric;
  v_promo record;
  v_item record;
  v_required_qty numeric;
  v_unit_price numeric;
  v_line_gross numeric;
  v_items jsonb := '[]'::jsonb;
  v_original_total numeric := 0;
  v_final_total numeric := 0;
  v_promo_expense numeric := 0;
  v_currency text;
begin
  if p_promotion_id is null then
    raise exception 'p_promotion_id is required';
  end if;

  v_bundle_qty := coalesce(p_bundle_qty, 1);
  if v_bundle_qty <= 0 then
    v_bundle_qty := 1;
  end if;

  select * into v_promo
  from public.promotions p
  where p.id = p_promotion_id;
  if not found then
    raise exception 'promotion_not_found';
  end if;

  v_currency := public.get_base_currency();

  for v_item in
    select pi.item_id, pi.quantity
    from public.promotion_items pi
    where pi.promotion_id = p_promotion_id
    order by pi.sort_order asc, pi.created_at asc, pi.id asc
  loop
    v_required_qty := public._money_round(coalesce(v_item.quantity, 0) * v_bundle_qty, 6);
    if v_required_qty <= 0 then
      continue;
    end if;

    v_unit_price := public.get_item_price_with_discount(v_item.item_id, p_customer_id, v_required_qty);
    v_unit_price := public._money_round(v_unit_price);
    v_line_gross := public._money_round(v_unit_price * v_required_qty);

    v_items := v_items || jsonb_build_object(
      'itemId', v_item.item_id,
      'quantity', v_required_qty,
      'unitPrice', v_unit_price,
      'grossTotal', v_line_gross
    );

    v_original_total := v_original_total + v_line_gross;
  end loop;

  if jsonb_array_length(v_items) = 0 then
    raise exception 'promotion_has_no_items';
  end if;

  v_original_total := public._money_round(v_original_total);

  if v_promo.discount_mode = 'fixed_total' then
    v_final_total := public._money_round(coalesce(v_promo.fixed_total, 0) * v_bundle_qty);
  else
    v_final_total := public._money_round(v_original_total * (1 - (coalesce(v_promo.percent_off, 0) / 100.0)));
  end if;

  v_final_total := greatest(0, least(v_final_total, v_original_total));
  v_promo_expense := public._money_round(v_original_total - v_final_total);

  return jsonb_build_object(
    'promotionId', v_promo.id::text,
    'name', v_promo.name,
    'startAt', v_promo.start_at,
    'endAt', v_promo.end_at,
    'bundleQty', public._money_round(v_bundle_qty, 6),
    'currency', v_currency,
    'displayOriginalTotal', v_promo.display_original_total,
    'computedOriginalTotal', v_original_total,
    'finalTotal', v_final_total,
    'promotionExpense', v_promo_expense,
    'items', v_items
  );
end;
$$;


ALTER FUNCTION "public"."_compute_promotion_price_only"("p_promotion_id" "uuid", "p_customer_id" "uuid", "p_bundle_qty" numeric) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."_compute_promotion_snapshot"("p_promotion_id" "uuid", "p_customer_id" "uuid", "p_warehouse_id" "uuid", "p_bundle_qty" numeric, "p_coupon_code" "text", "p_require_active" boolean DEFAULT true) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_customer_id uuid;
  v_warehouse_id uuid;
  v_bundle_qty numeric;
  v_coupon_code text;
  v_promo record;
  v_item record;
  v_item_input jsonb;
  v_required_qty numeric;
  v_unit_price numeric;
  v_line_gross numeric;
  v_items jsonb := '[]'::jsonb;
  v_original_total numeric := 0;
  v_final_total numeric := 0;
  v_promo_expense numeric := 0;
  v_alloc jsonb := '[]'::jsonb;
  v_alloc_item jsonb;
  v_alloc_total_gross numeric := 0;
  v_gross_share numeric;
  v_alloc_rev numeric;
  v_alloc_rev_sum numeric := 0;
  v_now timestamptz := now();
  v_stock_available numeric;
  v_stock_reserved numeric;
begin
  if p_promotion_id is null then
    raise exception 'p_promotion_id is required';
  end if;

  v_customer_id := p_customer_id;
  v_warehouse_id := p_warehouse_id;
  if v_warehouse_id is null then
    v_warehouse_id := public._resolve_default_warehouse_id();
  end if;

  v_bundle_qty := coalesce(p_bundle_qty, 1);
  if v_bundle_qty <= 0 then
    v_bundle_qty := 1;
  end if;

  v_coupon_code := nullif(btrim(coalesce(p_coupon_code, '')), '');

  select *
  into v_promo
  from public.promotions p
  where p.id = p_promotion_id;
  if not found then
    raise exception 'promotion_not_found';
  end if;

  if p_require_active then
    if not v_promo.is_active then
      raise exception 'promotion_inactive';
    end if;
    if v_promo.approval_status <> 'approved' then
      raise exception 'promotion_requires_approval';
    end if;
    if v_now < v_promo.start_at or v_now > v_promo.end_at then
      raise exception 'promotion_outside_time_window';
    end if;
  end if;

  if v_promo.exclusive_with_coupon and v_coupon_code is not null then
    raise exception 'promotion_coupon_conflict';
  end if;

  for v_item in
    select
      pi.item_id,
      pi.quantity,
      coalesce(mi.is_food, false) as is_food
    from public.promotion_items pi
    join public.menu_items mi on mi.id = pi.item_id
    where pi.promotion_id = p_promotion_id
    order by pi.sort_order asc, pi.created_at asc, pi.id asc
  loop
    v_required_qty := public._money_round(coalesce(v_item.quantity, 0) * v_bundle_qty, 6);
    if v_required_qty <= 0 then
      continue;
    end if;

    if not v_item.is_food then
      select coalesce(sm.available_quantity, 0), coalesce(sm.reserved_quantity, 0)
      into v_stock_available, v_stock_reserved
      from public.stock_management sm
      where sm.item_id::text = v_item.item_id
        and sm.warehouse_id = v_warehouse_id;

      if (coalesce(v_stock_available, 0) - coalesce(v_stock_reserved, 0)) + 1e-9 < v_required_qty then
        raise exception 'Insufficient stock for item % in warehouse %', v_item.item_id, v_warehouse_id;
      end if;
    else
      select coalesce(sum(greatest(coalesce(b.quantity_received,0) - coalesce(b.quantity_consumed,0), 0)), 0)
      into v_stock_available
      from public.batches b
      where b.item_id = v_item.item_id
        and b.warehouse_id = v_warehouse_id
        and (b.expiry_date is null or b.expiry_date >= current_date);

      if coalesce(v_stock_available, 0) + 1e-9 < v_required_qty then
        raise exception 'Insufficient FEFO stock for item % in warehouse %', v_item.item_id, v_warehouse_id;
      end if;
    end if;

    v_unit_price := public.get_item_price_with_discount(v_item.item_id, v_customer_id, v_required_qty);
    v_unit_price := public._money_round(v_unit_price);
    v_line_gross := public._money_round(v_unit_price * v_required_qty);

    v_items := v_items || jsonb_build_object(
      'itemId', v_item.item_id,
      'quantity', v_required_qty,
      'unitPrice', v_unit_price,
      'grossTotal', v_line_gross
    );

    v_original_total := v_original_total + v_line_gross;
  end loop;

  if jsonb_array_length(v_items) = 0 then
    raise exception 'promotion_has_no_items';
  end if;

  v_original_total := public._money_round(v_original_total);

  if v_promo.discount_mode = 'fixed_total' then
    v_final_total := public._money_round(coalesce(v_promo.fixed_total, 0) * v_bundle_qty);
  else
    v_final_total := public._money_round(v_original_total * (1 - (coalesce(v_promo.percent_off, 0) / 100.0)));
  end if;

  v_final_total := greatest(0, least(v_final_total, v_original_total));
  v_promo_expense := public._money_round(v_original_total - v_final_total);

  v_alloc_total_gross := greatest(v_original_total, 0);
  v_alloc_rev_sum := 0;

  for v_item_input in
    select value from jsonb_array_elements(v_items)
  loop
    v_line_gross := coalesce(nullif((v_item_input->>'grossTotal')::numeric, null), 0);
    if v_alloc_total_gross > 0 then
      v_gross_share := greatest(0, v_line_gross) / v_alloc_total_gross;
    else
      v_gross_share := 0;
    end if;
    v_alloc_rev := public._money_round(v_original_total * v_gross_share);
    v_alloc_rev_sum := v_alloc_rev_sum + v_alloc_rev;

    v_alloc_item := jsonb_build_object(
      'itemId', v_item_input->>'itemId',
      'quantity', coalesce(nullif((v_item_input->>'quantity')::numeric, null), 0),
      'unitPrice', coalesce(nullif((v_item_input->>'unitPrice')::numeric, null), 0),
      'grossTotal', v_line_gross,
      'allocatedRevenue', v_alloc_rev,
      'allocatedRevenuePct', v_gross_share
    );
    v_alloc := v_alloc || v_alloc_item;
  end loop;

  if abs(v_alloc_rev_sum - v_original_total) > 0.02 and jsonb_array_length(v_alloc) > 0 then
    v_alloc_item := v_alloc->(jsonb_array_length(v_alloc) - 1);
    v_alloc_item := jsonb_set(
      v_alloc_item,
      '{allocatedRevenue}',
      to_jsonb(public._money_round(coalesce(nullif((v_alloc_item->>'allocatedRevenue')::numeric, null), 0) + (v_original_total - v_alloc_rev_sum))),
      true
    );
    v_alloc := jsonb_set(v_alloc, array[(jsonb_array_length(v_alloc) - 1)::text], v_alloc_item, true);
  end if;

  return jsonb_build_object(
    'promotionId', v_promo.id::text,
    'name', v_promo.name,
    'startAt', v_promo.start_at,
    'endAt', v_promo.end_at,
    'bundleQty', public._money_round(v_bundle_qty, 6),
    'displayOriginalTotal', v_promo.display_original_total,
    'computedOriginalTotal', v_original_total,
    'finalTotal', v_final_total,
    'promotionExpense', v_promo_expense,
    'items', v_items,
    'revenueAllocation', v_alloc,
    'warehouseId', v_warehouse_id::text,
    'customerId', case when v_customer_id is null then null else v_customer_id::text end,
    'appliedAt', v_now
  );
end;
$$;


ALTER FUNCTION "public"."_compute_promotion_snapshot"("p_promotion_id" "uuid", "p_customer_id" "uuid", "p_warehouse_id" "uuid", "p_bundle_qty" numeric, "p_coupon_code" "text", "p_require_active" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."_driver_ledger_next_balance"("p_driver_id" "uuid", "p_debit" numeric, "p_credit" numeric) RETURNS numeric
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_prev numeric := 0;
BEGIN
  PERFORM pg_advisory_xact_lock(hashtextextended(p_driver_id::text, 0));
  SELECT dl.balance_after
  INTO v_prev
  FROM public.driver_ledger dl
  WHERE dl.driver_id = p_driver_id
  ORDER BY dl.occurred_at DESC, dl.created_at DESC, dl.id DESC
  LIMIT 1;
  RETURN coalesce(v_prev, 0) + coalesce(p_debit, 0) - coalesce(p_credit, 0);
END;
$$;


ALTER FUNCTION "public"."_driver_ledger_next_balance"("p_driver_id" "uuid", "p_debit" numeric, "p_credit" numeric) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."_extract_stock_items_from_order_data"("p_order_data" "jsonb") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_items jsonb := '[]'::jsonb;
  v_it jsonb;
  v_line jsonb;
  v_pi jsonb;
  v_item_id text;
  v_unit text;
  v_qty numeric;
begin
  if p_order_data is null then
    return '[]'::jsonb;
  end if;

  if jsonb_typeof(p_order_data->'items') = 'array' then
    for v_it in select value from jsonb_array_elements(p_order_data->'items')
    loop
      v_item_id := nullif(btrim(coalesce(v_it->>'itemId', v_it->>'id', v_it->>'menuItemId')), '');
      v_unit := lower(coalesce(nullif(v_it->>'unitType',''), nullif(v_it->>'unit',''), 'piece'));
      if v_unit in ('kg','gram') then
        v_qty := coalesce(
          nullif((v_it->>'weight')::numeric, null),
          nullif((v_it->>'quantity')::numeric, null),
          nullif((v_it->>'qty')::numeric, null),
          0
        );
      else
        v_qty := coalesce(
          nullif((v_it->>'quantity')::numeric, null),
          nullif((v_it->>'qty')::numeric, null),
          0
        );
      end if;
      if v_item_id is null or v_qty <= 0 then
        continue;
      end if;
      v_items := v_items || jsonb_build_object('itemId', v_item_id, 'quantity', v_qty);
    end loop;
  end if;

  if jsonb_typeof(p_order_data->'promotionLines') = 'array' then
    for v_line in select value from jsonb_array_elements(p_order_data->'promotionLines')
    loop
      for v_pi in select value from jsonb_array_elements(coalesce(v_line->'items', '[]'::jsonb))
      loop
        v_item_id := nullif(btrim(coalesce(v_pi->>'itemId', v_pi->>'id')), '');
        v_qty := coalesce(nullif((v_pi->>'quantity')::numeric, null), 0);
        if v_item_id is null or v_qty <= 0 then
          continue;
        end if;
        v_items := v_items || jsonb_build_object('itemId', v_item_id, 'quantity', v_qty);
      end loop;
    end loop;
  end if;

  return public._merge_stock_items(v_items);
end;
$$;


ALTER FUNCTION "public"."_extract_stock_items_from_order_data"("p_order_data" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."_is_cod_delivery_order"("p_order" "jsonb", "p_delivery_zone_id" "uuid") RETURNS boolean
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select
    coalesce(nullif(p_order->>'paymentMethod',''), '') = 'cash'
    and coalesce(nullif(p_order->>'orderSource',''), '') <> 'in_store'
    and p_delivery_zone_id is not null
$$;


ALTER FUNCTION "public"."_is_cod_delivery_order"("p_order" "jsonb", "p_delivery_zone_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."_is_migration_actor"() RETURNS boolean
    LANGUAGE "sql" STABLE
    AS $$
  select current_user in ('postgres','supabase_admin');
$$;


ALTER FUNCTION "public"."_is_migration_actor"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."_merge_stock_items"("p_items" "jsonb") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_item jsonb;
  v_map jsonb := '{}'::jsonb;
  v_item_id text;
  v_qty numeric;
  v_result jsonb := '[]'::jsonb;
  v_key text;
begin
  if p_items is null or jsonb_typeof(p_items) <> 'array' then
    return '[]'::jsonb;
  end if;

  for v_item in select value from jsonb_array_elements(p_items)
  loop
    v_item_id := nullif(btrim(coalesce(v_item->>'itemId', v_item->>'id')), '');
    v_qty := coalesce(nullif((v_item->>'quantity')::numeric, null), 0);
    if v_item_id is null or v_qty <= 0 then
      continue;
    end if;
    v_map := jsonb_set(
      v_map,
      array[v_item_id],
      to_jsonb(coalesce(nullif((v_map->>v_item_id)::numeric, null), 0) + v_qty),
      true
    );
  end loop;

  for v_key in select key from jsonb_each(v_map)
  loop
    v_result := v_result || jsonb_build_object('itemId', v_key, 'quantity', (v_map->>v_key)::numeric);
  end loop;

  return v_result;
end;
$$;


ALTER FUNCTION "public"."_merge_stock_items"("p_items" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."_money_round"("p_value" numeric, "p_scale" integer DEFAULT 2) RETURNS numeric
    LANGUAGE "plpgsql"
    AS $$
begin
  return round(coalesce(p_value, 0), coalesce(p_scale, 2));
end;
$$;


ALTER FUNCTION "public"."_money_round"("p_value" numeric, "p_scale" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."_require_staff"("p_action" "text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if auth.uid() is null then
    raise exception 'not authenticated';
  end if;
  if not public.is_staff() then
    raise exception 'not allowed: %', coalesce(p_action, 'operation');
  end if;
end;
$$;


ALTER FUNCTION "public"."_require_staff"("p_action" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."_require_stock_manager"("p_action" "text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if auth.uid() is null then
    raise exception 'not authenticated';
  end if;
  if not public.has_admin_permission('stock.manage') then
    raise exception 'not allowed: %', coalesce(p_action, 'stock');
  end if;
end;
$$;


ALTER FUNCTION "public"."_require_stock_manager"("p_action" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."_resolve_batch_sale_failure_reason"("p_item_id" "text", "p_warehouse_id" "uuid", "p_quantity" numeric) RETURNS "text"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_qty numeric := greatest(coalesce(p_quantity, 0), 0);
  v_total_released numeric := 0;
  v_has_nonexpired boolean := false;
  v_has_nonexpired_unreleased boolean := false;
begin
  if p_item_id is null or btrim(p_item_id) = '' or p_warehouse_id is null then
    return 'NO_VALID_BATCH';
  end if;
  if v_qty <= 0 then
    v_qty := 1;
  end if;

  select exists(
    select 1
    from public.batches b
    where b.item_id::text = p_item_id::text
      and b.warehouse_id = p_warehouse_id
      and coalesce(b.status, 'active') = 'active'
      and (b.expiry_date is null or b.expiry_date >= current_date)
      and greatest(coalesce(b.quantity_received,0) - coalesce(b.quantity_consumed,0) - coalesce(b.quantity_transferred,0), 0) > 0
  ) into v_has_nonexpired;

  if not v_has_nonexpired then
    return 'NO_VALID_BATCH';
  end if;

  select exists(
    select 1
    from public.batches b
    where b.item_id::text = p_item_id::text
      and b.warehouse_id = p_warehouse_id
      and coalesce(b.status, 'active') = 'active'
      and (b.expiry_date is null or b.expiry_date >= current_date)
      and greatest(coalesce(b.quantity_received,0) - coalesce(b.quantity_consumed,0) - coalesce(b.quantity_transferred,0), 0) > 0
      and coalesce(b.qc_status,'released') <> 'released'
  ) into v_has_nonexpired_unreleased;

  if v_has_nonexpired_unreleased then
    return 'BATCH_NOT_RELEASED';
  end if;

  select coalesce(sum(greatest(coalesce(b.quantity_received,0) - coalesce(b.quantity_consumed,0) - coalesce(b.quantity_transferred,0), 0)), 0)
  into v_total_released
  from public.batches b
  where b.item_id::text = p_item_id::text
    and b.warehouse_id = p_warehouse_id
    and coalesce(b.status, 'active') = 'active'
    and (b.expiry_date is null or b.expiry_date >= current_date)
    and coalesce(b.qc_status,'released') = 'released';

  if v_total_released + 1e-9 < v_qty then
    return 'INSUFFICIENT_BATCH_QUANTITY';
  end if;

  return null;
end;
$$;


ALTER FUNCTION "public"."_resolve_batch_sale_failure_reason"("p_item_id" "text", "p_warehouse_id" "uuid", "p_quantity" numeric) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."_resolve_default_admin_warehouse_id"() RETURNS "uuid"
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select w.id
  from public.warehouses w
  where w.is_active = true
  order by case when upper(coalesce(w.code,'')) = 'MAIN' then 0 else 1 end,
           w.created_at asc,
           w.code asc
  limit 1;
$$;


ALTER FUNCTION "public"."_resolve_default_admin_warehouse_id"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."_resolve_default_min_margin_pct"("p_item_id" "text", "p_warehouse_id" "uuid") RETURNS numeric
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_item jsonb;
  v_wh_pricing jsonb;
  v_settings jsonb;
  v_val numeric;
begin
  if p_item_id is null or btrim(p_item_id) = '' then
    return 0;
  end if;

  select data into v_item from public.menu_items mi where mi.id::text = p_item_id;
  if v_item is not null then
    begin
      v_val := nullif((v_item->'pricing'->>'minMarginPct')::numeric, null);
    exception when others then
      v_val := null;
    end;
    if v_val is not null then
      return greatest(0, v_val);
    end if;
  end if;

  if p_warehouse_id is not null then
    select pricing into v_wh_pricing from public.warehouses w where w.id = p_warehouse_id;
    if v_wh_pricing is not null then
      begin
        v_val := nullif((v_wh_pricing->>'defaultMinMarginPct')::numeric, null);
      exception when others then
        v_val := null;
      end;
      if v_val is not null then
        return greatest(0, v_val);
      end if;
    end if;
  end if;

  select data into v_settings from public.app_settings where id = 'singleton';
  if v_settings is not null then
    begin
      v_val := nullif((v_settings->'pricing'->>'defaultMinMarginPct')::numeric, null);
    exception when others then
      v_val := null;
    end;
    if v_val is not null then
      return greatest(0, v_val);
    end if;
  end if;

  return 0;
end;
$$;


ALTER FUNCTION "public"."_resolve_default_min_margin_pct"("p_item_id" "text", "p_warehouse_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."_resolve_default_warehouse_id"() RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_warehouse_id uuid;
begin
  select w.id
  into v_warehouse_id
  from public.warehouses w
  where w.is_active = true
  order by (upper(coalesce(w.code, '')) = 'MAIN') desc, w.code asc
  limit 1;

  if v_warehouse_id is null then
    raise exception 'No active warehouse found';
  end if;
  return v_warehouse_id;
end;
$$;


ALTER FUNCTION "public"."_resolve_default_warehouse_id"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."_resolve_open_shift_for_cash"("p_operator" "uuid") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_shift_id uuid;
begin
  select s.id
  into v_shift_id
  from public.cash_shifts s
  where s.cashier_id = p_operator
    and coalesce(s.status, 'open') = 'open'
  order by s.opened_at desc
  limit 1;

  return v_shift_id;
end;
$$;


ALTER FUNCTION "public"."_resolve_open_shift_for_cash"("p_operator" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."_sync_order_terms_columns"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
    declare
      v_terms text;
      v_net_days integer;
      v_due date;
      v_due_text text;
      v_basis timestamptz;
    begin
      v_terms := nullif(trim(coalesce(new.data->>'invoiceTerms','')), '');
      if v_terms is null then
        if coalesce((new.data->>'isCreditSale')::boolean, false) or coalesce(new.data->>'paymentMethod','') = 'ar' then
          v_terms := 'credit';
        else
          v_terms := 'cash';
        end if;
      end if;
      if v_terms <> 'credit' then
        v_terms := 'cash';
      end if;

      v_net_days := 0;
      begin
        v_net_days := greatest(0, coalesce(nullif((new.data->>'netDays')::int, 0), (new.data->>'creditDays')::int, new.net_days, 0));
      exception when others then
        v_net_days := greatest(0, coalesce(new.net_days, 0));
      end;

      v_due_text := nullif(trim(coalesce(new.data->>'dueDate','')), '');
      v_due := null;
      if v_due_text is not null then
        begin
          v_due := v_due_text::date;
        exception when others then
          v_due := null;
        end;
      end if;

      if v_due is null then
        begin
          v_basis := nullif(trim(coalesce(new.data->>'invoiceIssuedAt','')), '')::timestamptz;
        exception when others then
          v_basis := null;
        end;
        if v_basis is null then
          begin
            v_basis := nullif(trim(coalesce(new.data->>'deliveredAt','')), '')::timestamptz;
          exception when others then
            v_basis := null;
          end;
        end if;
        if v_basis is null then
          v_basis := coalesce(new.created_at, now());
        end if;

        if v_terms = 'cash' then
          v_due := (v_basis::date);
        else
          v_due := (v_basis::date + greatest(v_net_days, 0));
        end if;
      end if;

      new.invoice_terms := v_terms;
      new.net_days := greatest(0, coalesce(v_net_days, 0));
      new.due_date := v_due;
      return new;
    end
    $$;


ALTER FUNCTION "public"."_sync_order_terms_columns"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."_trg_purchase_orders_po_number"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  begin
    if new.po_number is null or length(trim(new.po_number)) = 0 then
      new.po_number := public._assign_po_number(new.purchase_date);
    end if;
    if new.reference_number is not null and length(trim(new.reference_number)) = 0 then
      new.reference_number := null;
    end if;
    return new;
  end
  $$;


ALTER FUNCTION "public"."_trg_purchase_orders_po_number"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."_uuid_or_null"("p_value" "text") RETURNS "uuid"
    LANGUAGE "plpgsql" IMMUTABLE
    AS $_$
begin
  if p_value is null or nullif(btrim(p_value), '') is null then
    return null;
  end if;
  if btrim(p_value) ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$' then
    return btrim(p_value)::uuid;
  end if;
  return null;
end;
$_$;


ALTER FUNCTION "public"."_uuid_or_null"("p_value" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."allocate_landed_cost_to_inventory"("p_shipment_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_entry_id uuid;
  v_total_expenses_base numeric;
  v_inventory uuid := public.get_account_id_by_code('1410');
  v_clearing uuid := public.get_account_id_by_code('2060');
begin
  if p_shipment_id is null then
    raise exception 'p_shipment_id required';
  end if;

  if exists(select 1 from public.landed_cost_audit a where a.shipment_id = p_shipment_id) then
    return;
  end if;

  select je.id into v_entry_id
  from public.journal_entries je
  where je.source_table = 'import_shipments'
    and je.source_id = p_shipment_id::text
  limit 1;

  if v_entry_id is not null then
    insert into public.landed_cost_audit(shipment_id, total_expenses_base, journal_entry_id)
    values (p_shipment_id, 0, v_entry_id)
    on conflict (shipment_id) do nothing;
    return;
  end if;

  select coalesce(sum(coalesce(ie.amount,0) * coalesce(ie.exchange_rate,1)), 0)
  into v_total_expenses_base
  from public.import_expenses ie
  where ie.shipment_id = p_shipment_id;

  if v_total_expenses_base <= 0 then
    return;
  end if;

  insert into public.journal_entries(entry_date, memo, source_table, source_id, source_event, created_by)
  values (
    current_date,
    concat('Landed cost allocation shipment ', p_shipment_id::text),
    'import_shipments',
    p_shipment_id::text,
    'landed_cost_allocation',
    auth.uid()
  )
  returning id into v_entry_id;

  insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
  values
    (v_entry_id, v_inventory, v_total_expenses_base, 0, 'Capitalize landed cost'),
    (v_entry_id, v_clearing, 0, v_total_expenses_base, 'Clear landed cost');

  insert into public.landed_cost_audit(shipment_id, total_expenses_base, journal_entry_id)
  values (p_shipment_id, v_total_expenses_base, v_entry_id)
  on conflict (shipment_id) do nothing;
end;
$$;


ALTER FUNCTION "public"."allocate_landed_cost_to_inventory"("p_shipment_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."allocate_payment_to_open_item"("p_open_item_id" "uuid", "p_payment_id" "uuid", "p_amount" numeric) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_open record;
  v_pay record;
  v_amount numeric;
begin
  if not (auth.role() = 'service_role' or public.has_admin_permission('accounting.manage')) then
    raise exception 'not authorized';
  end if;
  if p_open_item_id is null or p_payment_id is null then
    raise exception 'required ids';
  end if;
  select * into v_open from public.ar_open_items where id = p_open_item_id for update;
  if not found then
    raise exception 'open item not found';
  end if;
  select * into v_pay from public.payments where id = p_payment_id;
  if not found then
    raise exception 'payment not found';
  end if;
  v_amount := greatest(0, coalesce(p_amount, 0));
  if v_amount <= 0 then
    raise exception 'invalid amount';
  end if;
  if v_amount - 1e-9 > v_open.open_balance then
    raise exception 'allocation exceeds open balance';
  end if;
  insert into public.ar_allocations(open_item_id, payment_id, amount, occurred_at, created_by)
  values (p_open_item_id, p_payment_id, v_amount, v_pay.occurred_at, auth.uid())
  on conflict (open_item_id, payment_id) do update set amount = excluded.amount;
  update public.ar_open_items
  set open_balance = greatest(0, open_balance - v_amount),
      status = case when greatest(0, open_balance - v_amount) = 0 then 'closed' else status end,
      closed_at = case when greatest(0, open_balance - v_amount) = 0 then now() else closed_at end
  where id = p_open_item_id;
  update public.ar_payment_status
  set allocated = true,
      updated_at = now()
  where payment_id = p_payment_id;
end;
$$;


ALTER FUNCTION "public"."allocate_payment_to_open_item"("p_open_item_id" "uuid", "p_payment_id" "uuid", "p_amount" numeric) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."ap_aging_summary"("p_as_of" "date" DEFAULT CURRENT_DATE) RETURNS TABLE("supplier_id" "uuid", "current" numeric, "days_1_30" numeric, "days_31_60" numeric, "days_61_90" numeric, "days_91_plus" numeric, "total_outstanding" numeric)
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if not public.has_admin_permission('accounting.view') then
    raise exception 'not allowed';
  end if;

  return query
  with po as (
    select
      po.id as purchase_order_id,
      po.supplier_id,
      po.purchase_date as invoice_date,
      coalesce(po.total_amount, 0) as total
    from public.purchase_orders po
    where po.status <> 'cancelled'
      and po.purchase_date <= p_as_of
  ),
  paid as (
    select
      p.reference_id::uuid as purchase_order_id,
      coalesce(sum(p.amount), 0) as paid
    from public.payments p
    where p.reference_table = 'purchase_orders'
      and p.direction = 'out'
      and p.occurred_at::date <= p_as_of
    group by p.reference_id
  ),
  open_items as (
    select
      po.supplier_id,
      greatest(0, po.total - coalesce(p.paid, 0)) as outstanding,
      (p_as_of - po.invoice_date) as age_days
    from po
    left join paid p on p.purchase_order_id = po.purchase_order_id
    where (po.total - coalesce(p.paid, 0)) > 1e-9
  )
  select
    oi.supplier_id,
    coalesce(sum(case when oi.age_days <= 0 then oi.outstanding else 0 end), 0) as current,
    coalesce(sum(case when oi.age_days between 1 and 30 then oi.outstanding else 0 end), 0) as days_1_30,
    coalesce(sum(case when oi.age_days between 31 and 60 then oi.outstanding else 0 end), 0) as days_31_60,
    coalesce(sum(case when oi.age_days between 61 and 90 then oi.outstanding else 0 end), 0) as days_61_90,
    coalesce(sum(case when oi.age_days >= 91 then oi.outstanding else 0 end), 0) as days_91_plus,
    coalesce(sum(oi.outstanding), 0) as total_outstanding
  from open_items oi
  group by oi.supplier_id
  order by total_outstanding desc;
end;
$$;


ALTER FUNCTION "public"."ap_aging_summary"("p_as_of" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."apply_promotion_to_cart"("p_cart_payload" "jsonb", "p_promotion_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_actor uuid;
  v_customer_id uuid;
  v_warehouse_id uuid;
  v_bundle_qty numeric;
  v_coupon_code text;
  v_promo record;
  v_item record;
  v_item_input jsonb;
  v_required_qty numeric;
  v_unit_price numeric;
  v_line_gross numeric;
  v_items jsonb := '[]'::jsonb;
  v_original_total numeric := 0;
  v_final_total numeric := 0;
  v_promo_expense numeric := 0;
  v_alloc jsonb := '[]'::jsonb;
  v_alloc_item jsonb;
  v_alloc_total_gross numeric := 0;
  v_gross_share numeric;
  v_alloc_rev numeric;
  v_alloc_rev_sum numeric := 0;
  v_now timestamptz := now();
  v_stock_available numeric;
  v_stock_reserved numeric;
  v_is_food boolean;
  v_image_url text;
begin
  v_actor := auth.uid();
  if v_actor is null then
    raise exception 'not authenticated';
  end if;

  if p_promotion_id is null then
    raise exception 'p_promotion_id is required';
  end if;

  if p_cart_payload is null then
    p_cart_payload := '{}'::jsonb;
  end if;

  v_customer_id := public._uuid_or_null(p_cart_payload->>'customerId');
  v_warehouse_id := public._uuid_or_null(p_cart_payload->>'warehouseId');
  if v_warehouse_id is null then
    v_warehouse_id := public._resolve_default_warehouse_id();
  end if;

  v_bundle_qty := coalesce(nullif((p_cart_payload->>'bundleQty')::numeric, null), 1);
  if v_bundle_qty <= 0 then
    v_bundle_qty := 1;
  end if;

  v_coupon_code := nullif(btrim(coalesce(p_cart_payload->>'couponCode', '')), '');

  select *
  into v_promo
  from public.promotions p
  where p.id = p_promotion_id;
  if not found then
    raise exception 'promotion_not_found';
  end if;
  if not v_promo.is_active then
    raise exception 'promotion_inactive';
  end if;
  if v_promo.approval_status <> 'approved' then
    raise exception 'promotion_requires_approval';
  end if;
  if v_now < v_promo.start_at or v_now > v_promo.end_at then
    raise exception 'promotion_outside_time_window';
  end if;
  if v_promo.exclusive_with_coupon and v_coupon_code is not null then
    raise exception 'promotion_coupon_conflict';
  end if;

  v_image_url := nullif(btrim(coalesce(v_promo.image_url, v_promo.data->>'imageUrl', '')), '');

  for v_item in
    select
      pi.item_id,
      pi.quantity,
      coalesce(mi.is_food, false) as is_food
    from public.promotion_items pi
    join public.menu_items mi on mi.id = pi.item_id
    where pi.promotion_id = p_promotion_id
    order by pi.sort_order asc, pi.created_at asc, pi.id asc
  loop
    v_required_qty := public._money_round(coalesce(v_item.quantity, 0) * v_bundle_qty, 6);
    if v_required_qty <= 0 then
      continue;
    end if;

    if not v_item.is_food then
      select coalesce(sm.available_quantity, 0), coalesce(sm.reserved_quantity, 0)
      into v_stock_available, v_stock_reserved
      from public.stock_management sm
      where sm.item_id::text = v_item.item_id
        and sm.warehouse_id = v_warehouse_id;

      if (coalesce(v_stock_available, 0) - coalesce(v_stock_reserved, 0)) + 1e-9 < v_required_qty then
        raise exception 'Insufficient stock for item % in warehouse %', v_item.item_id, v_warehouse_id;
      end if;
    else
      select coalesce(sum(greatest(coalesce(b.quantity_received,0) - coalesce(b.quantity_consumed,0), 0)), 0)
      into v_stock_available
      from public.batches b
      where b.item_id = v_item.item_id
        and b.warehouse_id = v_warehouse_id
        and (b.expiry_date is null or b.expiry_date >= current_date);

      if coalesce(v_stock_available, 0) + 1e-9 < v_required_qty then
        raise exception 'Insufficient FEFO stock for item % in warehouse %', v_item.item_id, v_warehouse_id;
      end if;
    end if;

    v_unit_price := public.get_item_price_with_discount(v_item.item_id, v_customer_id, v_required_qty);
    v_unit_price := public._money_round(v_unit_price);
    v_line_gross := public._money_round(v_unit_price * v_required_qty);

    v_items := v_items || jsonb_build_object(
      'itemId', v_item.item_id,
      'quantity', v_required_qty,
      'unitPrice', v_unit_price,
      'grossTotal', v_line_gross
    );

    v_original_total := v_original_total + v_line_gross;
  end loop;

  if jsonb_array_length(v_items) = 0 then
    raise exception 'promotion_has_no_items';
  end if;

  v_original_total := public._money_round(v_original_total);

  if v_promo.discount_mode = 'fixed_total' then
    v_final_total := public._money_round(coalesce(v_promo.fixed_total, 0) * v_bundle_qty);
  else
    v_final_total := public._money_round(v_original_total * (1 - (coalesce(v_promo.percent_off, 0) / 100.0)));
  end if;

  v_final_total := greatest(0, least(v_final_total, v_original_total));
  v_promo_expense := public._money_round(v_original_total - v_final_total);

  v_alloc_total_gross := greatest(v_original_total, 0);
  v_alloc_rev_sum := 0;

  for v_item_input in
    select value from jsonb_array_elements(v_items)
  loop
    v_line_gross := coalesce(nullif((v_item_input->>'grossTotal')::numeric, null), 0);
    if v_alloc_total_gross > 0 then
      v_gross_share := greatest(0, v_line_gross) / v_alloc_total_gross;
    else
      v_gross_share := 0;
    end if;
    v_alloc_rev := public._money_round(v_original_total * v_gross_share);
    v_alloc_rev_sum := v_alloc_rev_sum + v_alloc_rev;

    v_alloc_item := jsonb_build_object(
      'itemId', v_item_input->>'itemId',
      'quantity', coalesce(nullif((v_item_input->>'quantity')::numeric, null), 0),
      'unitPrice', coalesce(nullif((v_item_input->>'unitPrice')::numeric, null), 0),
      'grossTotal', v_line_gross,
      'allocatedRevenue', v_alloc_rev,
      'allocatedRevenuePct', v_gross_share
    );
    v_alloc := v_alloc || v_alloc_item;
  end loop;

  if abs(v_alloc_rev_sum - v_original_total) > 0.02 and jsonb_array_length(v_alloc) > 0 then
    v_alloc_item := v_alloc->(jsonb_array_length(v_alloc) - 1);
    v_alloc_item := jsonb_set(
      v_alloc_item,
      '{allocatedRevenue}',
      to_jsonb(public._money_round(coalesce(nullif((v_alloc_item->>'allocatedRevenue')::numeric, null), 0) + (v_original_total - v_alloc_rev_sum))),
      true
    );
    v_alloc := jsonb_set(v_alloc, array[(jsonb_array_length(v_alloc) - 1)::text], v_alloc_item, true);
  end if;

  return jsonb_build_object(
    'promotionId', v_promo.id::text,
    'name', v_promo.name,
    'imageUrl', v_image_url,
    'startAt', v_promo.start_at,
    'endAt', v_promo.end_at,
    'bundleQty', public._money_round(v_bundle_qty, 6),
    'displayOriginalTotal', v_promo.display_original_total,
    'computedOriginalTotal', v_original_total,
    'finalTotal', v_final_total,
    'promotionExpense', v_promo_expense,
    'items', v_items,
    'revenueAllocation', v_alloc,
    'warehouseId', v_warehouse_id::text,
    'customerId', case when v_customer_id is null then null else v_customer_id::text end,
    'appliedAt', v_now
  );
end;
$$;


ALTER FUNCTION "public"."apply_promotion_to_cart"("p_cart_payload" "jsonb", "p_promotion_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."apply_supplier_credit_note"("p_credit_note_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_note record;
  v_ap uuid;
  v_inv uuid;
  v_cogs uuid;
  v_total_amount numeric;
  v_je uuid;
  v_roots_total_received numeric := 0;
  v_root record;
  v_root_share numeric;
  v_chain_onhand numeric;
  v_inventory_part numeric;
  v_cogs_part numeric;
  v_batch record;
  v_batch_credit numeric;
  v_new_cost numeric;
  v_line record;
begin
  perform public._require_staff('apply_supplier_credit_note');
  if not (auth.role() = 'service_role' or public.has_admin_permission('accounting.manage')) then
    raise exception 'not authorized';
  end if;
  if p_credit_note_id is null then
    raise exception 'p_credit_note_id is required';
  end if;

  select *
  into v_note
  from public.supplier_credit_notes n
  where n.id = p_credit_note_id
  for update;
  if not found then
    raise exception 'supplier credit note not found';
  end if;
  if v_note.status = 'applied' then
    return;
  end if;
  if v_note.status = 'cancelled' then
    raise exception 'credit note is cancelled';
  end if;

  v_total_amount := coalesce(v_note.amount, 0);
  if v_total_amount <= 0 then
    raise exception 'invalid amount';
  end if;

  v_ap := public.get_account_id_by_code('2010');
  v_inv := public.get_account_id_by_code('1410');
  v_cogs := public.get_account_id_by_code('5010');
  if v_ap is null or v_inv is null or v_cogs is null then
    raise exception 'required accounts missing';
  end if;

  select coalesce(sum(coalesce(b.quantity_received,0)),0)
  into v_roots_total_received
  from public.batches b
  where b.receipt_id = v_note.reference_purchase_receipt_id;

  if v_roots_total_received <= 0 then
    raise exception 'no batches for receipt';
  end if;

  insert into public.journal_entries(entry_date, memo, source_table, source_id, source_event, created_by, status)
  values (
    now(),
    concat('Supplier credit note ', v_note.id::text),
    'supplier_credit_notes',
    v_note.id::text,
    'applied',
    auth.uid(),
    'posted'
  )
  on conflict (source_table, source_id, source_event)
  do update set entry_date = excluded.entry_date, memo = excluded.memo
  returning id into v_je;

  delete from public.journal_lines jl where jl.journal_entry_id = v_je;

  delete from public.supplier_credit_note_allocations a where a.credit_note_id = v_note.id;

  v_inventory_part := 0;
  v_cogs_part := 0;

  for v_root in
    select
      b.id as root_batch_id,
      b.item_id,
      b.quantity_received,
      b.cost_per_unit,
      b.unit_cost
    from public.batches b
    where b.receipt_id = v_note.reference_purchase_receipt_id
    order by b.created_at asc, b.id asc
  loop
    v_root_share := v_total_amount * (coalesce(v_root.quantity_received,0) / v_roots_total_received);

    with recursive chain as (
      select b.id
      from public.batches b
      where b.id = v_root.root_batch_id
      union all
      select b2.id
      from public.batches b2
      join chain c on (b2.data->>'sourceBatchId')::uuid = c.id
      where b2.data ? 'sourceBatchId'
    )
    select coalesce(sum(greatest(coalesce(b.quantity_received,0) - coalesce(b.quantity_consumed,0) - coalesce(b.quantity_transferred,0), 0)), 0)
    into v_chain_onhand
    from chain c
    join public.batches b on b.id = c.id;

    if coalesce(v_root.quantity_received,0) <= 0 then
      continue;
    end if;

    v_inventory_part := v_inventory_part + (v_root_share * (greatest(coalesce(v_chain_onhand,0),0) / coalesce(v_root.quantity_received,0)));
    v_cogs_part := v_cogs_part + (v_root_share - (v_root_share * (greatest(coalesce(v_chain_onhand,0),0) / coalesce(v_root.quantity_received,0))));

    insert into public.supplier_credit_note_allocations(
      credit_note_id,
      root_batch_id,
      affected_batch_id,
      receipt_id,
      amount_total,
      amount_to_inventory,
      amount_to_cogs,
      batch_qty_received,
      batch_qty_onhand,
      batch_qty_sold,
      unit_cost_before,
      unit_cost_after
    )
    values (
      v_note.id,
      v_root.root_batch_id,
      v_root.root_batch_id,
      v_note.reference_purchase_receipt_id,
      v_root_share,
      v_root_share * (greatest(coalesce(v_chain_onhand,0),0) / coalesce(v_root.quantity_received,0)),
      v_root_share - (v_root_share * (greatest(coalesce(v_chain_onhand,0),0) / coalesce(v_root.quantity_received,0))),
      coalesce(v_root.quantity_received,0),
      greatest(coalesce(v_chain_onhand,0),0),
      greatest(coalesce(v_root.quantity_received,0) - greatest(coalesce(v_chain_onhand,0),0), 0),
      coalesce(v_root.cost_per_unit, v_root.unit_cost, 0),
      coalesce(v_root.cost_per_unit, v_root.unit_cost, 0)
    );

    if coalesce(v_chain_onhand,0) <= 0 then
      continue;
    end if;

    for v_batch in
      with recursive chain as (
        select b.id
        from public.batches b
        where b.id = v_root.root_batch_id
        union all
        select b2.id
        from public.batches b2
        join chain c on (b2.data->>'sourceBatchId')::uuid = c.id
        where b2.data ? 'sourceBatchId'
      )
      select
        b.id as batch_id,
        b.cost_per_unit,
        b.unit_cost,
        greatest(coalesce(b.quantity_received,0) - coalesce(b.quantity_consumed,0) - coalesce(b.quantity_transferred,0), 0) as remaining
      from chain c
      join public.batches b on b.id = c.id
      where greatest(coalesce(b.quantity_received,0) - coalesce(b.quantity_consumed,0) - coalesce(b.quantity_transferred,0), 0) > 0
      for update
    loop
      v_batch_credit :=
        (v_root_share * (v_chain_onhand / coalesce(v_root.quantity_received,0))) * (v_batch.remaining / v_chain_onhand);

      v_new_cost := greatest(0, coalesce(v_batch.cost_per_unit, v_batch.unit_cost, 0) - (v_batch_credit / v_batch.remaining));

      update public.batches
      set cost_per_unit = v_new_cost,
          unit_cost = v_new_cost
      where id = v_batch.batch_id;

      insert into public.supplier_credit_note_allocations(
        credit_note_id,
        root_batch_id,
        affected_batch_id,
        receipt_id,
        amount_total,
        amount_to_inventory,
        amount_to_cogs,
        batch_qty_received,
        batch_qty_onhand,
        batch_qty_sold,
        unit_cost_before,
        unit_cost_after
      )
      values (
        v_note.id,
        v_root.root_batch_id,
        v_batch.batch_id,
        v_note.reference_purchase_receipt_id,
        v_root_share,
        v_batch_credit,
        0,
        coalesce(v_root.quantity_received,0),
        v_batch.remaining,
        0,
        coalesce(v_batch.cost_per_unit, v_batch.unit_cost, 0),
        v_new_cost
      );
    end loop;
  end loop;

  v_inventory_part := public._money_round(v_inventory_part);
  v_cogs_part := public._money_round(v_cogs_part);

  if v_inventory_part + v_cogs_part > v_total_amount + 0.01 then
    raise exception 'allocation exceeded amount';
  end if;

  insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
  values (v_je, v_ap, v_total_amount, 0, 'Supplier credit note');

  if v_inventory_part > 0 then
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values (v_je, v_inv, 0, v_inventory_part, 'Reduce inventory cost');
  end if;
  if v_cogs_part > 0 then
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values (v_je, v_cogs, 0, v_cogs_part, 'Reduce COGS');
  end if;

  update public.supplier_credit_notes
  set status = 'applied',
      applied_at = now(),
      journal_entry_id = v_je,
      updated_at = now()
  where id = v_note.id;
end;
$$;


ALTER FUNCTION "public"."apply_supplier_credit_note"("p_credit_note_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."approval_required"("p_request_type" "text", "p_amount" numeric) RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_count int;
begin
  select count(*)
  into v_count
  from public.approval_policies p
  where p.request_type = p_request_type
    and p.is_active = true
    and p.min_amount <= coalesce(p_amount, 0)
    and (p.max_amount is null or p.max_amount >= coalesce(p_amount, 0));
  return v_count > 0;
end;
$$;


ALTER FUNCTION "public"."approval_required"("p_request_type" "text", "p_amount" numeric) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."approve_approval_step"("p_request_id" "uuid", "p_step_no" integer) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_requested_by uuid;
  v_required_role text;
  v_actor_role text;
  v_remaining int;
begin
  select ar.requested_by
  into v_requested_by
  from public.approval_requests ar
  where ar.id = p_request_id;

  if v_requested_by is null then
    raise exception 'approval request not found';
  end if;

  if auth.uid() is null then
    raise exception 'not authenticated';
  end if;

  if v_requested_by = auth.uid() then
    raise exception 'self_approval_forbidden';
  end if;

  select s.approver_role
  into v_required_role
  from public.approval_steps s
  where s.request_id = p_request_id
    and s.step_no = p_step_no;

  if v_required_role is null then
    raise exception 'approval step not found';
  end if;

  select au.role
  into v_actor_role
  from public.admin_users au
  where au.auth_user_id = auth.uid()
    and au.is_active = true
  limit 1;

  if v_actor_role is null then
    raise exception 'not authorized';
  end if;

  if v_actor_role <> v_required_role and v_actor_role <> 'owner' then
    raise exception 'not authorized';
  end if;

  update public.approval_steps
  set status = 'approved', action_by = auth.uid(), action_at = now()
  where request_id = p_request_id
    and step_no = p_step_no
    and status = 'pending';

  if not found then
    raise exception 'approval step not pending';
  end if;

  select count(*)
  into v_remaining
  from public.approval_steps
  where request_id = p_request_id and status <> 'approved';

  if v_remaining = 0 then
    update public.approval_requests
    set status = 'approved', approved_by = auth.uid(), approved_at = now()
    where id = p_request_id;
  end if;
end;
$$;


ALTER FUNCTION "public"."approve_approval_step"("p_request_id" "uuid", "p_step_no" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."approve_journal_entry"("p_entry_id" "uuid") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_entry public.journal_entries%rowtype;
  v_debit numeric;
  v_credit numeric;
begin
  if not public.has_admin_permission('accounting.approve') then
    raise exception 'not allowed';
  end if;

  if p_entry_id is null then
    raise exception 'p_entry_id is required';
  end if;

  select *
  into v_entry
  from public.journal_entries je
  where je.id = p_entry_id
  for update;

  if not found then
    raise exception 'journal entry not found';
  end if;

  if v_entry.source_table <> 'manual' then
    raise exception 'not allowed';
  end if;

  if v_entry.status <> 'draft' then
    return v_entry.id;
  end if;

  select coalesce(sum(jl.debit), 0), coalesce(sum(jl.credit), 0)
  into v_debit, v_credit
  from public.journal_lines jl
  where jl.journal_entry_id = p_entry_id;

  if v_debit <= 0 and v_credit <= 0 then
    raise exception 'empty entry';
  end if;

  if abs(coalesce(v_debit, 0) - coalesce(v_credit, 0)) > 1e-6 then
    raise exception 'entry not balanced';
  end if;

  perform set_config('app.accounting_bypass', '1', true);
  update public.journal_entries
  set status = 'posted',
      approved_by = auth.uid(),
      approved_at = now()
  where id = p_entry_id;

  insert into public.system_audit_logs(action, module, details, performed_by, performed_at, metadata, risk_level, reason_code)
  values (
    'journal_entries.approve',
    'accounting',
    p_entry_id::text,
    auth.uid(),
    now(),
    jsonb_build_object('entryId', p_entry_id::text),
    'MEDIUM',
    'ACCOUNTING_APPROVE'
  );

  return p_entry_id;
end;
$$;


ALTER FUNCTION "public"."approve_journal_entry"("p_entry_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."ar_aging_as_of"("p_as_of" timestamp with time zone) RETURNS TABLE("invoice_id" "uuid", "journal_entry_id" "uuid", "original_amount" numeric, "open_balance" numeric, "days_past_due" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  return query
  select
    a.invoice_id,
    a.journal_entry_id,
    a.original_amount,
    a.open_balance,
    greatest(0, (p_as_of::date - je.entry_date::date))::int as days_past_due
  from public.ar_open_items a
  join public.journal_entries je on je.id = a.journal_entry_id
  where a.status = 'open';
end;
$$;


ALTER FUNCTION "public"."ar_aging_as_of"("p_as_of" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."ar_aging_summary"("p_as_of" "date" DEFAULT CURRENT_DATE) RETURNS TABLE("customer_auth_user_id" "uuid", "current" numeric, "days_1_30" numeric, "days_31_60" numeric, "days_61_90" numeric, "days_91_plus" numeric, "total_outstanding" numeric)
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if not public.has_admin_permission('accounting.view') then
    raise exception 'not allowed';
  end if;

  return query
  with delivered as (
    select
      o.id as order_id,
      o.customer_auth_user_id,
      o.updated_at::date as invoice_date,
      coalesce(nullif((o.data->>'total')::numeric, null), 0) as total
    from public.orders o
    where o.status = 'delivered'
      and o.updated_at::date <= p_as_of
  ),
  paid as (
    select
      p.reference_id::uuid as order_id,
      coalesce(sum(p.amount), 0) as paid
    from public.payments p
    where p.reference_table = 'orders'
      and p.direction = 'in'
      and p.occurred_at::date <= p_as_of
    group by p.reference_id
  ),
  open_items as (
    select
      d.customer_auth_user_id,
      greatest(0, d.total - coalesce(p.paid, 0)) as outstanding,
      (p_as_of - d.invoice_date) as age_days
    from delivered d
    left join paid p on p.order_id = d.order_id
    where (d.total - coalesce(p.paid, 0)) > 1e-9
  )
  select
    oi.customer_auth_user_id,
    coalesce(sum(case when oi.age_days <= 0 then oi.outstanding else 0 end), 0) as current,
    coalesce(sum(case when oi.age_days between 1 and 30 then oi.outstanding else 0 end), 0) as days_1_30,
    coalesce(sum(case when oi.age_days between 31 and 60 then oi.outstanding else 0 end), 0) as days_31_60,
    coalesce(sum(case when oi.age_days between 61 and 90 then oi.outstanding else 0 end), 0) as days_61_90,
    coalesce(sum(case when oi.age_days >= 91 then oi.outstanding else 0 end), 0) as days_91_plus,
    coalesce(sum(oi.outstanding), 0) as total_outstanding
  from open_items oi
  group by oi.customer_auth_user_id
  order by total_outstanding desc;
end;
$$;


ALTER FUNCTION "public"."ar_aging_summary"("p_as_of" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."assert_balance_sheet"("p_as_of" timestamp with time zone) RETURNS "void"
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_assets numeric;
  v_le numeric;
begin
  if not (auth.role() = 'service_role' or public.has_admin_permission('accounting.view')) then
    raise exception 'not allowed';
  end if;

  select
    sum(case when coa.account_type = 'asset' then b.balance else 0 end),
    sum(case when coa.account_type in ('liability','equity') then b.balance else 0 end)
  into v_assets, v_le
  from public.balances_as_of(p_as_of) b
  join public.chart_of_accounts coa on coa.id = b.account_id
  where coa.account_type in ('asset','liability','equity')
    and coa.is_active = true;

  if abs(coalesce(v_assets,0) - coalesce(v_le,0)) > 1e-6 then
    raise exception 'Balance Sheet not balanced (assets %, liabilities+equity %)', v_assets, v_le;
  end if;
end;
$$;


ALTER FUNCTION "public"."assert_balance_sheet"("p_as_of" timestamp with time zone) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."assert_balance_sheet"("p_as_of" timestamp with time zone) IS 'Purpose: hard assertion that Assets = Liabilities + Equity as-of timestamp. Source of truth: balances_as_of() and chart_of_accounts classifications.';



CREATE OR REPLACE FUNCTION "public"."assert_trial_balance_by_range"("p_start" "date", "p_end" "date") RETURNS "void"
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_d numeric;
  v_c numeric;
begin
  if not (auth.role() = 'service_role' or public.has_admin_permission('accounting.view')) then
    raise exception 'not allowed';
  end if;

  select
    coalesce(sum(tb.total_debits), 0),
    coalesce(sum(tb.total_credits), 0)
  into v_d, v_c
  from public.trial_balance_by_range(p_start, p_end) tb;

  if abs(coalesce(v_d,0) - coalesce(v_c,0)) > 1e-6 then
    raise exception 'Trial balance not balanced (debits %, credits %)', v_d, v_c;
  end if;
end;
$$;


ALTER FUNCTION "public"."assert_trial_balance_by_range"("p_start" "date", "p_end" "date") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."assert_trial_balance_by_range"("p_start" "date", "p_end" "date") IS 'Purpose: hard assertion that debits = credits for a date range. Source of truth: trial_balance_by_range().';



CREATE OR REPLACE FUNCTION "public"."assign_invoice_number_if_missing"("p_order_id" "uuid") RETURNS "text"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_num text;
begin
  if not public.is_staff() then
    raise exception 'not allowed';
  end if;

  select invoice_number into v_num from public.orders where id = p_order_id for update;
  if v_num is null or length(trim(v_num)) = 0 then
    v_num := public.generate_invoice_number();
    update public.orders
    set invoice_number = v_num,
        updated_at = now()
    where id = p_order_id;
  end if;
  return v_num;
end;
$$;


ALTER FUNCTION "public"."assign_invoice_number_if_missing"("p_order_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."audit_changed_columns"("p_old" "jsonb", "p_new" "jsonb") RETURNS "text"[]
    LANGUAGE "plpgsql"
    AS $$
declare
  k text;
  keys text[];
  result text[] := '{}'::text[];
begin
  if p_old is null then
    p_old := '{}'::jsonb;
  end if;
  if p_new is null then
    p_new := '{}'::jsonb;
  end if;

  select array_agg(distinct key)
  into keys
  from (
    select jsonb_object_keys(p_old) as key
    union all
    select jsonb_object_keys(p_new) as key
  ) s;

  if keys is null then
    return result;
  end if;

  foreach k in array keys loop
    if (p_old -> k) is distinct from (p_new -> k) then
      result := array_append(result, k);
    end if;
  end loop;

  return result;
end;
$$;


ALTER FUNCTION "public"."audit_changed_columns"("p_old" "jsonb", "p_new" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."audit_get_record_id"("p_table" "text", "p_row" "jsonb") RETURNS "text"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  IF p_row IS NULL THEN
    RETURN NULL;
  END IF;

  CASE p_table
    WHEN 'admin_users' THEN RETURN p_row->>'auth_user_id';
    WHEN 'customers' THEN RETURN p_row->>'auth_user_id';
    WHEN 'orders' THEN RETURN p_row->>'id';
    WHEN 'menu_items' THEN RETURN p_row->>'id';
    WHEN 'stock_management' THEN RETURN p_row->>'item_id';
    WHEN 'purchase_orders' THEN RETURN p_row->>'id';
    WHEN 'purchase_items' THEN RETURN p_row->>'id';
    WHEN 'addons' THEN RETURN p_row->>'id';
    WHEN 'delivery_zones' THEN RETURN p_row->>'id';
    WHEN 'coupons' THEN RETURN p_row->>'id';
    WHEN 'ads' THEN RETURN p_row->>'id';
    WHEN 'challenges' THEN RETURN p_row->>'id';
    WHEN 'app_settings' THEN RETURN p_row->>'id';
    WHEN 'item_categories' THEN RETURN p_row->>'id';
    WHEN 'unit_types' THEN RETURN p_row->>'id';
    WHEN 'freshness_levels' THEN RETURN p_row->>'id';
    WHEN 'banks' THEN RETURN p_row->>'id';
    WHEN 'transfer_recipients' THEN RETURN p_row->>'id';
    WHEN 'reviews' THEN RETURN p_row->>'id';
    ELSE
      IF (p_row ? 'id') THEN RETURN p_row->>'id'; END IF;
      RETURN NULL;
  END CASE;
END;
$$;


ALTER FUNCTION "public"."audit_get_record_id"("p_table" "text", "p_row" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."audit_row_change"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_table text := tg_table_name;
  v_op text := lower(tg_op);
  v_row jsonb;
  v_old jsonb;
  v_new jsonb;
  v_record_id text;
  v_changed text[];
  v_changed_filtered text[] := '{}'::text[];
  v_key text;
  v_metadata jsonb;
  v_risk_level text;
  v_reason_code text;
BEGIN
  IF auth.uid() IS NULL THEN
    IF tg_op = 'DELETE' THEN RETURN old; END IF;
    RETURN new;
  END IF;

  IF v_table IN ('customers', 'reviews') AND NOT public.is_admin() THEN
    IF tg_op = 'DELETE' THEN RETURN old; END IF;
    RETURN new;
  END IF;

  -- Try to capture reason from session setting (set by app before critical ops)
  -- App should run: set_config('app.audit_reason', 'USER_CANCELLATION', true);
  BEGIN
    v_reason_code := current_setting('app.audit_reason', true);
  EXCEPTION WHEN OTHERS THEN
    v_reason_code := NULL;
  END;

  v_metadata := jsonb_build_object(
    'table', v_table,
    'op', v_op
  );

  IF tg_op = 'INSERT' THEN
    v_new := to_jsonb(new);
    v_row := v_new;
    v_record_id := public.audit_get_record_id(v_table, v_row);
    v_metadata := v_metadata || jsonb_build_object('recordId', v_record_id, 'new_values', v_new);
    v_risk_level := public.calculate_risk_level(v_table, v_op, NULL, v_new);
  
  ELSIF tg_op = 'UPDATE' THEN
    v_old := to_jsonb(old);
    v_new := to_jsonb(new);
    v_row := v_new;
    v_record_id := public.audit_get_record_id(v_table, v_row);
    
    v_changed := public.audit_changed_columns(v_old, v_new);
    
    IF v_changed IS NOT NULL THEN
      FOREACH v_key IN ARRAY v_changed LOOP
        IF v_key NOT IN ('updated_at', 'created_at', 'last_updated') THEN
          v_changed_filtered := array_append(v_changed_filtered, v_key);
        END IF;
      END LOOP;
    END IF;

    IF array_length(v_changed_filtered, 1) IS NULL THEN
      RETURN new;
    END IF;

    v_metadata := v_metadata || jsonb_build_object(
        'recordId', v_record_id, 
        'changedColumns', v_changed_filtered,
        'old_values', v_old,
        'new_values', v_new
    );
    v_risk_level := public.calculate_risk_level(v_table, v_op, v_old, v_new);

  ELSE -- DELETE
    v_old := to_jsonb(old);
    v_row := v_old;
    v_record_id := public.audit_get_record_id(v_table, v_row);
    v_metadata := v_metadata || jsonb_build_object('recordId', v_record_id, 'old_values', v_old);
    v_risk_level := public.calculate_risk_level(v_table, v_op, v_old, NULL);
  END IF;

  -- Enforce Reason Code for HIGH risk operations if missing (Soft Check for now to avoid breakage, but logs warning)
  IF v_risk_level = 'HIGH' AND v_reason_code IS NULL THEN
     v_reason_code := 'MISSING_REASON';
     -- In strict mode, we would: RAISE EXCEPTION 'Reason code is required for high risk operations';
  END IF;

  INSERT INTO public.system_audit_logs(action, module, details, performed_by, performed_at, metadata, risk_level, reason_code)
  VALUES (
    v_table || '.' || v_op,
    public.audit_table_module(v_table),
    jsonb_build_object(
      'recordId', v_record_id,
      'changedColumns', v_changed_filtered,
      'risk', v_risk_level
    )::text,
    auth.uid(),
    now(),
    v_metadata,
    v_risk_level,
    v_reason_code
  );

  IF tg_op = 'DELETE' THEN
    RETURN old;
  END IF;
  RETURN new;
END;
$$;


ALTER FUNCTION "public"."audit_row_change"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."audit_table_module"("p_table" "text") RETURNS "text"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  CASE p_table
    WHEN 'admin_users' THEN RETURN 'auth';
    WHEN 'customers' THEN RETURN 'customers';
    WHEN 'menu_items' THEN RETURN 'inventory';
    WHEN 'addons' THEN RETURN 'inventory';
    WHEN 'stock_management' THEN RETURN 'inventory';
    WHEN 'purchase_orders' THEN RETURN 'purchasing';
    WHEN 'purchase_items' THEN RETURN 'purchasing';
    WHEN 'delivery_zones' THEN RETURN 'orders';
    WHEN 'orders' THEN RETURN 'orders';
    WHEN 'coupons' THEN RETURN 'orders';
    WHEN 'ads' THEN RETURN 'marketing';
    WHEN 'challenges' THEN RETURN 'marketing';
    WHEN 'app_settings' THEN RETURN 'settings';
    WHEN 'item_categories' THEN RETURN 'inventory';
    WHEN 'unit_types' THEN RETURN 'inventory';
    WHEN 'freshness_levels' THEN RETURN 'inventory';
    WHEN 'banks' THEN RETURN 'settings';
    WHEN 'transfer_recipients' THEN RETURN 'settings';
    WHEN 'reviews' THEN RETURN 'reviews';
    ELSE
      RETURN 'system';
  END CASE;
END;
$$;


ALTER FUNCTION "public"."audit_table_module"("p_table" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."backfill_batches_from_movements"() RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
declare
  v_inserted int := 0;
  v_updated int := 0;
  v_default_wh uuid;
  v_im record;
  v_receipt_id uuid;
  v_receipt_item_id uuid;
  v_expiry date;
  v_production date;
  v_wh uuid;
  v_consumed numeric;
begin
  --     
  if to_regclass('public.warehouses') is not null then
    select w.id
    into v_default_wh
    from public.warehouses w
    where w.is_active = true
    order by (upper(coalesce(w.code,''))='MAIN') desc, w.code asc
    limit 1;
  else
    v_default_wh := null;
  end if;

  for v_im in
    select *
    from public.inventory_movements im
    where im.movement_type = 'purchase_in'
      and im.batch_id is not null
  loop
    v_receipt_id := null;
    v_receipt_item_id := null;
    v_wh := coalesce(
      v_im.warehouse_id,
      case
        when (v_im.data ? 'warehouseId') and (v_im.data->>'warehouseId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
          then (v_im.data->>'warehouseId')::uuid
        else v_default_wh
      end
    );

    -- receipt_id  reference   data
    if coalesce(v_im.reference_table,'') = 'purchase_receipts' then
      begin
        if coalesce(v_im.reference_id,'') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$' then
          v_receipt_id := v_im.reference_id::uuid;
        end if;
      exception when others then
        v_receipt_id := null;
      end;
    end if;
    if v_receipt_id is null and (v_im.data ? 'purchaseReceiptId') then
      begin
        v_receipt_id := (v_im.data->>'purchaseReceiptId')::uuid;
      exception when others then
        v_receipt_id := null;
      end;
    end if;

    if v_receipt_id is not null then
      select pri.id
      into v_receipt_item_id
      from public.purchase_receipt_items pri
      where pri.receipt_id = v_receipt_id
        and pri.item_id = v_im.item_id
      limit 1;
    end if;

    --  /
    v_expiry := null;
    v_production := null;
    if (v_im.data ? 'expiryDate') and (v_im.data->>'expiryDate') ~ '^[0-9]{4}-[0-9]{2}-[0-9]{2}$' then
      v_expiry := (v_im.data->>'expiryDate')::date;
    end if;
    if (v_im.data ? 'harvestDate') and (v_im.data->>'harvestDate') ~ '^[0-9]{4}-[0-9]{2}-[0-9]{2}$' then
      v_production := (v_im.data->>'harvestDate')::date;
    end if;

    --     
    select coalesce(sum(im2.quantity), 0)
    into v_consumed
    from public.inventory_movements im2
    where im2.batch_id = v_im.batch_id
      and im2.movement_type in ('sale_out','wastage_out','adjust_out','return_out','transfer_out');

    if exists (select 1 from public.batches b where b.id = v_im.batch_id) then
      update public.batches
      set item_id = v_im.item_id,
          receipt_item_id = v_receipt_item_id,
          receipt_id = v_receipt_id,
          warehouse_id = v_wh,
          unit_cost = v_im.unit_cost,
          quantity_received = v_im.quantity,
          quantity_consumed = least(greatest(v_consumed, 0), v_im.quantity),
          expiry_date = coalesce(v_expiry, expiry_date),
          production_date = coalesce(v_production, production_date),
          data = coalesce(data, '{}'::jsonb) || jsonb_build_object('source','backfill')
      where id = v_im.batch_id;
      v_updated := v_updated + 1;
    else
      insert into public.batches(
        id, item_id, receipt_item_id, receipt_id, warehouse_id,
        batch_code, production_date, expiry_date,
        quantity_received, quantity_consumed, unit_cost, data
      )
      values (
        v_im.batch_id, v_im.item_id, v_receipt_item_id, v_receipt_id, v_wh,
        null, v_production, v_expiry,
        v_im.quantity, least(greatest(v_consumed,0), v_im.quantity), v_im.unit_cost,
        jsonb_build_object('source','backfill')
      );
      v_inserted := v_inserted + 1;
    end if;
  end loop;

  return json_build_object('inserted', v_inserted, 'updated', v_updated);
end;
$_$;


ALTER FUNCTION "public"."backfill_batches_from_movements"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."balance_sheet"("p_as_of" "date", "p_cost_center_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("assets" numeric, "liabilities" numeric, "equity" numeric)
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  with tb as (
    select *
    from public.trial_balance(null, p_as_of, p_cost_center_id)
  ),
  sums as (
    select
      coalesce(sum(case when tb.account_type = 'asset' then (tb.debit - tb.credit) else 0 end), 0) as assets,
      coalesce(sum(case when tb.account_type = 'liability' then (tb.credit - tb.debit) else 0 end), 0) as liabilities,
      coalesce(sum(case when tb.account_type = 'equity' then (tb.credit - tb.debit) else 0 end), 0) as equity_base,
      coalesce(sum(case when tb.account_type = 'income' then (tb.credit - tb.debit) else 0 end), 0) as income_sum,
      coalesce(sum(case when tb.account_type = 'expense' then (tb.debit - tb.credit) else 0 end), 0) as expense_sum
    from tb
  )
  select
    s.assets,
    s.liabilities,
    (s.equity_base + (s.income_sum - s.expense_sum)) as equity
  from sums s;
$$;


ALTER FUNCTION "public"."balance_sheet"("p_as_of" "date", "p_cost_center_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."balances_as_of"("p_as_of" timestamp with time zone) RETURNS TABLE("account_id" "uuid", "balance" numeric)
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_period_id uuid;
  v_end date;
  v_from timestamptz;
begin
  if not (auth.role() = 'service_role' or public.has_admin_permission('accounting.view')) then
    raise exception 'not allowed';
  end if;

  if p_as_of is null then
    raise exception 'p_as_of is required';
  end if;

  select ap.id, ap.end_date
  into v_period_id, v_end
  from public.accounting_periods ap
  where ap.status = 'closed'
    and ap.end_date < (p_as_of::date)
    and exists (
      select 1
      from public.accounting_period_snapshots aps
      where aps.period_id = ap.id
      limit 1
    )
  order by ap.end_date desc
  limit 1;

  if v_period_id is null then
    return query
    select
      coa.id as account_id,
      coalesce(sum(
        case
          when coa.normal_balance = 'debit' then jl.debit - jl.credit
          else jl.credit - jl.debit
        end
      ), 0) as balance
    from public.chart_of_accounts coa
    left join public.journal_lines jl on jl.account_id = coa.id
    left join public.journal_entries je
      on je.id = jl.journal_entry_id
     and je.entry_date <= p_as_of
    where coa.is_active = true
    group by coa.id;
    return;
  end if;

  v_from := ((v_end + 1)::timestamptz);

  return query
  with base as (
    select aps.account_id, aps.closing_balance
    from public.accounting_period_snapshots aps
    where aps.period_id = v_period_id
  ),
  delta as (
    select
      coa.id as account_id,
      coalesce(sum(
        case
          when coa.normal_balance = 'debit' then jl.debit - jl.credit
          else jl.credit - jl.debit
        end
      ), 0) as delta_balance
    from public.chart_of_accounts coa
    left join public.journal_lines jl on jl.account_id = coa.id
    left join public.journal_entries je
      on je.id = jl.journal_entry_id
     and je.entry_date >= v_from
     and je.entry_date <= p_as_of
    where coa.is_active = true
    group by coa.id
  )
  select
    coa.id as account_id,
    coalesce(b.closing_balance, 0) + coalesce(d.delta_balance, 0) as balance
  from public.chart_of_accounts coa
  left join base b on b.account_id = coa.id
  left join delta d on d.account_id = coa.id
  where coa.is_active = true;
end;
$$;


ALTER FUNCTION "public"."balances_as_of"("p_as_of" timestamp with time zone) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."balances_as_of"("p_as_of" timestamp with time zone) IS 'Purpose: compute signed balances as-of timestamp using last available closed snapshot + post-snapshot deltas, or full journal scan when no snapshot exists. Source of truth: accounting_period_snapshots and journal_entries/journal_lines.';



CREATE OR REPLACE FUNCTION "public"."block_writes_during_maintenance"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  IF public.is_maintenance_on() AND NOT public.is_active_admin() THEN
    RAISE EXCEPTION 'Service unavailable during maintenance' USING errcode = 'U0001';
  END IF;
  IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
    RETURN NEW;
  ELSE
    RETURN OLD;
  END IF;
END;
$$;


ALTER FUNCTION "public"."block_writes_during_maintenance"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."branch_from_warehouse"("p_warehouse_id" "uuid") RETURNS "uuid"
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select w.branch_id from public.warehouses w where w.id = p_warehouse_id
$$;


ALTER FUNCTION "public"."branch_from_warehouse"("p_warehouse_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_cash_shift_expected"("p_shift_id" "uuid") RETURNS numeric
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_shift record;
  v_cash_in numeric;
  v_cash_out numeric;
begin
  if p_shift_id is null then
    raise exception 'p_shift_id is required';
  end if;

  select *
  into v_shift
  from public.cash_shifts s
  where s.id = p_shift_id;

  if not found then
    raise exception 'cash shift not found';
  end if;

  select
    coalesce(sum(case when p.direction = 'in' then p.amount else 0 end), 0),
    coalesce(sum(case when p.direction = 'out' then p.amount else 0 end), 0)
  into v_cash_in, v_cash_out
  from public.payments p
  where p.method = 'cash'
    and p.shift_id = p_shift_id;

  return coalesce(v_shift.start_amount, 0) + coalesce(v_cash_in, 0) - coalesce(v_cash_out, 0);
end;
$$;


ALTER FUNCTION "public"."calculate_cash_shift_expected"("p_shift_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_risk_level"("p_table" "text", "p_op" "text", "p_old" "jsonb", "p_new" "jsonb") RETURNS "text"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- DELETE operations are generally High Risk
  IF p_op = 'delete' THEN
    IF p_table IN ('orders', 'stock_management', 'purchase_orders', 'admin_users', 'journal_entries') THEN
        RETURN 'HIGH';
    END IF;
    RETURN 'MEDIUM';
  END IF;

  -- UPDATE operations
  IF p_op = 'update' THEN
    -- Orders: Status Change to Cancelled or Delivered is High/Medium
    IF p_table = 'orders' THEN
        IF (p_new->>'status') = 'cancelled' AND (p_old->>'status') <> 'cancelled' THEN
            RETURN 'HIGH';
        END IF;
        IF (p_new->>'status') = 'delivered' AND (p_old->>'status') <> 'delivered' THEN
            RETURN 'MEDIUM'; -- Delivery is normal but important
        END IF;
        -- Financial tampering check
        IF (p_new->>'total') <> (p_old->>'total') OR (p_new->>'subtotal') <> (p_old->>'subtotal') THEN
            RETURN 'HIGH';
        END IF;
    END IF;

    -- Stock: Quantity changes
    IF p_table = 'stock_management' THEN
        IF (p_new->>'available_quantity') <> (p_old->>'available_quantity') THEN
            RETURN 'MEDIUM'; -- Frequent but important
        END IF;
    END IF;

    -- Auth: Role/Permission changes
    IF p_table = 'admin_users' THEN
         RETURN 'HIGH';
    END IF;
  END IF;

  -- INSERT operations
  IF p_op = 'insert' THEN
     IF p_table IN ('admin_users') THEN
        RETURN 'HIGH';
     END IF;
  END IF;

  RETURN 'LOW';
END;
$$;


ALTER FUNCTION "public"."calculate_risk_level"("p_table" "text", "p_op" "text", "p_old" "jsonb", "p_new" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_shipment_landed_cost"("p_shipment_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_total_fob_value numeric;
  v_total_qty numeric;
  v_total_expenses numeric;
begin
  if p_shipment_id is null then
    raise exception 'p_shipment_id is required';
  end if;

  select
    coalesce(sum(isi.quantity * isi.unit_price_fob), 0),
    coalesce(sum(isi.quantity), 0)
  into v_total_fob_value, v_total_qty
  from public.import_shipments_items isi
  where isi.shipment_id = p_shipment_id;

  if coalesce(v_total_qty, 0) <= 0 then
    return;
  end if;

  select coalesce(sum(ie.amount * ie.exchange_rate), 0)
  into v_total_expenses
  from public.import_expenses ie
  where ie.shipment_id = p_shipment_id;

  if coalesce(v_total_fob_value, 0) > 0 then
    update public.import_shipments_items
    set landing_cost_per_unit = unit_price_fob * (1 + (coalesce(v_total_expenses, 0) / v_total_fob_value)),
        updated_at = now()
    where shipment_id = p_shipment_id;
  else
    update public.import_shipments_items
    set landing_cost_per_unit = unit_price_fob + (coalesce(v_total_expenses, 0) / v_total_qty),
        updated_at = now()
    where shipment_id = p_shipment_id;
  end if;
end;
$$;


ALTER FUNCTION "public"."calculate_shipment_landed_cost"("p_shipment_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_three_way_match"("p_invoice_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_line record;
  v_qty_po numeric;
  v_qty_grn numeric;
  v_price_po numeric;
  v_qty_tol numeric;
  v_price_tol numeric;
  v_status text;
begin
  delete from public.three_way_match_results where invoice_id = p_invoice_id;

  for v_line in
    select *
    from public.supplier_invoice_lines
    where invoice_id = p_invoice_id
  loop
    select coalesce(sum(pi.quantity), 0), coalesce(avg(pi.unit_cost), 0)
    into v_qty_po, v_price_po
    from public.purchase_items pi
    where pi.purchase_order_id = v_line.po_id
      and pi.item_id = v_line.item_id;

    select coalesce(sum(pri.quantity), 0)
    into v_qty_grn
    from public.purchase_receipt_items pri
    join public.purchase_receipts pr on pr.id = pri.receipt_id
    where pr.purchase_order_id = v_line.po_id
      and pri.item_id = v_line.item_id;

    select coalesce(it.qty_tolerance, 0), coalesce(it.price_tolerance, 0)
    into v_qty_tol, v_price_tol
    from public.invoice_tolerances it
    join public.supplier_invoices si on si.id = p_invoice_id
    where (it.supplier_id is null or it.supplier_id = si.supplier_id)
      and (it.item_id is null or it.item_id = v_line.item_id)
      and it.is_active = true
    order by (it.supplier_id is not null) desc, (it.item_id is not null) desc
    limit 1;

    if abs(coalesce(v_line.unit_price, 0) - coalesce(v_price_po, 0)) > v_price_tol then
      v_status := 'price_variance';
    elsif coalesce(v_line.quantity, 0) > coalesce(v_qty_grn, 0) + v_qty_tol then
      v_status := 'qty_variance';
    else
      v_status := 'matched';
    end if;

    insert into public.three_way_match_results(
      invoice_id, po_id, receipt_id, item_id,
      qty_po, qty_grn, qty_inv, price_po, price_inv, status
    )
    values (
      p_invoice_id, v_line.po_id, v_line.receipt_id, v_line.item_id,
      coalesce(v_qty_po, 0), coalesce(v_qty_grn, 0), coalesce(v_line.quantity, 0),
      coalesce(v_price_po, 0), coalesce(v_line.unit_price, 0), v_status
    );
  end loop;

  if exists (
    select 1 from public.three_way_match_results
    where invoice_id = p_invoice_id and status <> 'matched'
  ) then
    update public.supplier_invoices set status = 'exception' where id = p_invoice_id;
  else
    update public.supplier_invoices set status = 'matched' where id = p_invoice_id;
  end if;
end;
$$;


ALTER FUNCTION "public"."calculate_three_way_match"("p_invoice_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."can_manage_expenses"() RETURNS boolean
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select exists (
    select 1
    from public.admin_users au
    where au.auth_user_id = auth.uid()
      and au.is_active = true
      and (
        au.role in ('owner','manager')
        or ('expenses.manage' = any(coalesce(au.permissions, '{}'::text[])))
      )
  );
$$;


ALTER FUNCTION "public"."can_manage_expenses"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."can_manage_stock"() RETURNS boolean
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select exists (
    select 1
    from public.admin_users au
    where au.auth_user_id = auth.uid()
      and au.is_active = true
      and (
        au.role in ('owner','manager')
        or ('stock.manage' = any(coalesce(au.permissions, '{}'::text[])))
      )
  );
$$;


ALTER FUNCTION "public"."can_manage_stock"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."can_view_accounting_reports"() RETURNS boolean
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select public.has_admin_permission('accounting.view');
$$;


ALTER FUNCTION "public"."can_view_accounting_reports"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."can_view_reports"() RETURNS boolean
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select public.can_view_sales_reports();
$$;


ALTER FUNCTION "public"."can_view_reports"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."can_view_sales_reports"() RETURNS boolean
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select public.has_admin_permission('reports.view');
$$;


ALTER FUNCTION "public"."can_view_sales_reports"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."cancel_order"("p_order_id" "uuid", "p_reason" "text" DEFAULT NULL::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_order record;
  v_actor uuid;
  v_items jsonb;
  v_payload jsonb;
  v_payment_id uuid;
  v_warehouse_id uuid;
  v_wh_text text;
begin
  v_actor := auth.uid();
  if v_actor is null then
    raise exception 'not authenticated';
  end if;

  select * into v_order from public.orders where id = p_order_id for update;
  if not found then
    raise exception 'order not found';
  end if;

  if v_order.status in ('delivered','cancelled') then
    raise exception 'cannot cancel order in status %', v_order.status;
  end if;

  if not exists (
      select 1 from public.admin_users au
      where au.auth_user_id = v_actor
        and au.is_active = true
        and au.role in ('owner','manager','employee')
    )
    and v_order.customer_auth_user_id <> v_actor
  then
    raise exception 'not authorized';
  end if;

  v_wh_text := nullif(trim(coalesce(v_order.data->>'warehouseId', '')), '');
  if v_wh_text is not null then
    begin
      v_warehouse_id := v_wh_text::uuid;
    exception when others then
      v_warehouse_id := null;
    end;
  end if;
  if v_warehouse_id is null then
    select w.id
    into v_warehouse_id
    from public.warehouses w
    where w.is_active = true
    order by (upper(coalesce(w.code, '')) = 'MAIN') desc, w.code asc
    limit 1;
  end if;
  if v_warehouse_id is null then
    raise exception 'warehouse_id is required';
  end if;

  v_items := coalesce(v_order.items, v_order.data->'items');
  if v_items is null or jsonb_typeof(v_items) <> 'array' then
    v_items := '[]'::jsonb;
  end if;

  perform public.release_reserved_stock_for_order(
    (
      select jsonb_agg(
        jsonb_build_object(
          'itemId', coalesce(it->>'itemId', it->>'id'),
          'quantity', coalesce(nullif(it->>'quantity','')::numeric, 0)
        )
      )
      from jsonb_array_elements(v_items) as it
    ),
    p_order_id,
    v_warehouse_id
  );

  for v_payment_id in
    select p.id
    from public.payments p
    where p.reference_table = 'orders'
      and p.reference_id = p_order_id::text
      and p.direction = 'in'
  loop
    perform public.reverse_payment_journal(v_payment_id, coalesce(p_reason, 'ORDER_CANCELLED'));
  end loop;

  update public.orders
  set status = 'cancelled',
      data = jsonb_set(
        coalesce(data, '{}'::jsonb),
        '{cancellationReason}',
        to_jsonb(coalesce(p_reason, '')),
        true
      ),
      updated_at = now()
  where id = p_order_id;

  v_payload := jsonb_build_object('reason', p_reason);
  insert into public.order_events(order_id, action, actor_type, actor_id, to_status, payload)
  values (
    p_order_id,
    'order.cancelled',
    case when v_order.customer_auth_user_id = v_actor then 'customer' else 'admin' end,
    v_actor,
    'cancelled',
    v_payload
  );
end;
$$;


ALTER FUNCTION "public"."cancel_order"("p_order_id" "uuid", "p_reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."cancel_order"("p_order_id" "uuid", "p_reason" "text" DEFAULT NULL::"text", "p_occurred_at" timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_order record;
  v_is_cod boolean := false;
  v_wh uuid;
  v_items jsonb := '[]'::jsonb;
  v_mv record;
  v_has_sale_out boolean := false;
  v_reason text;
begin
  if auth.role() <> 'service_role' then
    if not public.is_staff() then
      raise exception 'not allowed';
    end if;
    if not (public.has_admin_permission('orders.cancel') or public.has_admin_permission('orders.updateStatus.all')) then
      raise exception 'not allowed';
    end if;
  end if;
  if p_order_id is null then
    raise exception 'p_order_id is required';
  end if;
  select *
  into v_order
  from public.orders o
  where o.id = p_order_id
  for update;
  if not found then
    raise exception 'order not found';
  end if;
  v_is_cod := public._is_cod_delivery_order(coalesce(v_order.data,'{}'::jsonb), v_order.delivery_zone_id);
  if coalesce(nullif(v_order.data->'invoiceSnapshot'->>'issuedAt',''), '') is not null then
    raise exception 'cannot_cancel_settled';
  end if;
  if v_is_cod and coalesce(nullif(v_order.data->>'paidAt',''), '') is not null then
    raise exception 'cannot_cancel_settled';
  end if;
  if exists (select 1 from public.cod_settlement_orders cso where cso.order_id = p_order_id) then
    raise exception 'cannot_cancel_settled';
  end if;
  select exists(
    select 1
    from public.inventory_movements im
    where im.reference_table = 'orders'
      and im.reference_id = p_order_id::text
      and im.movement_type = 'sale_out'
  )
  into v_has_sale_out;
  if v_has_sale_out then
    for v_mv in
      select *
      from public.inventory_movements im
      where im.reference_table = 'orders'
        and im.reference_id = p_order_id::text
        and im.movement_type = 'sale_out'
    loop
      insert into public.inventory_movements(
        item_id, movement_type, quantity, unit_cost, total_cost,
        reference_table, reference_id, occurred_at, created_by, data, batch_id, warehouse_id
      )
      values (
        v_mv.item_id,
        'return_in',
        v_mv.quantity,
        coalesce(v_mv.unit_cost, 0),
        coalesce(v_mv.quantity, 0) * coalesce(v_mv.unit_cost, 0),
        'orders',
        p_order_id::text,
        coalesce(p_occurred_at, now()),
        auth.uid(),
        jsonb_build_object('orderId', p_order_id),
        v_mv.batch_id,
        v_mv.warehouse_id
      )
      returning id into v_mv.id;
      perform public.post_inventory_movement(v_mv.id);
    end loop;
  else
    v_wh := coalesce(nullif(v_order.data->>'warehouseId','')::uuid, public._resolve_default_warehouse_id());
    for v_mv in
      select i
      from jsonb_array_elements(coalesce(v_order.data->'items','[]'::jsonb)) as t(i)
    loop
      v_items := v_items || jsonb_build_object(
        'itemId', coalesce(v_mv.i->>'itemId', v_mv.i->>'id'),
        'quantity', coalesce(nullif((v_mv.i->>'quantity')::numeric, null), 0)
      );
    end loop;
    v_items := public._merge_stock_items(v_items);
    if jsonb_array_length(v_items) > 0 then
      perform public.release_reserved_stock_for_order(v_items, p_order_id, v_wh);
    end if;
  end if;
  for v_mv in
    select p.id
    from public.payments p
    where p.reference_table = 'orders'
      and p.reference_id = p_order_id::text
      and p.direction = 'in'
  loop
    begin
      perform public.reverse_payment_journal(v_mv.id, coalesce(p_reason, 'order_cancel'));
    exception when others then
      null;
    end;
  end loop;
  v_reason := nullif(trim(coalesce(p_reason,'')),'');
  update public.orders
  set status = 'cancelled',
      data = jsonb_set(coalesce(v_order.data,'{}'::jsonb), '{cancelReason}', to_jsonb(coalesce(v_reason,'')), true),
      updated_at = now()
  where id = p_order_id;
end;
$$;


ALTER FUNCTION "public"."cancel_order"("p_order_id" "uuid", "p_reason" "text", "p_occurred_at" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."cancel_purchase_order"("p_order_id" "uuid", "p_reason" "text" DEFAULT NULL::"text", "p_occurred_at" timestamp with time zone DEFAULT "now"()) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_allowed boolean;
  v_has_receipts boolean;
  v_has_payments boolean;
  v_po record;
begin
  if p_order_id is null then
    raise exception 'p_order_id is required';
  end if;

  select exists(
    select 1
    from public.admin_users au
    where au.auth_user_id = auth.uid()
      and au.is_active = true
      and au.role in ('owner','manager')
  ) into v_allowed;

  if not coalesce(v_allowed, false) then
    raise exception 'not allowed';
  end if;

  select *
  into v_po
  from public.purchase_orders po
  where po.id = p_order_id
  for update;

  if not found then
    raise exception 'purchase order not found';
  end if;

  if v_po.status = 'cancelled' then
    return;
  end if;

  select exists(select 1 from public.purchase_receipts pr where pr.purchase_order_id = p_order_id)
  into v_has_receipts;

  select exists(
    select 1
    from public.payments p
    where p.reference_table = 'purchase_orders'
      and p.reference_id::text = p_order_id::text
  ) into v_has_payments;

  if coalesce(v_has_receipts, false) then
    raise exception 'cannot cancel received purchase order';
  end if;

  if coalesce(v_has_payments, false) or coalesce(v_po.paid_amount, 0) > 0 then
    raise exception 'cannot cancel paid purchase order';
  end if;

  update public.purchase_orders
  set status = 'cancelled',
      notes = case
        when nullif(trim(coalesce(p_reason, '')), '') is null then notes
        when nullif(trim(coalesce(notes, '')), '') is null then concat('[cancel] ', trim(p_reason))
        else concat(notes, E'\n', '[cancel] ', trim(p_reason))
      end,
      updated_at = now()
  where id = p_order_id;

  insert into public.system_audit_logs(action, module, details, performed_by, performed_at, metadata)
  values (
    'cancel',
    'purchases',
    concat('Cancelled purchase order ', p_order_id::text),
    auth.uid(),
    coalesce(p_occurred_at, now()),
    jsonb_build_object('purchaseOrderId', p_order_id::text, 'reason', nullif(trim(coalesce(p_reason, '')), ''))
  );
end;
$$;


ALTER FUNCTION "public"."cancel_purchase_order"("p_order_id" "uuid", "p_reason" "text", "p_occurred_at" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."cancel_warehouse_transfer"("p_transfer_id" "uuid", "p_reason" "text" DEFAULT NULL::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  --      
  IF NOT EXISTS (
    SELECT 1 FROM public.warehouse_transfers 
    WHERE id = p_transfer_id AND status = 'pending'
  ) THEN
    RAISE EXCEPTION 'Transfer not found or cannot be cancelled';
  END IF;
  
  --  
  UPDATE public.warehouse_transfers
  SET 
    status = 'cancelled',
    notes = COALESCE(notes || E'\n', '') || ': ' || COALESCE(p_reason, ' ')
  WHERE id = p_transfer_id;
  
  --    
  INSERT INTO public.system_audit_log (id, action, module, details, performed_by, performed_at)
  VALUES (
    gen_random_uuid(),
    'warehouse_transfer_cancelled',
    'inventory',
    format('Cancelled transfer %s. Reason: %s', p_transfer_id, COALESCE(p_reason, 'No reason')),
    auth.uid()::text,
    NOW()
  );
END;
$$;


ALTER FUNCTION "public"."cancel_warehouse_transfer"("p_transfer_id" "uuid", "p_reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."cash_flow_detailed"("p_start" "date", "p_end" "date") RETURNS TABLE("category" "text", "description" "text", "amount" numeric)
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  WITH cash_accounts AS (
    SELECT id FROM public.chart_of_accounts 
    WHERE code IN ('1010', '1020') AND is_active = true
  ),
  cash_movements AS (
    SELECT
      je.source_table,
      je.source_event,
      je.memo,
      SUM(jl.debit - jl.credit) as net_amount,
      je.entry_date
    FROM public.journal_lines jl
    JOIN public.journal_entries je ON je.id = jl.journal_entry_id
    WHERE jl.account_id IN (SELECT id FROM cash_accounts)
      AND (p_start IS NULL OR je.entry_date::date >= p_start)
      AND (p_end IS NULL OR je.entry_date::date <= p_end)
      AND public.can_view_reports()
    GROUP BY je.id, je.source_table, je.source_event, je.memo, je.entry_date
    HAVING SUM(jl.debit - jl.credit) != 0
  )
  SELECT
    'Operating' as category,
    COALESCE(
      CASE 
        WHEN cm.source_table = 'orders' THEN 'Cash from sales'
        WHEN cm.source_table = 'payments' AND cm.net_amount > 0 THEN 'Customer payments received'
        WHEN cm.source_table = 'payments' AND cm.net_amount < 0 THEN 'Supplier payments made'
        WHEN cm.source_table = 'expenses' THEN 'Operating expenses paid'
        WHEN cm.source_table = 'sales_returns' THEN 'Cash refunds for returns'
        WHEN cm.source_table = 'cash_shifts' THEN 'Cash shift adjustments'
        ELSE cm.memo
      END,
      'Other operating cash flow'
    ) as description,
    cm.net_amount as amount
  FROM cash_movements cm
  ORDER BY cm.entry_date, cm.net_amount DESC;
$$;


ALTER FUNCTION "public"."cash_flow_detailed"("p_start" "date", "p_end" "date") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."cash_flow_detailed"("p_start" "date", "p_end" "date") IS 'Returns detailed cash flow line items for the specified period';



CREATE OR REPLACE FUNCTION "public"."cash_flow_statement"("p_start" "date", "p_end" "date", "p_cost_center_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("operating_activities" numeric, "investing_activities" numeric, "financing_activities" numeric, "net_cash_flow" numeric, "opening_cash" numeric, "closing_cash" numeric)
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if not public.can_view_accounting_reports() then
    raise exception 'not allowed';
  end if;

  return query
  with cash_accounts as (
    select id from public.chart_of_accounts
    where code in ('1010', '1020') and is_active = true
  ),
  opening as (
    select coalesce(sum(jl.debit - jl.credit), 0) as opening_balance
    from public.journal_lines jl
    join public.journal_entries je on je.id = jl.journal_entry_id
    where jl.account_id in (select id from cash_accounts)
      and p_start is not null
      and je.entry_date::date < p_start
      and (p_cost_center_id is null or jl.cost_center_id = p_cost_center_id)
  ),
  operating as (
    select coalesce(sum(
      case
        when coa.code in ('1010', '1020') then (jl.debit - jl.credit)
        else 0
      end
    ), 0) as operating_cash
    from public.journal_lines jl
    join public.journal_entries je on je.id = jl.journal_entry_id
    join public.chart_of_accounts coa on coa.id = jl.account_id
    where (p_start is null or je.entry_date::date >= p_start)
      and (p_end is null or je.entry_date::date <= p_end)
      and je.source_table in ('orders', 'payments', 'expenses', 'sales_returns', 'cash_shifts')
      and (p_cost_center_id is null or jl.cost_center_id = p_cost_center_id)
  ),
  investing as (
    select 0::numeric as investing_cash
  ),
  financing as (
    select 0::numeric as financing_cash
  ),
  closing as (
    select coalesce(sum(jl.debit - jl.credit), 0) as closing_balance
    from public.journal_lines jl
    join public.journal_entries je on je.id = jl.journal_entry_id
    where jl.account_id in (select id from cash_accounts)
      and (p_end is null or je.entry_date::date <= p_end)
      and (p_cost_center_id is null or jl.cost_center_id = p_cost_center_id)
  )
  select
    (select operating_cash from operating) as operating_activities,
    (select investing_cash from investing) as investing_activities,
    (select financing_cash from financing) as financing_activities,
    (select operating_cash from operating)
      + (select investing_cash from investing)
      + (select financing_cash from financing) as net_cash_flow,
    (select opening_balance from opening) as opening_cash,
    (select closing_balance from closing) as closing_cash;
end;
$$;


ALTER FUNCTION "public"."cash_flow_statement"("p_start" "date", "p_end" "date", "p_cost_center_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_batch_invariants"("p_item_id" "text" DEFAULT NULL::"text", "p_warehouse_id" "uuid" DEFAULT NULL::"uuid") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_over_consumed int := 0;
  v_negative_remaining int := 0;
  v_reserved_exceeds int := 0;
  v_totals_exceed int := 0;
  v_result json;
begin
  select count(*) into v_over_consumed
  from public.batches b
  where (p_item_id is null or b.item_id = p_item_id)
    and (p_warehouse_id is null or b.warehouse_id is not distinct from p_warehouse_id)
    and coalesce(b.quantity_consumed,0) > coalesce(b.quantity_received,0);

  select count(*) into v_negative_remaining
  from public.batches b
  where (p_item_id is null or b.item_id = p_item_id)
    and (p_warehouse_id is null or b.warehouse_id is not distinct from p_warehouse_id)
    and ((coalesce(b.quantity_received,0) - coalesce(b.quantity_consumed,0)) < 0);

  with sm as (
    select sm.item_id::text as item_id_text, sm.warehouse_id, sm.data->'reservedBatches' as rb
    from public.stock_management sm
  ),
  entries as (
    select sm.item_id_text, sm.warehouse_id, e.key as batch_id_text, e.value as entry
    from sm, jsonb_each(coalesce(rb,'{}'::jsonb)) e
  ),
  normalized as (
    select item_id_text, warehouse_id, batch_id_text,
           case when jsonb_typeof(entry)='array' then entry else jsonb_build_array(entry) end as arr
    from entries
  ),
  sum_res as (
    select item_id_text, warehouse_id, batch_id_text,
           sum(coalesce(nullif(x.value->>'qty','')::numeric,0)) as reserved_qty
    from normalized, jsonb_array_elements(arr) x
    group by item_id_text, warehouse_id, batch_id_text
  )
  select count(*) into v_reserved_exceeds
  from public.batches b
  left join sum_res sr on sr.batch_id_text = b.id::text
                        and sr.item_id_text = b.item_id
                        and (sr.warehouse_id is not distinct from b.warehouse_id)
  where (p_item_id is null or b.item_id = p_item_id)
    and (p_warehouse_id is null or b.warehouse_id is not distinct from p_warehouse_id)
    and coalesce(sr.reserved_qty,0) > (coalesce(b.quantity_received,0) - coalesce(b.quantity_consumed,0) + 1e-9);

  with sm as (
    select sm.item_id::text as item_id_text, sm.warehouse_id, sm.data->'reservedBatches' as rb
    from public.stock_management sm
  ),
  entries as (
    select sm.item_id_text, sm.warehouse_id, e.key as batch_id_text, e.value as entry
    from sm, jsonb_each(coalesce(rb,'{}'::jsonb)) e
  ),
  normalized as (
    select item_id_text, warehouse_id, batch_id_text,
           case when jsonb_typeof(entry)='array' then entry else jsonb_build_array(entry) end as arr
    from entries
  ),
  sum_res as (
    select item_id_text, warehouse_id, batch_id_text,
           sum(coalesce(nullif(x.value->>'qty','')::numeric,0)) as reserved_qty
    from normalized, jsonb_array_elements(arr) x
    group by item_id_text, warehouse_id, batch_id_text
  ),
  agg as (
    select b.item_id, b.warehouse_id,
           sum(coalesce(b.quantity_received,0)) as total_received,
           sum(coalesce(b.quantity_consumed,0)) as total_consumed,
           sum(coalesce(sr.reserved_qty,0)) as total_reserved
    from public.batches b
    left join sum_res sr on sr.batch_id_text = b.id::text
                         and sr.item_id_text = b.item_id
                         and (sr.warehouse_id is not distinct from b.warehouse_id)
    where (p_item_id is null or b.item_id = p_item_id)
      and (p_warehouse_id is null or b.warehouse_id is not distinct from p_warehouse_id)
    group by b.item_id, b.warehouse_id
  )
  select count(*) into v_totals_exceed
  from agg
  where (coalesce(total_consumed,0) + coalesce(total_reserved,0)) > (coalesce(total_received,0) + 1e-9);

  v_result := json_build_object(
    'ok', ((v_over_consumed = 0) and (v_negative_remaining = 0) and (v_reserved_exceeds = 0) and (v_totals_exceed = 0)),
    'violations', json_build_object(
      'over_consumed', v_over_consumed,
      'negative_remaining', v_negative_remaining,
      'reserved_exceeds_remaining', v_reserved_exceeds,
      'totals_exceed_received', v_totals_exceed
    )
  );

  return v_result;
end;
$$;


ALTER FUNCTION "public"."check_batch_invariants"("p_item_id" "text", "p_warehouse_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_customer_credit_limit"("p_customer_id" "uuid", "p_order_amount" numeric) RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_limit numeric := 0;
  v_terms text := 'cash';
  v_current_balance numeric := 0;
  v_company_id uuid;
begin
  if p_customer_id is null then
    return true;
  end if;
  select coalesce(c.credit_limit, 0), coalesce(c.payment_terms, 'cash')
  into v_limit, v_terms
  from public.customers c
  where c.auth_user_id = p_customer_id;
  if not found then
    return true;
  end if;
  if v_terms = 'cash' then
    return true;
  end if;
  if v_limit <= 0 then
    return coalesce(p_order_amount, 0) <= 0;
  end if;

  select s.company_id into v_company_id
  from public.get_admin_session_scope() s
  limit 1;

  if v_company_id is null then
    v_current_balance := public.compute_customer_ar_balance(p_customer_id);
    update public.customers
    set current_balance = v_current_balance,
        updated_at = now()
    where auth_user_id = p_customer_id;
  else
    v_current_balance := public.compute_customer_ar_balance_in_company(p_customer_id, v_company_id);
  end if;

  return (v_current_balance + greatest(coalesce(p_order_amount, 0), 0)) <= v_limit;
end;
$$;


ALTER FUNCTION "public"."check_customer_credit_limit"("p_customer_id" "uuid", "p_order_amount" numeric) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_journal_entry_balance"("p_entry_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_debit numeric;
  v_credit numeric;
  v_count int;
begin
  if p_entry_id is null then
    raise exception 'p_entry_id is required';
  end if;

  select
    coalesce(sum(jl.debit), 0),
    coalesce(sum(jl.credit), 0),
    count(1)
  into v_debit, v_credit, v_count
  from public.journal_lines jl
  where jl.journal_entry_id = p_entry_id;

  if v_count < 2 then
    raise exception 'journal entry must have at least 2 lines %', p_entry_id;
  end if;

  if abs((v_debit - v_credit)) > 1e-6 then
    raise exception 'journal entry not balanced % (debit %, credit %)', p_entry_id, v_debit, v_credit;
  end if;
end;
$$;


ALTER FUNCTION "public"."check_journal_entry_balance"("p_entry_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."close_accounting_period"("p_period_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_period record;
  v_entry_id uuid;
  v_entry_date timestamptz;
  v_retained uuid;
  v_income_total numeric := 0;
  v_expense_total numeric := 0;
  v_profit numeric := 0;
  v_amount numeric := 0;
  v_has_lines boolean := false;
  v_row record;
begin
  if not public.has_admin_permission('accounting.periods.close') then
    raise exception 'not allowed';
  end if;
  if not public.has_admin_permission('accounting.manage') then
    raise exception 'not allowed';
  end if;

  select *
  into v_period
  from public.accounting_periods ap
  where ap.id = p_period_id
  for update;

  if not found then
    raise exception 'period not found';
  end if;

  if v_period.status = 'closed' then
    raise exception 'period already closed';
  end if;

  v_entry_date := (v_period.end_date::timestamptz + interval '23 hours 59 minutes 59 seconds');
  v_retained := public.get_account_id_by_code('3000');
  if v_retained is null then
    raise exception 'Retained earnings account (3000) not found';
  end if;

  begin
    insert into public.journal_entries(entry_date, memo, source_table, source_id, source_event, created_by)
    values (
      v_entry_date,
      concat('Close period ', v_period.name),
      'accounting_periods',
      p_period_id::text,
      'closing',
      auth.uid()
    )
    returning id into v_entry_id;
  exception
    when unique_violation then
      raise exception 'closing entry already exists';
  end;

  for v_row in
    select
      coa.id as account_id,
      coa.account_type,
      coalesce(sum(jl.debit), 0) as debit,
      coalesce(sum(jl.credit), 0) as credit
    from public.chart_of_accounts coa
    join public.journal_lines jl on jl.account_id = coa.id
    join public.journal_entries je on je.id = jl.journal_entry_id
    where coa.account_type in ('income', 'expense')
      and je.entry_date::date >= v_period.start_date
      and je.entry_date::date <= v_period.end_date
    group by coa.id, coa.account_type
  loop
    if v_row.account_type = 'income' then
      v_amount := (v_row.credit - v_row.debit);
      v_income_total := v_income_total + v_amount;
      if abs(v_amount) > 1e-9 then
        insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
        values (
          v_entry_id,
          v_row.account_id,
          greatest(v_amount, 0),
          greatest(-v_amount, 0),
          'Close income'
        );
        v_has_lines := true;
      end if;
    else
      v_amount := (v_row.debit - v_row.credit);
      v_expense_total := v_expense_total + v_amount;
      if abs(v_amount) > 1e-9 then
        insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
        values (
          v_entry_id,
          v_row.account_id,
          greatest(-v_amount, 0),
          greatest(v_amount, 0),
          'Close expense'
        );
        v_has_lines := true;
      end if;
    end if;
  end loop;

  v_profit := coalesce(v_income_total, 0) - coalesce(v_expense_total, 0);
  if abs(v_profit) > 1e-9 or v_has_lines then
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values (
      v_entry_id,
      v_retained,
      greatest(-v_profit, 0),
      greatest(v_profit, 0),
      'Retained earnings'
    );
  end if;

  perform public.check_journal_entry_balance(v_entry_id);

  update public.accounting_periods
  set status = 'closed',
      closed_at = now(),
      closed_by = auth.uid()
  where id = p_period_id
    and status <> 'closed';
end;
$$;


ALTER FUNCTION "public"."close_accounting_period"("p_period_id" "uuid") OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";


CREATE TABLE IF NOT EXISTS "public"."cash_shifts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "cashier_id" "uuid",
    "opened_at" timestamp with time zone DEFAULT "now"(),
    "closed_at" timestamp with time zone,
    "start_amount" numeric DEFAULT 0,
    "end_amount" numeric,
    "expected_amount" numeric,
    "difference" numeric,
    "status" "text" DEFAULT 'open'::"text",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "denomination_counts" "jsonb",
    "forced_close_reason" "text",
    "forced_close" boolean DEFAULT false,
    "closed_by" "uuid",
    "tender_counts" "jsonb",
    CONSTRAINT "cash_shifts_status_check" CHECK (("status" = ANY (ARRAY['open'::"text", 'closed'::"text"])))
);


ALTER TABLE "public"."cash_shifts" OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."close_cash_shift"("p_shift_id" "uuid", "p_end_amount" numeric, "p_notes" "text") RETURNS "public"."cash_shifts"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_shift public.cash_shifts%rowtype;
  v_expected numeric;
  v_end numeric;
  v_actor_role text;
begin
  if auth.uid() is null then
    raise exception 'not allowed';
  end if;

  if p_shift_id is null then
    raise exception 'p_shift_id is required';
  end if;

  select au.role
  into v_actor_role
  from public.admin_users au
  where au.auth_user_id = auth.uid()
    and au.is_active = true;

  if v_actor_role is null then
    raise exception 'not allowed';
  end if;

  select *
  into v_shift
  from public.cash_shifts s
  where s.id = p_shift_id
  for update;

  if not found then
    raise exception 'cash shift not found';
  end if;

  if auth.uid() <> v_shift.cashier_id and (v_actor_role not in ('owner', 'manager') and not public.has_admin_permission('cashShifts.manage')) then
    raise exception 'not allowed';
  end if;

  if coalesce(v_shift.status, 'open') <> 'open' then
    return v_shift;
  end if;

  v_end := coalesce(p_end_amount, 0);
  if v_end < 0 then
    raise exception 'invalid end amount';
  end if;

  v_expected := public.calculate_cash_shift_expected(p_shift_id);

  update public.cash_shifts
  set closed_at = now(),
      end_amount = v_end,
      expected_amount = v_expected,
      difference = v_end - v_expected,
      status = 'closed',
      notes = nullif(coalesce(p_notes, ''), '')
  where id = p_shift_id
  returning * into v_shift;

  perform public.post_cash_shift_close(p_shift_id);

  return v_shift;
end;
$$;


ALTER FUNCTION "public"."close_cash_shift"("p_shift_id" "uuid", "p_end_amount" numeric, "p_notes" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."close_cash_shift_v2"("p_shift_id" "uuid", "p_end_amount" numeric, "p_notes" "text" DEFAULT NULL::"text", "p_forced_reason" "text" DEFAULT NULL::"text", "p_denomination_counts" "jsonb" DEFAULT NULL::"jsonb", "p_tender_counts" "jsonb" DEFAULT NULL::"jsonb") RETURNS "public"."cash_shifts"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_shift public.cash_shifts%rowtype;
  v_expected numeric;
  v_end numeric;
  v_actor_role text;
  v_diff numeric;
  v_forced boolean;
  v_reason text;
begin
  if auth.uid() is null then
    raise exception 'not allowed';
  end if;

  if p_shift_id is null then
    raise exception 'p_shift_id is required';
  end if;

  select au.role
  into v_actor_role
  from public.admin_users au
  where au.auth_user_id = auth.uid()
    and au.is_active = true;

  if v_actor_role is null then
    raise exception 'not allowed';
  end if;

  select *
  into v_shift
  from public.cash_shifts s
  where s.id = p_shift_id
  for update;

  if not found then
    raise exception 'cash shift not found';
  end if;

  if auth.uid() <> v_shift.cashier_id and (v_actor_role not in ('owner', 'manager') and not public.has_admin_permission('cashShifts.manage')) then
    raise exception 'not allowed';
  end if;

  if coalesce(v_shift.status, 'open') <> 'open' then
    return v_shift;
  end if;

  v_end := coalesce(p_end_amount, 0);
  if v_end < 0 then
    raise exception 'invalid end amount';
  end if;

  v_expected := public.calculate_cash_shift_expected(p_shift_id);
  v_diff := v_end - v_expected;
  v_forced := abs(v_diff) > 0.01;
  v_reason := nullif(trim(coalesce(p_forced_reason, '')), '');

  if v_forced and v_reason is null then
    raise exception '      .';
  end if;

  update public.cash_shifts
  set closed_at = now(),
      end_amount = v_end,
      expected_amount = v_expected,
      difference = v_diff,
      status = 'closed',
      notes = nullif(coalesce(p_notes, ''), ''),
      denomination_counts = coalesce(p_denomination_counts, denomination_counts),
      tender_counts = coalesce(p_tender_counts, tender_counts),
      forced_close = v_forced,
      forced_close_reason = v_reason,
      closed_by = auth.uid()
  where id = p_shift_id
  returning * into v_shift;

  insert into public.system_audit_logs(action, module, details, performed_by, performed_at, metadata, risk_level, reason_code)
  values (
    'cash_shift_close',
    'cash_shifts',
    'Cash shift closed',
    auth.uid(),
    now(),
    jsonb_strip_nulls(jsonb_build_object(
      'shiftId', p_shift_id::text,
      'endAmount', v_end,
      'expectedAmount', v_expected,
      'difference', v_diff,
      'forced', v_forced,
      'forcedReason', v_reason,
      'notes', nullif(coalesce(p_notes, ''), ''),
      'denominationCounts', p_denomination_counts,
      'tenderCounts', p_tender_counts
    )),
    case when v_forced then 'HIGH' else 'MEDIUM' end,
    case when v_forced then 'SHIFT_FORCED_CLOSE' else 'SHIFT_CLOSE' end
  );

  perform public.post_cash_shift_close(p_shift_id);

  return v_shift;
end;
$$;


ALTER FUNCTION "public"."close_cash_shift_v2"("p_shift_id" "uuid", "p_end_amount" numeric, "p_notes" "text", "p_forced_reason" "text", "p_denomination_counts" "jsonb", "p_tender_counts" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."cod_post_delivery"("p_order_id" "uuid", "p_driver_id" "uuid", "p_occurred_at" timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_order record;
  v_data jsonb;
  v_amount numeric;
  v_delivery_fee numeric;
  v_tax_amount numeric;
  v_items_revenue numeric;
  v_at timestamptz;
  v_entry_id uuid;
  v_balance numeric;
BEGIN
  IF p_order_id IS NULL THEN
    RAISE EXCEPTION 'p_order_id is required';
  END IF;
  IF p_driver_id IS NULL THEN
    RAISE EXCEPTION 'p_driver_id is required';
  END IF;

  SELECT o.*
  INTO v_order
  FROM public.orders o
  WHERE o.id = p_order_id
  FOR UPDATE;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'order not found';
  END IF;

  v_amount := coalesce(nullif((v_order.data->>'total')::numeric, null), 0);
  IF v_amount <= 0 THEN
    RAISE EXCEPTION 'invalid order total';
  END IF;

  v_at := coalesce(p_occurred_at, now());
  v_data := coalesce(v_order.data, '{}'::jsonb);
  v_delivery_fee := coalesce(nullif((v_data->'invoiceSnapshot'->>'deliveryFee')::numeric, null), coalesce(nullif((v_data->>'deliveryFee')::numeric, null), 0));
  v_tax_amount := coalesce(nullif((v_data->'invoiceSnapshot'->>'taxAmount')::numeric, null), coalesce(nullif((v_data->>'taxAmount')::numeric, null), 0));
  v_tax_amount := least(greatest(0, v_tax_amount), v_amount);
  v_delivery_fee := least(greatest(0, v_delivery_fee), v_amount - v_tax_amount);
  v_items_revenue := greatest(0, v_amount - v_delivery_fee - v_tax_amount);

  -- idempotent: one delivery entry per order
  SELECT le.id
  INTO v_entry_id
  FROM public.ledger_entries le
  WHERE le.entry_type = 'delivery'
    AND le.reference_type = 'order'
    AND le.reference_id = p_order_id::text
  LIMIT 1;

  IF v_entry_id IS NULL THEN
    INSERT INTO public.ledger_entries(entry_type, reference_type, reference_id, occurred_at, created_by, data)
    VALUES (
      'delivery',
      'order',
      p_order_id::text,
      v_at,
      auth.uid(),
      jsonb_build_object('orderId', p_order_id::text, 'driverId', p_driver_id::text, 'amount', v_amount)
    )
    RETURNING id INTO v_entry_id;

    INSERT INTO public.ledger_lines(entry_id, account, debit, credit)
    VALUES (v_entry_id, 'Accounts_Receivable_COD', v_amount, 0);
    IF v_items_revenue > 0 THEN
      INSERT INTO public.ledger_lines(entry_id, account, debit, credit)
      VALUES (v_entry_id, 'Sales_Revenue', 0, v_items_revenue);
    END IF;
    IF v_delivery_fee > 0 THEN
      INSERT INTO public.ledger_lines(entry_id, account, debit, credit)
      VALUES (v_entry_id, 'Delivery_Income', 0, v_delivery_fee);
    END IF;
    IF v_tax_amount > 0 THEN
      INSERT INTO public.ledger_lines(entry_id, account, debit, credit)
      VALUES (v_entry_id, 'VAT_Payable', 0, v_tax_amount);
    END IF;
    INSERT INTO public.ledger_lines(entry_id, account, debit, credit)
    VALUES (v_entry_id, 'Cash_In_Transit', v_amount, 0);
    INSERT INTO public.ledger_lines(entry_id, account, debit, credit)
    VALUES (v_entry_id, 'Accounts_Receivable_COD', 0, v_amount);
  END IF;

  -- Driver wallet/receivable (cash in hand with driver)
  v_balance := public._driver_ledger_next_balance(p_driver_id, v_amount, 0);
  INSERT INTO public.driver_ledger(driver_id, reference_type, reference_id, debit, credit, balance_after, occurred_at, created_by)
  VALUES (p_driver_id, 'order', p_order_id::text, v_amount, 0, v_balance, v_at, auth.uid())
  ON CONFLICT (driver_id, reference_type, reference_id) DO NOTHING;
END;
$$;


ALTER FUNCTION "public"."cod_post_delivery"("p_order_id" "uuid", "p_driver_id" "uuid", "p_occurred_at" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."cod_settle_order"("p_order_id" "uuid", "p_occurred_at" timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS timestamp with time zone
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_order record;
  v_data jsonb;
  v_amount numeric;
  v_at timestamptz;
  v_driver_id uuid;
  v_shift_id uuid;
  v_settlement_id uuid;
  v_entry_id uuid;
  v_balance numeric;
BEGIN
  IF NOT (auth.role() = 'service_role' OR public.has_admin_permission('accounting.manage')) THEN
    RAISE EXCEPTION 'not authorized to post accounting entries';
  END IF;
  IF p_order_id IS NULL THEN
    RAISE EXCEPTION 'p_order_id is required';
  END IF;

  v_at := coalesce(p_occurred_at, now());

  SELECT s.id
  INTO v_shift_id
  FROM public.cash_shifts s
  WHERE s.cashier_id = auth.uid()
    AND coalesce(s.status, 'open') = 'open'
  ORDER BY s.opened_at DESC
  LIMIT 1;

  IF v_shift_id IS NULL THEN
    RAISE EXCEPTION 'cash method requires an open cash shift';
  END IF;

  SELECT o.*
  INTO v_order
  FROM public.orders o
  WHERE o.id = p_order_id
  FOR UPDATE;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'order not found';
  END IF;

  v_data := coalesce(v_order.data, '{}'::jsonb);
  v_amount := coalesce(nullif((v_data->>'total')::numeric, null), 0);
  IF v_amount <= 0 THEN
    RAISE EXCEPTION 'invalid order total';
  END IF;

  IF v_order.status::text <> 'delivered' THEN
    RAISE EXCEPTION 'order must be delivered first';
  END IF;

  IF NOT public._is_cod_delivery_order(v_data, v_order.delivery_zone_id) THEN
    RAISE EXCEPTION 'order is not COD delivery';
  END IF;

  IF nullif(v_data->>'paidAt','') IS NOT NULL THEN
    RETURN (v_data->>'paidAt')::timestamptz;
  END IF;

  v_driver_id := nullif(v_data->>'deliveredBy','')::uuid;
  IF v_driver_id IS NULL THEN
    v_driver_id := nullif(v_data->>'assignedDeliveryUserId','')::uuid;
  END IF;
  IF v_driver_id IS NULL THEN
    RAISE EXCEPTION 'driver_id is required for COD settlement';
  END IF;

  -- Ensure delivery ledger exists (idempotent creation)
  PERFORM public.cod_post_delivery(p_order_id, v_driver_id, coalesce(nullif(v_data->>'deliveredAt','')::timestamptz, v_at));

  INSERT INTO public.cod_settlements(driver_id, shift_id, total_amount, occurred_at, created_by, data)
  VALUES (v_driver_id, v_shift_id, v_amount, v_at, auth.uid(), jsonb_build_object('orderId', p_order_id::text))
  RETURNING id INTO v_settlement_id;

  INSERT INTO public.cod_settlement_orders(settlement_id, order_id, amount)
  VALUES (v_settlement_id, p_order_id, v_amount);

  INSERT INTO public.ledger_entries(entry_type, reference_type, reference_id, occurred_at, created_by, data)
  VALUES (
    'settlement',
    'settlement',
    v_settlement_id::text,
    v_at,
    auth.uid(),
    jsonb_build_object('orderId', p_order_id::text, 'driverId', v_driver_id::text, 'shiftId', v_shift_id::text, 'amount', v_amount)
  )
  RETURNING id INTO v_entry_id;

  INSERT INTO public.ledger_lines(entry_id, account, debit, credit)
  VALUES
    (v_entry_id, 'Cash_On_Hand', v_amount, 0),
    (v_entry_id, 'Cash_In_Transit', 0, v_amount);

  v_balance := public._driver_ledger_next_balance(v_driver_id, 0, v_amount);
  INSERT INTO public.driver_ledger(driver_id, reference_type, reference_id, debit, credit, balance_after, occurred_at, created_by)
  VALUES (v_driver_id, 'settlement', v_settlement_id::text, 0, v_amount, v_balance, v_at, auth.uid());

  -- Create payment (cashbox event) inside the cashier shift (creates journal entry too)
  PERFORM public.record_order_payment(
    p_order_id,
    v_amount,
    'cash',
    v_at,
    'cod_settle:' || v_settlement_id::text
  );

  -- Only now: mark paidAt in orders.data
  v_data := jsonb_set(v_data, '{paidAt}', to_jsonb(v_at::text), true);
  UPDATE public.orders
  SET data = v_data,
      updated_at = now()
  WHERE id = p_order_id;

  RETURN v_at;
END;
$$;


ALTER FUNCTION "public"."cod_settle_order"("p_order_id" "uuid", "p_occurred_at" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."cod_settle_orders"("p_driver_id" "uuid", "p_order_ids" "uuid"[], "p_occurred_at" timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_shift_id uuid;
  v_at timestamptz;
  v_settlement_id uuid;
  v_entry_id uuid;
  v_total numeric := 0;
  v_order_id uuid;
  v_order record;
  v_data jsonb;
  v_amount numeric;
  v_paid numeric;
  v_remaining numeric;
  v_balance numeric;
begin
  if not (auth.role() = 'service_role' or public.has_admin_permission('accounting.manage')) then
    raise exception 'not authorized to post accounting entries';
  end if;
  if p_driver_id is null then
    raise exception 'p_driver_id is required';
  end if;
  if p_order_ids is null or array_length(p_order_ids, 1) is null or array_length(p_order_ids, 1) = 0 then
    raise exception 'p_order_ids is required';
  end if;

  v_at := coalesce(p_occurred_at, now());

  select s.id
  into v_shift_id
  from public.cash_shifts s
  where s.cashier_id = auth.uid()
    and coalesce(s.status, 'open') = 'open'
  order by s.opened_at desc
  limit 1;

  if v_shift_id is null then
    raise exception 'cash method requires an open cash shift';
  end if;

  foreach v_order_id in array p_order_ids
  loop
    select o.*
    into v_order
    from public.orders o
    where o.id = v_order_id
    for update;

    if not found then
      raise exception 'order not found';
    end if;

    v_data := coalesce(v_order.data, '{}'::jsonb);

    if v_order.status::text <> 'delivered' then
      raise exception 'order must be delivered first';
    end if;

    if not public._is_cod_delivery_order(v_data, v_order.delivery_zone_id) then
      raise exception 'order is not COD delivery';
    end if;

    if nullif(v_data->>'paidAt','') is not null then
      raise exception 'order already settled';
    end if;

    if nullif(v_data->>'deliveredBy','')::uuid is distinct from p_driver_id
       and nullif(v_data->>'assignedDeliveryUserId','')::uuid is distinct from p_driver_id then
      raise exception 'order driver mismatch';
    end if;

    v_amount := coalesce(nullif((v_data->>'total')::numeric, null), 0);
    if v_amount <= 0 then
      raise exception 'invalid order total';
    end if;

    perform public.cod_post_delivery(v_order_id, p_driver_id, coalesce(nullif(v_data->>'deliveredAt','')::timestamptz, v_at));

    select coalesce(sum(p.amount), 0)
    into v_paid
    from public.payments p
    where p.reference_table = 'orders'
      and p.reference_id = v_order_id::text
      and p.direction = 'in';
    v_remaining := greatest(v_amount - v_paid, 0);
    v_total := v_total + v_remaining;
  end loop;

  if v_total <= 0 then
    raise exception 'invalid settlement amount';
  end if;

  insert into public.cod_settlements(driver_id, shift_id, total_amount, occurred_at, created_by, data)
  values (p_driver_id, v_shift_id, v_total, v_at, auth.uid(), jsonb_build_object('batch', true))
  returning id into v_settlement_id;

  foreach v_order_id in array p_order_ids
  loop
    select o.*
    into v_order
    from public.orders o
    where o.id = v_order_id;

    v_data := coalesce(v_order.data, '{}'::jsonb);
    v_amount := coalesce(nullif((v_data->>'total')::numeric, null), 0);
    select coalesce(sum(p.amount), 0)
    into v_paid
    from public.payments p
    where p.reference_table = 'orders'
      and p.reference_id = v_order_id::text
      and p.direction = 'in';
    v_remaining := greatest(v_amount - v_paid, 0);
    if v_remaining <= 0 then
      continue;
    end if;

    insert into public.cod_settlement_orders(settlement_id, order_id, amount)
    values (v_settlement_id, v_order_id, v_remaining);

    perform public.record_order_payment(
      v_order_id,
      v_remaining,
      'cash',
      v_at,
      'cod_settle_batch:' || v_settlement_id::text || ':' || v_order_id::text
    );

    v_data := jsonb_set(v_data, '{paidAt}', to_jsonb(v_at::text), true);
    update public.orders
    set data = v_data,
        updated_at = now()
    where id = v_order_id;
  end loop;

  insert into public.ledger_entries(entry_type, reference_type, reference_id, occurred_at, created_by, data)
  values (
    'settlement',
    'settlement',
    v_settlement_id::text,
    v_at,
    auth.uid(),
    jsonb_build_object('driverId', p_driver_id::text, 'shiftId', v_shift_id::text, 'amount', v_total, 'orderCount', array_length(p_order_ids, 1))
  )
  returning id into v_entry_id;

  insert into public.ledger_lines(entry_id, account, debit, credit)
  values
    (v_entry_id, 'Cash_On_Hand', v_total, 0),
    (v_entry_id, 'Cash_In_Transit', 0, v_total);

  v_balance := public._driver_ledger_next_balance(p_driver_id, 0, v_total);
  insert into public.driver_ledger(driver_id, reference_type, reference_id, debit, credit, balance_after, occurred_at, created_by)
  values (p_driver_id, 'settlement', v_settlement_id::text, 0, v_total, v_balance, v_at, auth.uid());

  return v_settlement_id;
end;
$$;


ALTER FUNCTION "public"."cod_settle_orders"("p_driver_id" "uuid", "p_order_ids" "uuid"[], "p_occurred_at" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."cogs_reconciliation_by_range"("p_start" "date", "p_end" "date") RETURNS TABLE("item_id" "text", "expected_cogs" numeric, "actual_cogs" numeric, "delta" numeric)
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if not (auth.role() = 'service_role' or public.has_admin_permission('accounting.view')) then
    raise exception 'not allowed';
  end if;

  return query
  with mv as (
    select
      im.id,
      im.item_id,
      im.total_cost,
      im.occurred_at::date as d,
      im.movement_type
    from public.inventory_movements im
    where im.movement_type in ('sale_out','wastage_out','expired_out')
      and (p_start is null or im.occurred_at::date >= p_start)
      and (p_end is null or im.occurred_at::date <= p_end)
  ),
  expected as (
    select m.item_id, coalesce(sum(m.total_cost), 0) as expected_cogs
    from mv m
    group by m.item_id
  ),
  actual as (
    select
      m.item_id,
      coalesce(sum(jl.debit - jl.credit), 0) as actual_cogs
    from mv m
    join public.journal_entries je
      on je.source_table = 'inventory_movements'
     and je.source_id = m.id::text
     and je.source_event = m.movement_type
    join public.journal_lines jl
      on jl.journal_entry_id = je.id
    join public.chart_of_accounts coa
      on coa.id = jl.account_id
    where coa.code = '5010'
    group by m.item_id
  )
  select
    coalesce(e.item_id, a.item_id) as item_id,
    coalesce(e.expected_cogs, 0) as expected_cogs,
    coalesce(a.actual_cogs, 0) as actual_cogs,
    (coalesce(e.expected_cogs, 0) - coalesce(a.actual_cogs, 0)) as delta
  from expected e
  full join actual a on a.item_id = e.item_id
  order by abs(coalesce(e.expected_cogs, 0) - coalesce(a.actual_cogs, 0)) desc, item_id;
end;
$$;


ALTER FUNCTION "public"."cogs_reconciliation_by_range"("p_start" "date", "p_end" "date") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."cogs_reconciliation_by_range"("p_start" "date", "p_end" "date") IS 'Purpose: reconcile expected COGS from inventory_movements vs journaled COGS (account 5010) posted from those movements. Source of truth: inventory_movements and journal_entries/journal_lines.';



CREATE OR REPLACE FUNCTION "public"."company_from_branch"("p_branch_id" "uuid") RETURNS "uuid"
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select b.company_id from public.branches b where b.id = p_branch_id
$$;


ALTER FUNCTION "public"."company_from_branch"("p_branch_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."complete_warehouse_transfer"("p_transfer_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_item record;
  v_from_warehouse uuid;
  v_to_warehouse uuid;
  v_transfer_date date;
  v_needed numeric;
  v_batch record;
  v_reserved_other numeric;
  v_available numeric;
  v_alloc numeric;
  v_unit_cost numeric;
begin
  perform public._require_stock_manager('complete_warehouse_transfer');

  select from_warehouse_id, to_warehouse_id, transfer_date
  into v_from_warehouse, v_to_warehouse, v_transfer_date
  from public.warehouse_transfers
  where id = p_transfer_id and status = 'pending'
  for update;
  if not found then
    raise exception 'Transfer not found or not pending';
  end if;

  for v_item in
    select id, item_id, quantity
    from public.warehouse_transfer_items
    where transfer_id = p_transfer_id
  loop
    v_needed := v_item.quantity;
    if v_needed <= 0 then
      continue;
    end if;

    for v_batch in
      select bb.batch_id, bb.quantity, bb.expiry_date
      from public.batch_balances bb
      where bb.item_id = v_item.item_id
        and bb.warehouse_id = v_from_warehouse
        and bb.quantity > 0
        and (bb.expiry_date is null or bb.expiry_date >= current_date)
      order by bb.expiry_date asc nulls last, bb.batch_id asc
    loop
      exit when v_needed <= 0;

      select coalesce(sum(br.quantity), 0)
      into v_reserved_other
      from public.batch_reservations br
      where br.item_id = v_item.item_id
        and br.warehouse_id = v_from_warehouse
        and br.batch_id = v_batch.batch_id;

      v_available := greatest(coalesce(v_batch.quantity, 0) - coalesce(v_reserved_other, 0), 0);
      if v_available <= 0 then
        continue;
      end if;

      v_alloc := least(v_needed, v_available);
      if v_alloc <= 0 then
        continue;
      end if;

      update public.batch_balances
      set quantity = quantity - v_alloc,
          updated_at = now()
      where item_id = v_item.item_id
        and batch_id = v_batch.batch_id
        and warehouse_id = v_from_warehouse;

      insert into public.batch_balances(item_id, batch_id, warehouse_id, quantity, expiry_date)
      values (v_item.item_id, v_batch.batch_id, v_to_warehouse, v_alloc, v_batch.expiry_date)
      on conflict (item_id, batch_id, warehouse_id)
      do update set
        quantity = public.batch_balances.quantity + excluded.quantity,
        expiry_date = coalesce(excluded.expiry_date, public.batch_balances.expiry_date),
        updated_at = now();

      select im.unit_cost
      into v_unit_cost
      from public.inventory_movements im
      where im.batch_id = v_batch.batch_id
        and im.item_id::text = v_item.item_id::text
        and im.movement_type = 'purchase_in'
      order by im.occurred_at asc
      limit 1;
      v_unit_cost := coalesce(v_unit_cost, 0);

      insert into public.inventory_movements(
        item_id, movement_type, quantity, unit_cost, total_cost,
        reference_table, reference_id, occurred_at, created_by, data, batch_id, warehouse_id
      )
      values (
        v_item.item_id, 'adjust_out', v_alloc, v_unit_cost, v_alloc * v_unit_cost,
        'warehouse_transfers', p_transfer_id::text, v_transfer_date::timestamptz, auth.uid(),
        jsonb_build_object('transferId', p_transfer_id, 'fromWarehouseId', v_from_warehouse, 'toWarehouseId', v_to_warehouse, 'batchId', v_batch.batch_id, 'expiryDate', v_batch.expiry_date),
        v_batch.batch_id,
        v_from_warehouse
      );

      insert into public.inventory_movements(
        item_id, movement_type, quantity, unit_cost, total_cost,
        reference_table, reference_id, occurred_at, created_by, data, batch_id, warehouse_id
      )
      values (
        v_item.item_id, 'adjust_in', v_alloc, v_unit_cost, v_alloc * v_unit_cost,
        'warehouse_transfers', p_transfer_id::text, v_transfer_date::timestamptz, auth.uid(),
        jsonb_build_object('transferId', p_transfer_id, 'fromWarehouseId', v_from_warehouse, 'toWarehouseId', v_to_warehouse, 'batchId', v_batch.batch_id, 'expiryDate', v_batch.expiry_date),
        v_batch.batch_id,
        v_to_warehouse
      );

      v_needed := v_needed - v_alloc;
    end loop;

    if v_needed > 0 then
      raise exception 'Insufficient FEFO-valid stock for item % in source warehouse', v_item.item_id;
    end if;

    update public.stock_management sm
    set available_quantity = coalesce((
          select sum(bb.quantity)
          from public.batch_balances bb
          where bb.item_id = v_item.item_id
            and bb.warehouse_id = v_from_warehouse
        ), 0),
        updated_at = now(),
        last_updated = now()
    where sm.item_id::text = v_item.item_id::text
      and sm.warehouse_id = v_from_warehouse;

    update public.stock_management sm
    set available_quantity = coalesce((
          select sum(bb.quantity)
          from public.batch_balances bb
          where bb.item_id = v_item.item_id
            and bb.warehouse_id = v_to_warehouse
        ), 0),
        updated_at = now(),
        last_updated = now()
    where sm.item_id::text = v_item.item_id::text
      and sm.warehouse_id = v_to_warehouse;

    update public.warehouse_transfer_items
    set transferred_quantity = v_item.quantity
    where id = v_item.id;
  end loop;

  update public.warehouse_transfers
  set status = 'completed',
      completed_at = now(),
      approved_by = auth.uid()
  where id = p_transfer_id;

  insert into public.system_audit_logs(action, module, details, performed_by, performed_at, metadata)
  values (
    'warehouse_transfer_completed',
    'inventory',
    format('Completed transfer %s', p_transfer_id),
    auth.uid(),
    now(),
    jsonb_build_object('transferId', p_transfer_id, 'fromWarehouseId', v_from_warehouse, 'toWarehouseId', v_to_warehouse)
  );
end;
$$;


ALTER FUNCTION "public"."complete_warehouse_transfer"("p_transfer_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."compute_customer_ar_balance"("p_customer_id" "uuid") RETURNS numeric
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  with ar as (
    select public.get_account_id_by_code('1200') as ar_id
  )
  select coalesce(sum(jl.debit - jl.credit), 0)
  from public.journal_lines jl
  join public.journal_entries je on je.id = jl.journal_entry_id
  join ar on jl.account_id = ar.ar_id
  left join public.orders o_del
    on je.source_table = 'orders'
   and je.source_event = 'delivered'
   and je.source_id = o_del.id::text
  left join public.payments pay
    on je.source_table = 'payments'
   and je.source_id = pay.id::text
  left join public.orders o_pay
    on pay.reference_table = 'orders'
   and pay.reference_id = o_pay.id::text
  where (o_del.customer_auth_user_id = p_customer_id or o_pay.customer_auth_user_id = p_customer_id);
$$;


ALTER FUNCTION "public"."compute_customer_ar_balance"("p_customer_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."compute_customer_ar_balance_in_company"("p_customer_id" "uuid", "p_company_id" "uuid") RETURNS numeric
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  with ar as (
    select public.get_account_id_by_code('1200') as ar_id
  )
  select coalesce(sum(jl.debit - jl.credit), 0)
  from public.journal_lines jl
  join public.journal_entries je on je.id = jl.journal_entry_id
  join ar on jl.account_id = ar.ar_id
  left join public.orders o_del
    on je.source_table = 'orders'
   and je.source_event = 'delivered'
   and je.source_id = o_del.id::text
  left join public.payments pay
    on je.source_table = 'payments'
   and je.source_id = pay.id::text
  left join public.orders o_pay
    on pay.reference_table = 'orders'
   and pay.reference_id = o_pay.id::text
  where (o_del.customer_auth_user_id = p_customer_id or o_pay.customer_auth_user_id = p_customer_id)
    and (p_company_id is null or coalesce(o_del.company_id, o_pay.company_id, je.company_id) = p_company_id);
$$;


ALTER FUNCTION "public"."compute_customer_ar_balance_in_company"("p_customer_id" "uuid", "p_company_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."compute_order_tax_lines"("p_order_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_order record;
  v_item jsonb;
  v_tax_code text;
  v_tax_rate numeric;
  v_tax_amount numeric;
  v_jurisdiction uuid;
  v_line_total numeric;
begin
  select * into v_order from public.orders where id = p_order_id;
  if not found then
    raise exception 'order not found';
  end if;

  delete from public.order_tax_lines where order_id = p_order_id;

  select ctp.jurisdiction_id into v_jurisdiction
  from public.customer_tax_profiles ctp
  where ctp.customer_id = v_order.customer_auth_user_id
  limit 1;

  for v_item in select value from jsonb_array_elements(coalesce(v_order.items, v_order.data->'items', '[]'::jsonb))
  loop
    v_tax_code := nullif(v_item->>'taxCode', '');
    if v_tax_code is null then
      select itp.tax_code into v_tax_code
      from public.item_tax_profiles itp
      where itp.item_id = coalesce(v_item->>'itemId', v_item->>'id')
      limit 1;
    end if;
    if v_tax_code is null or v_jurisdiction is null then
      raise exception 'missing tax profile';
    end if;
    select tr.rate into v_tax_rate
    from public.tax_rates tr
    where tr.jurisdiction_id = v_jurisdiction
      and tr.tax_code = v_tax_code
      and tr.effective_from <= current_date
      and (tr.effective_to is null or tr.effective_to >= current_date)
    order by tr.effective_from desc
    limit 1;
    if v_tax_rate is null then
      raise exception 'missing tax rate';
    end if;
    v_line_total := coalesce((v_item->>'price')::numeric, 0) * coalesce((v_item->>'quantity')::numeric, 0);
    v_tax_amount := v_line_total * v_tax_rate;
    insert into public.order_tax_lines(order_id, tax_code, tax_rate, tax_amount)
    values (p_order_id, v_tax_code, v_tax_rate, v_tax_amount);
  end loop;
end;
$$;


ALTER FUNCTION "public"."compute_order_tax_lines"("p_order_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."confirm_order_delivery"("p_payload" "jsonb") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
declare
  v_items jsonb;
  v_updated_data jsonb;
  v_order_id_text text;
  v_warehouse_id_text text;
  v_order_id uuid;
  v_warehouse_id uuid;
begin
  if p_payload is null or jsonb_typeof(p_payload) <> 'object' then
    raise exception 'p_payload must be a json object';
  end if;

  v_items := p_payload->'p_items';
  if v_items is null then
    v_items := p_payload->'items';
  end if;
  if v_items is null then
    v_items := '[]'::jsonb;
  end if;

  v_updated_data := p_payload->'p_updated_data';
  if v_updated_data is null then
    v_updated_data := p_payload->'updated_data';
  end if;
  if v_updated_data is null then
    v_updated_data := '{}'::jsonb;
  end if;

  v_order_id_text := nullif(coalesce(p_payload->>'p_order_id', p_payload->>'order_id', p_payload->>'orderId'), '');
  if v_order_id_text is null or v_order_id_text !~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$' then
    raise exception 'p_order_id is required';
  end if;
  v_order_id := v_order_id_text::uuid;

  v_warehouse_id_text := nullif(coalesce(p_payload->>'p_warehouse_id', p_payload->>'warehouse_id', p_payload->>'warehouseId'), '');
  if v_warehouse_id_text is null or v_warehouse_id_text !~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$' then
    raise exception 'p_warehouse_id is required';
  end if;
  v_warehouse_id := v_warehouse_id_text::uuid;

  perform public.confirm_order_delivery(v_order_id, v_items, v_updated_data, v_warehouse_id);
end;
$_$;


ALTER FUNCTION "public"."confirm_order_delivery"("p_payload" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."confirm_order_delivery"("p_order_id" "uuid", "p_items" "jsonb", "p_updated_data" "jsonb", "p_warehouse_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
    v_actor uuid;
    v_order record;
    v_order_data jsonb;
    v_promos jsonb;
    v_promos_fixed jsonb := '[]'::jsonb;
    v_line jsonb;
    v_snapshot jsonb;
    v_items_all jsonb := '[]'::jsonb;
    v_item jsonb;
    v_final_data jsonb;
    v_is_cod boolean := false;
    v_driver_id uuid;
    v_delivered_at timestamptz;
    v_order_source text;
    v_customer_id uuid;
    v_amount numeric;
    v_customer_type text;
    v_ok boolean;
    v_deposits_paid numeric := 0;
    v_net_ar numeric := 0;
    v_err text;
    v_reason text;
begin
    if p_warehouse_id is null then
      raise exception 'warehouse_id is required';
    end if;
    v_actor := auth.uid();
    v_order_source := '';
    if auth.role() <> 'service_role' then
      if not public.is_staff() then
        raise exception 'not allowed';
      end if;
    end if;
    select *
    into v_order
    from public.orders o
    where o.id = p_order_id
    for update;
    if not found then
      raise exception 'order not found';
    end if;
    v_order_data := coalesce(v_order.data, '{}'::jsonb);
    v_order_source := coalesce(nullif(v_order_data->>'orderSource',''), nullif(p_updated_data->>'orderSource',''), '');
    if auth.role() <> 'service_role' then
      if v_order_source = 'in_store' then
        if not public.has_admin_permission('orders.markPaid') then
          raise exception 'not allowed';
        end if;
      else
        if not (public.has_admin_permission('orders.updateStatus.all') or public.has_admin_permission('orders.updateStatus.delivery')) then
          raise exception 'not allowed';
        end if;
        if public.has_admin_permission('orders.updateStatus.delivery') and not public.has_admin_permission('orders.updateStatus.all') then
          if (v_order_data->>'assignedDeliveryUserId') is distinct from v_actor::text then
            raise exception 'not allowed';
          end if;
        end if;
      end if;
    end if;

    v_customer_id := coalesce(
      nullif(v_order_data->>'customerId','')::uuid,
      nullif(p_updated_data->>'customerId','')::uuid,
      (select c.auth_user_id from public.customers c where c.auth_user_id = v_order.customer_auth_user_id limit 1)
    );
    v_amount := coalesce(nullif((v_order_data->>'total')::numeric, null), nullif((p_updated_data->>'total')::numeric, null), 0);
    if v_customer_id is not null then
      select c.customer_type
      into v_customer_type
      from public.customers c
      where c.auth_user_id = v_customer_id;
    end if;
    if v_customer_type = 'wholesale' then
      v_delivered_at := now();
      select coalesce(sum(p.amount), 0)
      into v_deposits_paid
      from public.payments p
      where p.reference_table = 'orders'
        and p.reference_id = p_order_id::text
        and p.direction = 'in'
        and p.occurred_at < v_delivered_at;
      v_deposits_paid := least(greatest(coalesce(v_amount, 0), 0), greatest(coalesce(v_deposits_paid, 0), 0));
      v_net_ar := greatest(0, coalesce(v_amount, 0) - v_deposits_paid);

      select public.check_customer_credit_limit(v_customer_id, v_net_ar)
      into v_ok;
      if not v_ok then
        raise exception 'CREDIT_LIMIT_EXCEEDED';
      end if;
    end if;
    if p_items is null or jsonb_typeof(p_items) <> 'array' then
      p_items := '[]'::jsonb;
    end if;
    v_items_all := p_items;
    v_promos := coalesce(v_order_data->'promotionLines', '[]'::jsonb);
    v_is_cod := public._is_cod_delivery_order(v_order_data, v_order.delivery_zone_id);
    if v_is_cod then
      v_driver_id := nullif(coalesce(p_updated_data->>'deliveredBy', p_updated_data->>'assignedDeliveryUserId', v_order_data->>'deliveredBy', v_order_data->>'assignedDeliveryUserId'),'')::uuid;
      if v_driver_id is null then
        raise exception 'delivery_driver_required';
      end if;
    end if;
    if jsonb_typeof(v_promos) = 'array' and jsonb_array_length(v_promos) > 0 then
      if nullif(btrim(coalesce(v_order_data->>'appliedCouponCode', '')), '') is not null then
        raise exception 'promotion_coupon_conflict';
      end if;
      if coalesce(nullif((v_order_data->>'pointsRedeemedValue')::numeric, null), 0) > 0 then
        raise exception 'promotion_points_conflict';
      end if;
      for v_line in select value from jsonb_array_elements(v_promos)
      loop
        v_snapshot := public._compute_promotion_snapshot(
          (v_line->>'promotionId')::uuid,
          null,
          p_warehouse_id,
          coalesce(nullif((v_line->>'bundleQty')::numeric, null), 1),
          null,
          true
        );
        v_snapshot := v_snapshot || jsonb_build_object('promotionLineId', v_line->>'promotionLineId');
        v_promos_fixed := v_promos_fixed || v_snapshot;
        for v_item in select value from jsonb_array_elements(coalesce(v_snapshot->'items','[]'::jsonb))
        loop
          v_items_all := v_items_all || jsonb_build_object(
            'itemId', v_item->>'itemId',
            'quantity', coalesce(nullif((v_item->>'quantity')::numeric, null), 0)
          );
        end loop;
        insert into public.promotion_usage(
          promotion_id,
          promotion_line_id,
          order_id,
          bundle_qty,
          channel,
          warehouse_id,
          snapshot,
          created_by
        )
        values (
          (v_snapshot->>'promotionId')::uuid,
          (v_snapshot->>'promotionLineId')::uuid,
          p_order_id,
          coalesce(nullif((v_snapshot->>'bundleQty')::numeric, null), 1),
          'in_store',
          p_warehouse_id,
          v_snapshot,
          auth.uid()
        )
        on conflict (promotion_line_id) do nothing;
      end loop;
      v_items_all := public._merge_stock_items(v_items_all);
    else
      v_items_all := public._merge_stock_items(v_items_all);
    end if;

    if jsonb_array_length(v_items_all) = 0 then
      v_items_all := public._extract_stock_items_from_order_data(v_order_data);
    end if;
    if jsonb_array_length(v_items_all) = 0 then
      raise exception 'no deliverable items';
    end if;

    if exists (
      select 1
      from public.inventory_movements im
      where im.reference_table = 'orders'
        and im.reference_id = p_order_id::text
        and im.movement_type = 'sale_out'
    ) then
      update public.orders
      set status = 'delivered',
          data = p_updated_data,
          updated_at = now()
      where id = p_order_id;
      return;
    end if;

    begin
      perform public.deduct_stock_on_delivery_v2(p_order_id, v_items_all, p_warehouse_id);
    exception when others then
      v_err := coalesce(sqlerrm, '');
      if v_err = 'SELLING_BELOW_COST_NOT_ALLOWED' then
        raise;
      end if;
      if v_err ilike '%batch not released or recalled%' then
        raise exception 'BATCH_NOT_RELEASED';
      end if;
      if v_err = 'BATCH_EXPIRED' then
        raise exception 'NO_VALID_BATCH';
      end if;
      if v_err ilike '%insufficient%' or v_err ilike '%INSUFFICIENT%' then
        v_reason := null;
        for v_item in select value from jsonb_array_elements(coalesce(v_items_all,'[]'::jsonb))
        loop
          v_reason := public._resolve_batch_sale_failure_reason(
            coalesce(nullif(v_item->>'itemId',''), nullif(v_item->>'id','')),
            p_warehouse_id,
            coalesce(nullif((v_item->>'quantity')::numeric, null), coalesce(nullif((v_item->>'qty')::numeric, null), 0))
          );
          if v_reason is not null then
            raise exception '%', v_reason;
          end if;
        end loop;
        raise exception 'INSUFFICIENT_BATCH_QUANTITY';
      end if;
      raise;
    end;

    v_final_data := coalesce(p_updated_data, v_order_data);
    if jsonb_array_length(v_promos_fixed) > 0 then
      v_final_data := jsonb_set(v_final_data, '{promotionLines}', v_promos_fixed, true);
    end if;
    if v_is_cod then
      v_final_data := v_final_data - 'paidAt';
      v_driver_id := nullif(v_final_data->>'deliveredBy','')::uuid;
      if v_driver_id is null then
        v_driver_id := nullif(v_final_data->>'assignedDeliveryUserId','')::uuid;
      end if;
      if v_driver_id is not null then
        v_delivered_at := coalesce(nullif(v_final_data->>'deliveredAt','')::timestamptz, now());
        perform public.cod_post_delivery(p_order_id, v_driver_id, v_delivered_at);
      end if;
    end if;
    update public.orders
    set status = 'delivered',
        data = v_final_data,
        updated_at = now()
    where id = p_order_id;
end;
$$;


ALTER FUNCTION "public"."confirm_order_delivery"("p_order_id" "uuid", "p_items" "jsonb", "p_updated_data" "jsonb", "p_warehouse_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."confirm_order_delivery_with_credit"("p_payload" "jsonb") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
declare
  v_items jsonb;
  v_updated_data jsonb;
  v_order_id_text text;
  v_warehouse_id_text text;
  v_order_id uuid;
  v_warehouse_id uuid;
begin
  if p_payload is null or jsonb_typeof(p_payload) <> 'object' then
    raise exception 'p_payload must be a json object';
  end if;

  v_items := p_payload->'p_items';
  if v_items is null then
    v_items := p_payload->'items';
  end if;
  if v_items is null then
    v_items := '[]'::jsonb;
  end if;

  v_updated_data := p_payload->'p_updated_data';
  if v_updated_data is null then
    v_updated_data := p_payload->'updated_data';
  end if;
  if v_updated_data is null then
    v_updated_data := '{}'::jsonb;
  end if;

  v_order_id_text := nullif(coalesce(p_payload->>'p_order_id', p_payload->>'order_id', p_payload->>'orderId'), '');
  if v_order_id_text is null or v_order_id_text !~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$' then
    raise exception 'p_order_id is required';
  end if;
  v_order_id := v_order_id_text::uuid;

  v_warehouse_id_text := nullif(coalesce(p_payload->>'p_warehouse_id', p_payload->>'warehouse_id', p_payload->>'warehouseId'), '');
  if v_warehouse_id_text is null or v_warehouse_id_text !~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$' then
    raise exception 'p_warehouse_id is required';
  end if;
  v_warehouse_id := v_warehouse_id_text::uuid;

  perform public.confirm_order_delivery_with_credit(v_order_id, v_items, v_updated_data, v_warehouse_id);
end;
$_$;


ALTER FUNCTION "public"."confirm_order_delivery_with_credit"("p_payload" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."confirm_order_delivery_with_credit"("p_order_id" "uuid", "p_items" "jsonb", "p_updated_data" "jsonb", "p_warehouse_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if auth.role() <> 'service_role' then
    if not public.is_staff() then
      raise exception 'not allowed';
    end if;
  end if;

  perform public.confirm_order_delivery(p_order_id, p_items, p_updated_data, p_warehouse_id);
end;
$$;


ALTER FUNCTION "public"."confirm_order_delivery_with_credit"("p_order_id" "uuid", "p_items" "jsonb", "p_updated_data" "jsonb", "p_warehouse_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."confirm_order_delivery_with_credit"("p_order_id" "uuid", "p_items" "jsonb", "p_updated_data" "jsonb", "p_warehouse_id" "uuid") IS 'Phase 6: Wholesale credit guard at delivery. Retail unaffected. Calls confirm_order_delivery after passing credit check.';



CREATE OR REPLACE FUNCTION "public"."convert_qty"("p_qty" numeric, "p_from" "uuid", "p_to" "uuid") RETURNS numeric
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_num bigint;
  v_den bigint;
begin
  if p_from = p_to then
    return p_qty;
  end if;
  select numerator, denominator into v_num, v_den
  from public.uom_conversions
  where from_uom_id = p_from and to_uom_id = p_to
  limit 1;
  if v_num is null or v_den is null then
    raise exception 'missing uom conversion';
  end if;
  return p_qty * (v_num::numeric / v_den::numeric);
end;
$$;


ALTER FUNCTION "public"."convert_qty"("p_qty" numeric, "p_from" "uuid", "p_to" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_accounting_document"("p_document_type" "text", "p_source_table" "text", "p_source_id" "text", "p_branch_id" "uuid", "p_company_id" "uuid", "p_memo" "text") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_id uuid;
begin
  select id into v_id
  from public.accounting_documents
  where source_table = p_source_table and source_id = p_source_id;
  if v_id is not null then
    return v_id;
  end if;
  insert into public.accounting_documents(
    document_type, source_table, source_id, branch_id, company_id, status, memo, created_by
  )
  values (
    p_document_type, p_source_table, p_source_id, p_branch_id, p_company_id, 'posted', p_memo, auth.uid()
  )
  returning id into v_id;
  return v_id;
end;
$$;


ALTER FUNCTION "public"."create_accounting_document"("p_document_type" "text", "p_source_table" "text", "p_source_id" "text", "p_branch_id" "uuid", "p_company_id" "uuid", "p_memo" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_approval_request"("p_target_table" "text", "p_target_id" "text", "p_request_type" "text", "p_amount" numeric, "p_payload" "jsonb") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
declare
  v_request_id uuid;
  v_policy_id uuid;
  v_payload_hash text;
begin
  if not public.approval_required(p_request_type, p_amount) then
    raise exception 'approval policy not found for request_type %', p_request_type;
  end if;

  v_payload_hash := encode(digest(convert_to(coalesce(p_payload::text, ''), 'utf8'), 'sha256'::text), 'hex');

  insert into public.approval_requests(
    target_table, target_id, request_type, status, requested_by, payload_hash
  )
  values (
    p_target_table, p_target_id, p_request_type, 'pending', auth.uid(), v_payload_hash
  )
  returning id into v_request_id;

  select p.id into v_policy_id
  from public.approval_policies p
  where p.request_type = p_request_type
    and p.is_active = true
    and p.min_amount <= coalesce(p_amount, 0)
    and (p.max_amount is null or p.max_amount >= coalesce(p_amount, 0))
  order by p.min_amount desc
  limit 1;

  insert into public.approval_steps(request_id, step_no, approver_role, status)
  select v_request_id, s.step_no, s.approver_role, 'pending'
  from public.approval_policy_steps s
  where s.policy_id = v_policy_id
  order by s.step_no asc;

  return v_request_id;
end;
$$;


ALTER FUNCTION "public"."create_approval_request"("p_target_table" "text", "p_target_id" "text", "p_request_type" "text", "p_amount" numeric, "p_payload" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_chart_account"("p_code" "text", "p_name" "text", "p_account_type" "text", "p_normal_balance" "text") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
declare
  v_code text;
  v_name text;
  v_id uuid;
begin
  if not public.is_owner() then
    raise exception 'not allowed';
  end if;

  v_code := btrim(coalesce(p_code, ''));
  v_name := btrim(coalesce(p_name, ''));
  if v_code = '' then
    raise exception 'code is required';
  end if;
  if v_code !~ '^[0-9]{3,10}$' then
    raise exception 'invalid code';
  end if;
  if v_name = '' then
    raise exception 'name is required';
  end if;
  if coalesce(p_account_type,'') not in ('asset','liability','equity','income','expense') then
    raise exception 'invalid account_type';
  end if;
  if coalesce(p_normal_balance,'') not in ('debit','credit') then
    raise exception 'invalid normal_balance';
  end if;

  insert into public.chart_of_accounts(code, name, account_type, normal_balance, is_active)
  values (v_code, v_name, p_account_type, p_normal_balance, true)
  returning id into v_id;

  return v_id;
end;
$_$;


ALTER FUNCTION "public"."create_chart_account"("p_code" "text", "p_name" "text", "p_account_type" "text", "p_normal_balance" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_inventory_transfer"("p_from_warehouse_id" "uuid", "p_to_warehouse_id" "uuid", "p_items" "jsonb", "p_transfer_date" "date" DEFAULT CURRENT_DATE, "p_notes" "text" DEFAULT NULL::"text", "p_idempotency_key" "text" DEFAULT NULL::"text") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_actor uuid;
  v_existing_id uuid;
  v_transfer_id uuid;
  v_transfer_number text;
  v_item jsonb;
  v_item_id text;
  v_batch_id text;
  v_qty numeric;
  v_batch record;
begin
  v_actor := auth.uid();
  if not public.is_admin() then
    raise exception 'not allowed';
  end if;

  if p_from_warehouse_id is null or p_to_warehouse_id is null then
    raise exception 'warehouse ids are required';
  end if;
  if p_from_warehouse_id = p_to_warehouse_id then
    raise exception 'from and to warehouses must differ';
  end if;
  if p_items is null or jsonb_typeof(p_items) <> 'array' then
    raise exception 'p_items must be a json array';
  end if;

  if p_idempotency_key is not null and btrim(p_idempotency_key) <> '' then
    select it.id
    into v_existing_id
    from public.inventory_transfers it
    where it.create_idempotency_key = p_idempotency_key;
    if found then
      return v_existing_id;
    end if;
  end if;

  v_transfer_id := gen_random_uuid();
  v_transfer_number := 'IT-' || to_char(now(), 'YYYYMMDD-HH24MISS') || '-' || right(v_transfer_id::text, 6);

  insert into public.inventory_transfers(
    id,
    transfer_number,
    from_warehouse_id,
    to_warehouse_id,
    transfer_date,
    state,
    notes,
    payload,
    created_by,
    created_at,
    updated_at,
    create_idempotency_key
  )
  values (
    v_transfer_id,
    v_transfer_number,
    p_from_warehouse_id,
    p_to_warehouse_id,
    coalesce(p_transfer_date, current_date),
    'CREATED',
    p_notes,
    '{}'::jsonb,
    v_actor,
    now(),
    now(),
    nullif(btrim(p_idempotency_key), '')
  );

  for v_item in select value from jsonb_array_elements(p_items)
  loop
    v_item_id := coalesce(v_item->>'itemId', v_item->>'id');
    v_batch_id := nullif(v_item->>'batchId', '');
    v_qty := coalesce(nullif(v_item->>'quantity', '')::numeric, 0);
    if v_item_id is null or v_item_id = '' then
      raise exception 'Invalid itemId';
    end if;
    if v_batch_id is null then
      raise exception 'batchId is required';
    end if;
    if v_qty <= 0 then
      raise exception 'quantity must be > 0';
    end if;

    select b.id, b.item_id, b.warehouse_id, b.unit_cost, b.expiry_date
    into v_batch
    from public.batches b
    where b.id = v_batch_id::uuid
      and b.item_id::text = v_item_id
      and b.warehouse_id = p_from_warehouse_id
    for update;

    if not found then
      raise exception 'Batch % not found in source warehouse', v_batch_id;
    end if;

    insert into public.inventory_transfer_items(
      transfer_id,
      item_id,
      source_batch_id,
      quantity,
      unit_cost,
      total_cost,
      created_at,
      updated_at
    )
    values (
      v_transfer_id,
      v_item_id,
      v_batch.id,
      v_qty,
      coalesce(v_batch.unit_cost, 0),
      v_qty * coalesce(v_batch.unit_cost, 0),
      now(),
      now()
    );
  end loop;

  return v_transfer_id;
end;
$$;


ALTER FUNCTION "public"."create_inventory_transfer"("p_from_warehouse_id" "uuid", "p_to_warehouse_id" "uuid", "p_items" "jsonb", "p_transfer_date" "date", "p_notes" "text", "p_idempotency_key" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_manual_journal_entry"("p_entry_date" timestamp with time zone, "p_memo" "text", "p_lines" "jsonb") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_entry_id uuid;
  v_line jsonb;
  v_account_code text;
  v_account_id uuid;
  v_debit numeric;
  v_credit numeric;
  v_memo text;
  v_cost_center_id uuid;
begin
  if not public.has_admin_permission('accounting.manage') then
    raise exception 'not allowed';
  end if;

  if p_lines is null or jsonb_typeof(p_lines) <> 'array' then
    raise exception 'p_lines must be a json array';
  end if;

  v_memo := nullif(trim(coalesce(p_memo, '')), '');

  insert into public.journal_entries(entry_date, memo, source_table, source_id, source_event, created_by)
  values (
    coalesce(p_entry_date, now()),
    v_memo,
    'manual',
    null,
    null,
    auth.uid()
  )
  returning id into v_entry_id;

  for v_line in select value from jsonb_array_elements(p_lines)
  loop
    v_account_code := nullif(trim(coalesce(v_line->>'accountCode', '')), '');
    v_debit := coalesce(nullif(v_line->>'debit', '')::numeric, 0);
    v_credit := coalesce(nullif(v_line->>'credit', '')::numeric, 0);
    v_cost_center_id := nullif(trim(coalesce(v_line->>'costCenterId', '')), '')::uuid;

    if v_account_code is null then
      raise exception 'accountCode is required';
    end if;

    if v_debit < 0 or v_credit < 0 then
      raise exception 'invalid debit/credit';
    end if;

    if (v_debit > 0 and v_credit > 0) or (v_debit = 0 and v_credit = 0) then
      raise exception 'invalid line amounts';
    end if;

    v_account_id := public.get_account_id_by_code(v_account_code);
    if v_account_id is null then
      raise exception 'account not found %', v_account_code;
    end if;

    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo, cost_center_id)
    values (
      v_entry_id,
      v_account_id,
      v_debit,
      v_credit,
      nullif(trim(coalesce(v_line->>'memo', '')), ''),
      v_cost_center_id
    );
  end loop;

  insert into public.system_audit_logs(action, module, details, performed_by, performed_at, metadata, risk_level, reason_code)
  values (
    'journal_entries.manual_draft',
    'accounting',
    v_entry_id::text,
    auth.uid(),
    now(),
    jsonb_build_object('entryId', v_entry_id::text),
    'LOW',
    'ACCOUNTING_DRAFT'
  );

  return v_entry_id;
end;
$$;


ALTER FUNCTION "public"."create_manual_journal_entry"("p_entry_date" timestamp with time zone, "p_memo" "text", "p_lines" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_order_secure"("p_items" "jsonb", "p_delivery_zone_id" "uuid", "p_payment_method" "text", "p_notes" "text", "p_address" "text", "p_location" "jsonb", "p_customer_name" "text", "p_phone_number" "text", "p_is_scheduled" boolean, "p_scheduled_at" timestamp with time zone, "p_coupon_code" "text" DEFAULT NULL::"text", "p_points_redeemed_value" numeric DEFAULT 0) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
    v_user_id uuid;
    v_order_id uuid;
    v_item_input jsonb;
    v_menu_item record;
    v_menu_item_data jsonb;
    v_cart_item jsonb;
    v_final_items jsonb := '[]'::jsonb;
    v_subtotal numeric := 0;
    v_total numeric := 0;
    v_delivery_fee numeric := 0;
    v_discount_amount numeric := 0;
    v_tax_amount numeric := 0;
    v_tax_rate numeric := 0;
    v_points_earned numeric := 0;
    v_settings jsonb;
    v_zone_data jsonb;
    v_line_total numeric;
    v_addons_price numeric;
    v_unit_price numeric;
    v_base_price numeric;
    v_addon_key text;
    v_addon_qty numeric;
    v_addon_def jsonb;
    v_grade_id text;
    v_grade_def jsonb;
    v_weight numeric;
    v_quantity numeric;
    v_unit_type text;
    v_delivery_pin text;
    v_available_addons jsonb;
    v_selected_addons_map jsonb;
    v_final_selected_addons jsonb;
    v_points_settings jsonb;
    v_currency_val_per_point numeric;
    v_points_per_currency numeric;
    v_coupon_record record;
    v_stock_items jsonb := '[]'::jsonb;
    v_item_name_ar text;
    v_item_name_en text;
begin
    v_user_id := auth.uid();
    if v_user_id is null then
        raise exception 'User not authenticated';
    end if;

    if exists (
      select 1
      from public.admin_users au
      where au.auth_user_id = v_user_id
        and au.is_active = true
      limit 1
    ) then
      raise exception '      .   / .';
    end if;

    select data into v_settings from public.app_settings where id = 'singleton';
    if v_settings is null then
        v_settings := '{}'::jsonb;
    end if;

    for v_item_input in select * from jsonb_array_elements(p_items)
    loop
        select * into v_menu_item from public.menu_items where id = (v_item_input->>'itemId');
        if not found then
            raise exception 'Item not found: %', v_item_input->>'itemId';
        end if;
        
        v_menu_item_data := v_menu_item.data;
        v_item_name_ar := v_menu_item_data->'name'->>'ar';
        v_item_name_en := v_menu_item_data->'name'->>'en';

        v_quantity := coalesce((v_item_input->>'quantity')::numeric, 0);
        v_weight := coalesce((v_item_input->>'weight')::numeric, 0);
        v_unit_type := coalesce(v_menu_item.unit_type, 'piece');
        
        if v_unit_type in ('kg', 'gram') then
             if v_unit_type = 'gram' and (v_menu_item.price_per_unit is not null or (v_menu_item_data->>'pricePerUnit') is not null) then
                 v_base_price := coalesce(v_menu_item.price_per_unit, (v_menu_item_data->>'pricePerUnit')::numeric) / 1000;
                 v_base_price := v_base_price * v_weight;
             else
                 v_base_price := v_menu_item.price * v_weight;
             end if;
             if v_quantity <= 0 then v_quantity := 1; end if;
        else
             v_base_price := v_menu_item.price;
             if v_quantity <= 0 then raise exception 'Quantity must be positive for item %', v_menu_item.id; end if;
        end if;

        v_grade_id := v_item_input->>'gradeId';
        v_grade_def := null;
        if v_grade_id is not null and (v_menu_item_data->'availableGrades') is not null then
             select value into v_grade_def 
             from jsonb_array_elements(v_menu_item_data->'availableGrades') 
             where value->>'id' = v_grade_id;
             
             if v_grade_def is not null then
                 v_base_price := v_base_price * coalesce((v_grade_def->>'priceMultiplier')::numeric, 1.0);
             end if;
        end if;

        v_addons_price := 0;
        v_available_addons := coalesce(v_menu_item_data->'addons', '[]'::jsonb);
        v_selected_addons_map := coalesce(v_item_input->'selectedAddons', '{}'::jsonb);
        v_final_selected_addons := '{}'::jsonb;
        
        for v_addon_key in select jsonb_object_keys(v_selected_addons_map)
        loop
            v_addon_qty := (v_selected_addons_map->>v_addon_key)::numeric;
            if v_addon_qty > 0 then
                select value into v_addon_def
                from jsonb_array_elements(v_available_addons)
                where value->>'id' = v_addon_key;
                
                if v_addon_def is not null then
                    v_addons_price := v_addons_price + ((v_addon_def->>'price')::numeric * v_addon_qty);
                    
                    v_final_selected_addons := jsonb_set(
                        v_final_selected_addons,
                        array[v_addon_key],
                        jsonb_build_object('addon', v_addon_def, 'quantity', v_addon_qty)
                    );
                end if;
            end if;
        end loop;

        v_unit_price := v_base_price + v_addons_price;
        v_line_total := (v_base_price + v_addons_price) * v_quantity; 
        
        v_subtotal := v_subtotal + v_line_total;

        v_cart_item := v_menu_item_data || jsonb_build_object(
            'quantity', v_quantity,
            'weight', v_weight,
            'selectedAddons', v_final_selected_addons,
            'selectedGrade', v_grade_def,
            'cartItemId', gen_random_uuid()::text,
            'price', v_menu_item.price
        );
        
        v_final_items := v_final_items || v_cart_item;
        
        v_stock_items := v_stock_items || jsonb_build_object(
            'itemId', v_menu_item.id,
            'quantity', v_quantity
        );
    end loop;

    if p_delivery_zone_id is not null then
        select data into v_zone_data from public.delivery_zones where id = p_delivery_zone_id;
        if v_zone_data is not null and (v_zone_data->>'isActive')::boolean then
             v_delivery_fee := coalesce((v_zone_data->>'deliveryFee')::numeric, 0);
        else
             v_delivery_fee := coalesce((v_settings->'deliverySettings'->>'baseFee')::numeric, 0);
        end if;
    else
        v_delivery_fee := coalesce((v_settings->'deliverySettings'->>'baseFee')::numeric, 0);
    end if;

    if (v_settings->'deliverySettings'->>'freeDeliveryThreshold') is not null and 
       v_subtotal >= (v_settings->'deliverySettings'->>'freeDeliveryThreshold')::numeric then
        v_delivery_fee := 0;
    end if;

    if p_coupon_code is not null and length(p_coupon_code) > 0 then
        select * into v_coupon_record from public.coupons where lower(code) = lower(p_coupon_code) and is_active = true;
        if found then
             if (v_coupon_record.data->>'expiresAt') is not null and (v_coupon_record.data->>'expiresAt')::timestamptz < now() then
                 raise exception 'Coupon expired';
             end if;
             if (v_coupon_record.data->>'minOrderAmount') is not null and v_subtotal < (v_coupon_record.data->>'minOrderAmount')::numeric then
                 raise exception 'Order amount too low for coupon';
             end if;
             if (v_coupon_record.data->>'usageLimit') is not null and 
                coalesce((v_coupon_record.data->>'usageCount')::int, 0) >= (v_coupon_record.data->>'usageLimit')::int then
                 raise exception 'Coupon usage limit reached';
             end if;
             
             if (v_coupon_record.data->>'type') = 'percentage' then
                 v_discount_amount := v_subtotal * ((v_coupon_record.data->>'value')::numeric / 100);
                 if (v_coupon_record.data->>'maxDiscount') is not null then
                     v_discount_amount := least(v_discount_amount, (v_coupon_record.data->>'maxDiscount')::numeric);
                 end if;
             else
                 v_discount_amount := (v_coupon_record.data->>'value')::numeric;
             end if;
             
             v_discount_amount := least(v_discount_amount, v_subtotal);
             
             update public.coupons 
             set data = jsonb_set(data, '{usageCount}', (coalesce((data->>'usageCount')::int, 0) + 1)::text::jsonb)
             where id = v_coupon_record.id;
        else
             v_discount_amount := 0;
        end if;
    end if;

    if p_points_redeemed_value > 0 then
        v_points_settings := v_settings->'loyaltySettings';
        if (v_points_settings->>'enabled')::boolean then
             v_currency_val_per_point := coalesce((v_points_settings->>'currencyValuePerPoint')::numeric, 0);
             if v_currency_val_per_point > 0 then
                 declare
                     v_user_points int;
                     v_points_needed numeric;
                 begin
                     select loyalty_points into v_user_points from public.customers where auth_user_id = v_user_id;
                     v_points_needed := p_points_redeemed_value / v_currency_val_per_point;
                     
                     if coalesce(v_user_points, 0) < v_points_needed then
                         raise exception 'Insufficient loyalty points';
                     end if;
                     
                     update public.customers 
                     set loyalty_points = loyalty_points - v_points_needed::int
                     where auth_user_id = v_user_id;
                     
                     v_discount_amount := v_discount_amount + p_points_redeemed_value;
                 end;
             end if;
        end if;
    end if;

    if (v_settings->'taxSettings'->>'enabled')::boolean then
        v_tax_rate := coalesce((v_settings->'taxSettings'->>'rate')::numeric, 0);
        v_tax_amount := greatest(0, v_subtotal - v_discount_amount) * (v_tax_rate / 100);
    end if;

    v_total := greatest(0, v_subtotal - v_discount_amount) + v_delivery_fee + v_tax_amount;

    v_points_settings := v_settings->'loyaltySettings';
    if (v_points_settings->>'enabled')::boolean then
        v_points_per_currency := coalesce((v_points_settings->>'pointsPerCurrencyUnit')::numeric, 0);
        v_points_earned := floor(v_subtotal * v_points_per_currency);
    end if;

    v_delivery_pin := floor(random() * 9000 + 1000)::text;

    insert into public.orders (
        customer_auth_user_id,
        status,
        invoice_number,
        data
    )
    values (
        v_user_id,
        case when p_is_scheduled then 'scheduled' else 'pending' end,
        null,
        jsonb_build_object(
            'id', gen_random_uuid(),
            'userId', v_user_id,
            'orderSource', 'online',
            'items', v_final_items,
            'subtotal', v_subtotal,
            'deliveryFee', v_delivery_fee,
            'discountAmount', v_discount_amount,
            'total', v_total,
            'taxAmount', v_tax_amount,
            'taxRate', v_tax_rate,
            'pointsEarned', v_points_earned,
            'pointsRedeemedValue', p_points_redeemed_value,
            'deliveryZoneId', p_delivery_zone_id,
            'paymentMethod', p_payment_method,
            'notes', p_notes,
            'address', p_address,
            'location', p_location,
            'customerName', p_customer_name,
            'phoneNumber', p_phone_number,
            'isScheduled', p_is_scheduled,
            'scheduledAt', p_scheduled_at,
            'deliveryPin', v_delivery_pin,
            'appliedCouponCode', p_coupon_code
        )
    )
    returning id into v_order_id;

    update public.orders 
    set data = jsonb_set(data, '{id}', to_jsonb(v_order_id::text))
    where id = v_order_id
    returning data into v_item_input;

    perform public.reserve_stock_for_order(v_stock_items, v_order_id);

    insert into public.order_events (order_id, action, actor_type, actor_id, to_status, payload)
    values (
        v_order_id,
        'order.created',
        'customer',
        v_user_id,
        case when p_is_scheduled then 'scheduled' else 'pending' end,
        jsonb_build_object(
            'total', v_total,
            'method', p_payment_method
        )
    );

    return v_item_input;
end;
$$;


ALTER FUNCTION "public"."create_order_secure"("p_items" "jsonb", "p_delivery_zone_id" "uuid", "p_payment_method" "text", "p_notes" "text", "p_address" "text", "p_location" "jsonb", "p_customer_name" "text", "p_phone_number" "text", "p_is_scheduled" boolean, "p_scheduled_at" timestamp with time zone, "p_coupon_code" "text", "p_points_redeemed_value" numeric) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_order_secure"("p_items" "jsonb", "p_delivery_zone_id" "uuid", "p_payment_method" "text", "p_notes" "text", "p_address" "text", "p_location" "jsonb", "p_customer_name" "text", "p_phone_number" "text", "p_is_scheduled" boolean, "p_scheduled_at" timestamp with time zone, "p_coupon_code" "text" DEFAULT NULL::"text", "p_points_redeemed_value" numeric DEFAULT 0, "p_explicit_customer_id" "uuid" DEFAULT NULL::"uuid", "p_order_source" "text" DEFAULT 'online'::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
    v_user_id uuid;
    v_order_id uuid;
    v_item_input jsonb;
    v_menu_item record;
    v_menu_item_data jsonb;
    v_cart_item jsonb;
    v_final_items jsonb := '[]'::jsonb;
    v_subtotal numeric := 0;
    v_total numeric := 0;
    v_delivery_fee numeric := 0;
    v_discount_amount numeric := 0;
    v_tax_amount numeric := 0;
    v_tax_rate numeric := 0;
    v_points_earned numeric := 0;
    v_settings jsonb;
    v_zone_data jsonb;
    v_line_total numeric;
    v_addons_price numeric;
    v_unit_price numeric;
    v_base_price numeric;
    v_addon_key text;
    v_addon_qty numeric;
    v_addon_def jsonb;
    v_grade_id text;
    v_grade_def jsonb;
    v_weight numeric;
    v_quantity numeric;
    v_unit_type text;
    v_delivery_pin text;
    v_available_addons jsonb;
    v_selected_addons_map jsonb;
    v_final_selected_addons jsonb;
    v_points_settings jsonb;
    v_currency_val_per_point numeric;
    v_points_per_currency numeric;
    v_coupon_record record;
    v_stock_items jsonb := '[]'::jsonb;
    v_item_name_ar text;
    v_item_name_en text;
    v_priced_unit numeric;
    v_pricing_qty numeric;
    v_warehouse_id uuid;
    v_stock_qty numeric;
    v_has_promotions boolean := false;
    v_promotion_id uuid;
    v_bundle_qty numeric;
    v_promo_snapshot jsonb;
    v_promotion_lines jsonb := '[]'::jsonb;
    v_promo_line_id uuid;
    v_promo_item jsonb;
    v_is_staff boolean := false;
begin
    v_user_id := auth.uid();
    if v_user_id is null then
        raise exception 'User not authenticated';
    end if;

    -- Check if user is staff
    if exists (
      select 1
      from public.admin_users au
      where au.auth_user_id = v_user_id
        and au.is_active = true
      limit 1
    ) then
      v_is_staff := true;
    end if;

    -- Staff Blocking Logic
    if v_is_staff then
       if p_order_source = 'online' and p_explicit_customer_id is null then
          -- Staff trying to make a personal online order? Block.
          raise exception '      .   / .';
       end if;
       
       -- Allow substituting the customer ID
       if p_explicit_customer_id is not null then
          v_user_id := p_explicit_customer_id;
       elsif p_order_source = 'in_store' then
          -- Walk-in customer entered by staff
          v_user_id := null;
       end if;
    else
       -- Normal customer
       -- Ensure order_source is consistent (force online if not specified? or allow app to say in_store?)
       -- Usually customers are 'online'.
       if p_order_source <> 'online' then
          -- Maybe in future we allow Kiosk mode? For now trust caller or force 'online'
          -- p_order_source := 'online'; -- Let's respect it for now but default is online
          null;
       end if;
    end if;

    v_warehouse_id := public._resolve_default_warehouse_id();

    select data into v_settings from public.app_settings where id = 'singleton';
    if v_settings is null then
        v_settings := '{}'::jsonb;
    end if;

    if p_items is null or jsonb_typeof(p_items) <> 'array' then
      raise exception 'p_items must be a json array';
    end if;

    for v_item_input in select * from jsonb_array_elements(p_items)
    loop
        v_promotion_id := public._uuid_or_null(v_item_input->>'promotionId');
        if v_promotion_id is not null or coalesce(nullif(v_item_input->>'lineType',''), '') = 'promotion' then
          v_has_promotions := true;
          v_bundle_qty := coalesce(nullif((v_item_input->>'bundleQty')::numeric, null), nullif((v_item_input->>'quantity')::numeric, null), 1);
          if v_bundle_qty <= 0 then v_bundle_qty := 1; end if;

          if p_coupon_code is not null and length(p_coupon_code) > 0 then
            raise exception 'promotion_coupon_conflict';
          end if;
          if coalesce(p_points_redeemed_value, 0) > 0 then
            raise exception 'promotion_points_conflict';
          end if;

          v_promo_snapshot := public._compute_promotion_snapshot(v_promotion_id, v_user_id, v_warehouse_id, v_bundle_qty, null, true);
          v_promo_line_id := gen_random_uuid();

          v_cart_item := jsonb_build_object(
            'lineType', 'promotion',
            'promotionId', v_promotion_id::text,
            'promotionLineId', v_promo_line_id::text,
            'name', v_promo_snapshot->>'name',
            'bundleQty', coalesce(nullif((v_promo_snapshot->>'bundleQty')::numeric, null), v_bundle_qty),
            'originalTotal', coalesce(nullif((v_promo_snapshot->>'computedOriginalTotal')::numeric, null), 0),
            'finalTotal', coalesce(nullif((v_promo_snapshot->>'finalTotal')::numeric, null), 0),
            'promotionExpense', coalesce(nullif((v_promo_snapshot->>'promotionExpense')::numeric, null), 0),
            'cartItemId', coalesce(nullif(v_item_input->>'cartItemId',''), gen_random_uuid()::text)
          );

          v_final_items := v_final_items || v_cart_item;
          v_subtotal := v_subtotal + coalesce(nullif((v_promo_snapshot->>'finalTotal')::numeric, null), 0);

          v_promotion_lines := v_promotion_lines || (v_promo_snapshot || jsonb_build_object(
            'promotionLineId', v_promo_line_id::text
          ));

          for v_promo_item in select value from jsonb_array_elements(coalesce(v_promo_snapshot->'items','[]'::jsonb))
          loop
            v_stock_items := v_stock_items || jsonb_build_object(
              'itemId', v_promo_item->>'itemId',
              'quantity', coalesce(nullif((v_promo_item->>'quantity')::numeric, null), 0)
            );
          end loop;

          continue;
        end if;

        select * into v_menu_item from public.menu_items where id = (v_item_input->>'itemId');
        if not found then
            raise exception 'Item not found: %', v_item_input->>'itemId';
        end if;
        
        v_menu_item_data := v_menu_item.data;
        v_item_name_ar := v_menu_item_data->'name'->>'ar';
        v_item_name_en := v_menu_item_data->'name'->>'en';

        v_quantity := coalesce((v_item_input->>'quantity')::numeric, 0);
        v_weight := coalesce((v_item_input->>'weight')::numeric, 0);
        v_unit_type := coalesce(v_menu_item.unit_type, 'piece');

        if v_unit_type in ('kg', 'gram') then
            if v_weight <= 0 then
              raise exception 'Weight must be positive for item %', v_menu_item.id;
            end if;
            if v_quantity <= 0 then v_quantity := 1; end if;
            v_pricing_qty := v_weight;
            v_priced_unit := public.get_item_price_with_discount(v_menu_item.id::text, v_user_id, v_pricing_qty);
            v_base_price := v_priced_unit * v_weight;
            v_stock_qty := v_weight;
        else
            if v_quantity <= 0 then raise exception 'Quantity must be positive for item %', v_menu_item.id; end if;
            v_pricing_qty := v_quantity;
            v_priced_unit := public.get_item_price_with_discount(v_menu_item.id::text, v_user_id, v_pricing_qty);
            v_base_price := v_priced_unit;
            v_stock_qty := v_quantity;
        end if;

        v_grade_id := v_item_input->>'gradeId';
        v_grade_def := null;
        if v_grade_id is not null and (v_menu_item_data->'availableGrades') is not null then
            select value into v_grade_def
            from jsonb_array_elements(v_menu_item_data->'availableGrades')
            where value->>'id' = v_grade_id;
            
            if v_grade_def is not null then
                v_priced_unit := v_priced_unit * coalesce((v_grade_def->>'priceMultiplier')::numeric, 1.0);
                v_base_price := v_base_price * coalesce((v_grade_def->>'priceMultiplier')::numeric, 1.0);
            end if;
        end if;

        v_addons_price := 0;
        v_available_addons := coalesce(v_menu_item_data->'addons', '[]'::jsonb);
        v_selected_addons_map := coalesce(v_item_input->'selectedAddons', '{}'::jsonb);
        v_final_selected_addons := '{}'::jsonb;
        
        for v_addon_key in select jsonb_object_keys(v_selected_addons_map)
        loop
            v_addon_qty := (v_selected_addons_map->>v_addon_key)::numeric;
            if v_addon_qty > 0 then
                select value into v_addon_def
                from jsonb_array_elements(v_available_addons)
                where value->>'id' = v_addon_key;
                
                if v_addon_def is not null then
                    v_addons_price := v_addons_price + ((v_addon_def->>'price')::numeric * v_addon_qty);
                    v_final_selected_addons := jsonb_set(
                        v_final_selected_addons,
                        array[v_addon_key],
                        jsonb_build_object('addon', v_addon_def, 'quantity', v_addon_qty)
                    );
                end if;
            end if;
        end loop;

        if v_unit_type in ('kg', 'gram') then
            v_unit_price := v_base_price + v_addons_price;
            v_line_total := (v_base_price + v_addons_price) * v_quantity;
        else
            v_unit_price := v_priced_unit + v_addons_price;
            v_line_total := (v_priced_unit + v_addons_price) * v_quantity;
        end if;
        
        v_subtotal := v_subtotal + v_line_total;

        v_cart_item := v_menu_item_data || jsonb_build_object(
            'quantity', v_quantity,
            'weight', v_weight,
            'selectedAddons', v_final_selected_addons,
            'selectedGrade', v_grade_def,
            'cartItemId', gen_random_uuid()::text,
            'price', v_priced_unit
        );
        if v_unit_type = 'gram' then
          v_cart_item := v_cart_item || jsonb_build_object('pricePerUnit', (v_priced_unit * 1000));
        end if;
        
        v_final_items := v_final_items || v_cart_item;
        
        v_stock_items := v_stock_items || jsonb_build_object(
            'itemId', v_menu_item.id,
            'quantity', v_stock_qty
        );
    end loop;

    if p_delivery_zone_id is not null then
        select data into v_zone_data from public.delivery_zones where id = p_delivery_zone_id;
        if v_zone_data is not null and (v_zone_data->>'isActive')::boolean then
            v_delivery_fee := coalesce((v_zone_data->>'deliveryFee')::numeric, 0);
        else
            v_delivery_fee := coalesce((v_settings->'deliverySettings'->>'baseFee')::numeric, 0);
        end if;
    else
        v_delivery_fee := coalesce((v_settings->'deliverySettings'->>'baseFee')::numeric, 0);
    end if;

    if (v_settings->'deliverySettings'->>'freeDeliveryThreshold') is not null and
       v_subtotal >= (v_settings->'deliverySettings'->>'freeDeliveryThreshold')::numeric then
        v_delivery_fee := 0;
    end if;

    if not v_has_promotions and p_coupon_code is not null and length(p_coupon_code) > 0 then
        select * into v_coupon_record from public.coupons where lower(code) = lower(p_coupon_code) and is_active = true;
        if found then
            if (v_coupon_record.data->>'expiresAt') is not null and (v_coupon_record.data->>'expiresAt')::timestamptz < now() then
                raise exception 'Coupon expired';
            end if;
            if (v_coupon_record.data->>'minOrderAmount') is not null and v_subtotal < (v_coupon_record.data->>'minOrderAmount')::numeric then
                raise exception 'Order amount too low for coupon';
            end if;
            if (v_coupon_record.data->>'usageLimit') is not null and
               coalesce((v_coupon_record.data->>'usageCount')::int, 0) >= (v_coupon_record.data->>'usageLimit')::int then
                raise exception 'Coupon usage limit reached';
            end if;
            
            if (v_coupon_record.data->>'type') = 'percentage' then
                v_discount_amount := v_subtotal * ((v_coupon_record.data->>'value')::numeric / 100);
                if (v_coupon_record.data->>'maxDiscount') is not null then
                    v_discount_amount := least(v_discount_amount, (v_coupon_record.data->>'maxDiscount')::numeric);
                end if;
            else
                v_discount_amount := (v_coupon_record.data->>'value')::numeric;
            end if;
            
            v_discount_amount := least(v_discount_amount, v_subtotal);
            
            update public.coupons
            set data = jsonb_set(data, '{usageCount}', (coalesce((data->>'usageCount')::int, 0) + 1)::text::jsonb)
            where id = v_coupon_record.id;
        else
            v_discount_amount := 0;
        end if;
    end if;

    if not v_has_promotions and p_points_redeemed_value > 0 then
        v_points_settings := v_settings->'loyaltySettings';
        if (v_points_settings->>'enabled')::boolean then
            v_currency_val_per_point := coalesce((v_points_settings->>'currencyValuePerPoint')::numeric, 0);
            if v_currency_val_per_point > 0 then
                declare
                    v_user_points int;
                    v_points_needed numeric;
                begin
                    -- If Walk-in (v_user_id is null), they cannot redeem points!
                    if v_user_id is null then
                        raise exception 'Cannot redeem points for walk-in customer';
                    end if;
                    select loyalty_points into v_user_points from public.customers where auth_user_id = v_user_id;
                    v_points_needed := p_points_redeemed_value / v_currency_val_per_point;
                    
                    if coalesce(v_user_points, 0) < v_points_needed then
                        raise exception 'Insufficient loyalty points';
                    end if;
                    
                    update public.customers
                    set loyalty_points = loyalty_points - v_points_needed::int
                    where auth_user_id = v_user_id;
                    
                    v_discount_amount := v_discount_amount + p_points_redeemed_value;
                end;
            end if;
        end if;
    end if;

    if (v_settings->'taxSettings'->>'enabled')::boolean then
        v_tax_rate := coalesce((v_settings->'taxSettings'->>'rate')::numeric, 0);
        v_tax_amount := greatest(0, v_subtotal - v_discount_amount) * (v_tax_rate / 100);
    end if;

    v_total := greatest(0, v_subtotal - v_discount_amount) + v_delivery_fee + v_tax_amount;

    v_points_settings := v_settings->'loyaltySettings';
    if (v_points_settings->>'enabled')::boolean then
        v_points_per_currency := coalesce((v_points_settings->>'pointsPerCurrencyUnit')::numeric, 0);
        v_points_earned := floor(v_subtotal * v_points_per_currency);
    end if;

    v_delivery_pin := floor(random() * 9000 + 1000)::text;

    v_stock_items := public._merge_stock_items(v_stock_items);

    insert into public.orders (
        customer_auth_user_id,
        status,
        invoice_number,
        data
    )
    values (
        v_user_id,
        case when p_is_scheduled then 'scheduled' else 'pending' end,
        null,
        jsonb_build_object(
            'id', gen_random_uuid(),
            'userId', v_user_id,
            'orderSource', p_order_source,
            'items', v_final_items,
            'promotionLines', case when v_has_promotions then v_promotion_lines else '[]'::jsonb end,
            'subtotal', public._money_round(v_subtotal),
            'deliveryFee', public._money_round(v_delivery_fee),
            'discountAmount', public._money_round(v_discount_amount),
            'total', public._money_round(v_total),
            'taxAmount', public._money_round(v_tax_amount),
            'taxRate', v_tax_rate,
            'pointsEarned', v_points_earned,
            'pointsRedeemedValue', p_points_redeemed_value,
            'deliveryZoneId', p_delivery_zone_id,
            'paymentMethod', p_payment_method,
            'notes', p_notes,
            'address', p_address,
            'location', p_location,
            'customerName', p_customer_name,
            'phoneNumber', p_phone_number,
            'isScheduled', p_is_scheduled,
            'scheduledAt', p_scheduled_at,
            'deliveryPin', v_delivery_pin,
            'appliedCouponCode', p_coupon_code,
            'warehouseId', v_warehouse_id
        )
    )
    returning id into v_order_id;

    update public.orders
    set data = jsonb_set(data, '{id}', to_jsonb(v_order_id::text))
    where id = v_order_id
    returning data into v_item_input;

    perform public.reserve_stock_for_order(v_stock_items, v_order_id, v_warehouse_id);

    if v_has_promotions then
      for v_promo_snapshot in select value from jsonb_array_elements(v_promotion_lines)
      loop
        insert into public.promotion_usage(
          promotion_id,
          promotion_line_id,
          order_id,
          bundle_qty,
          channel,
          warehouse_id,
          snapshot,
          created_by
        )
        values (
          (v_promo_snapshot->>'promotionId')::uuid,
          (v_promo_snapshot->>'promotionLineId')::uuid,
          v_order_id,
          coalesce(nullif((v_promo_snapshot->>'bundleQty')::numeric, null), 1),
          p_order_source,
          v_warehouse_id,
          v_promo_snapshot,
          auth.uid()
        );
      end loop;
    end if;

    insert into public.order_events (order_id, action, actor_type, actor_id, to_status, payload)
    values (
        v_order_id,
        'order.created',
        'customer',
        coalesce(v_user_id, auth.uid()), -- If walked in, actor is staff (auth.uid). If customer, actor is user.
        case when p_is_scheduled then 'scheduled' else 'pending' end,
        jsonb_build_object('total', public._money_round(v_total), 'method', p_payment_method)
    );

    return v_item_input;
end;
$$;


ALTER FUNCTION "public"."create_order_secure"("p_items" "jsonb", "p_delivery_zone_id" "uuid", "p_payment_method" "text", "p_notes" "text", "p_address" "text", "p_location" "jsonb", "p_customer_name" "text", "p_phone_number" "text", "p_is_scheduled" boolean, "p_scheduled_at" timestamp with time zone, "p_coupon_code" "text", "p_points_redeemed_value" numeric, "p_explicit_customer_id" "uuid", "p_order_source" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_order_secure_with_payment_proof"("p_items" "jsonb", "p_delivery_zone_id" "uuid", "p_payment_method" "text", "p_notes" "text", "p_address" "text", "p_location" "jsonb", "p_customer_name" "text", "p_phone_number" "text", "p_is_scheduled" boolean, "p_scheduled_at" timestamp with time zone, "p_coupon_code" "text" DEFAULT NULL::"text", "p_points_redeemed_value" numeric DEFAULT 0, "p_payment_proof_type" "text" DEFAULT NULL::"text", "p_payment_proof" "text" DEFAULT NULL::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
declare
  v_payment_method text;
  v_proof_type text;
  v_proof text;
  v_order jsonb;
  v_order_id uuid;
  v_coupon_id uuid;
  v_customer_name text;
  v_phone text;
  v_address text;
begin
  v_payment_method := lower(btrim(coalesce(p_payment_method, '')));
  if v_payment_method not in ('cash', 'kuraimi', 'network') then
    raise exception '   ';
  end if;

  v_customer_name := btrim(coalesce(p_customer_name, ''));
  if length(v_customer_name) < 3 or length(v_customer_name) > 50 or v_customer_name !~ '^[\u0600-\u06FFa-zA-Z\s]+$' then
    raise exception '   ';
  end if;

  v_phone := btrim(coalesce(p_phone_number, ''));
  if v_phone !~ '^(77|73|71|70)[0-9]{7}$' then
    raise exception '   ';
  end if;

  v_address := btrim(coalesce(p_address, ''));
  if length(v_address) < 10 or length(v_address) > 200 then
    raise exception '  ';
  end if;

  v_proof_type := nullif(btrim(coalesce(p_payment_proof_type, '')), '');
  v_proof := nullif(btrim(coalesce(p_payment_proof, '')), '');

  if v_payment_method = 'cash' then
    if v_proof_type is not null or v_proof is not null then
      raise exception '     ';
    end if;
  else
    if v_payment_method in ('kuraimi', 'network') then
      if v_proof_type is null or v_proof is null then
        raise exception '      ';
      end if;
      if v_proof_type not in ('image', 'ref_number') then
        raise exception '    ';
      end if;
    end if;
  end if;

  if p_coupon_code is not null and length(btrim(p_coupon_code)) > 0 then
    select c.id
    into v_coupon_id
    from public.coupons c
    where lower(c.code) = lower(btrim(p_coupon_code))
      and c.is_active = true
    for update;
  end if;

  v_order := public.create_order_secure(
    p_items,
    p_delivery_zone_id,
    v_payment_method,
    p_notes,
    v_address,
    p_location,
    v_customer_name,
    v_phone,
    p_is_scheduled,
    p_scheduled_at,
    p_coupon_code,
    p_points_redeemed_value
  );

  v_order_id := (v_order->>'id')::uuid;

  if v_payment_method in ('kuraimi', 'network') then
    update public.orders
    set data = jsonb_set(
      jsonb_set(data, '{paymentProofType}', to_jsonb(v_proof_type), true),
      '{paymentProof}',
      to_jsonb(p_payment_proof),
      true
    )
    where id = v_order_id;

    v_order := jsonb_set(
      jsonb_set(v_order, '{paymentProofType}', to_jsonb(v_proof_type), true),
      '{paymentProof}',
      to_jsonb(p_payment_proof),
      true
    );
  end if;

  return v_order;
end;
$_$;


ALTER FUNCTION "public"."create_order_secure_with_payment_proof"("p_items" "jsonb", "p_delivery_zone_id" "uuid", "p_payment_method" "text", "p_notes" "text", "p_address" "text", "p_location" "jsonb", "p_customer_name" "text", "p_phone_number" "text", "p_is_scheduled" boolean, "p_scheduled_at" timestamp with time zone, "p_coupon_code" "text", "p_points_redeemed_value" numeric, "p_payment_proof_type" "text", "p_payment_proof" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_order_secure_with_payment_proof"("p_items" "jsonb", "p_delivery_zone_id" "uuid", "p_payment_method" "text", "p_notes" "text", "p_address" "text", "p_location" "jsonb", "p_customer_name" "text", "p_phone_number" "text", "p_is_scheduled" boolean, "p_scheduled_at" timestamp with time zone, "p_coupon_code" "text" DEFAULT NULL::"text", "p_points_redeemed_value" numeric DEFAULT 0, "p_payment_proof_type" "text" DEFAULT NULL::"text", "p_payment_proof" "text" DEFAULT NULL::"text", "p_order_source" "text" DEFAULT 'online'::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
declare
  v_payment_method text;
  v_proof_type text;
  v_proof text;
  v_order jsonb;
  v_order_id uuid;
  v_coupon_id uuid;
  v_customer_name text;
  v_phone text;
  v_address text;
begin
  v_payment_method := lower(btrim(coalesce(p_payment_method, '')));
  if v_payment_method not in ('cash', 'kuraimi', 'network', 'mixed', 'unknown') then
     -- 'mixed' and 'unknown' are allowed for in_store
     if p_order_source = 'online' then
        raise exception '   ';
     end if;
  end if;

  v_customer_name := btrim(coalesce(p_customer_name, ''));
  if length(v_customer_name) < 2 then
    if p_order_source = 'in_store' then
       v_customer_name := ' ';
    else
       raise exception '   ';
    end if;
  end if;

  v_phone := btrim(coalesce(p_phone_number, ''));
  
  -- Validation Logic for Phone
  if length(v_phone) > 0 then
      -- If provided, must look like a phone number (relaxed)
      -- Allow 7x or 05x or just digits 9+ length
      if v_phone !~ '^[0-9+]{9,15}$' and v_phone !~ '^(77|73|71|70)[0-9]{7}$' then
          -- Keep strict Yemen check if it looks short, otherwise allow international?
          -- For now, let's just enforce the previous strict check ONLY if it matches the length of local mobile
          -- Or just allow it if it's in_store?
          if p_order_source = 'online' and v_phone !~ '^(77|73|71|70)[0-9]{7}$' then
             raise exception '   ';
          end if;
      end if;
  else
      -- Empty phone
      if p_order_source = 'online' then
         raise exception '    ';
      end if;
  end if;

  v_address := btrim(coalesce(p_address, ''));
  if length(v_address) < 2 then
     if p_order_source = 'in_store' then
        v_address := ' ';
     else
        raise exception '  ';
     end if;
  end if;

  v_proof_type := nullif(btrim(coalesce(p_payment_proof_type, '')), '');
  v_proof := nullif(btrim(coalesce(p_payment_proof, '')), '');

  if v_payment_method = 'cash' then
    if v_proof_type is not null or v_proof is not null then
      -- In store cash might have reference? No.
      null; 
    end if;
  else
    if v_payment_method in ('kuraimi', 'network') and p_order_source = 'online' then
      if v_proof_type is null or v_proof is null then
        raise exception '      ';
      end if;
    end if;
  end if;

  if p_coupon_code is not null and length(btrim(p_coupon_code)) > 0 then
    select c.id
    into v_coupon_id
    from public.coupons c
    where lower(c.code) = lower(btrim(p_coupon_code))
      and c.is_active = true
    for update;
  end if;

  -- Create the order using core function (defaults to online)
  v_order := public.create_order_secure(
    p_items,
    p_delivery_zone_id,
    v_payment_method,
    p_notes,
    v_address,
    p_location,
    v_customer_name,
    v_phone,
    p_is_scheduled,
    p_scheduled_at,
    p_coupon_code,
    p_points_redeemed_value
  );

  v_order_id := (v_order->>'id')::uuid;

  -- Post-Creation Updates
  
  -- 1. Update Order Source if not online
  if p_order_source <> 'online' then
      update public.orders
      set data = jsonb_set(data, '{orderSource}', to_jsonb(p_order_source), true),
          order_source = p_order_source -- if column exists, usually mapped from data
      where id = v_order_id;
      
      v_order := jsonb_set(v_order, '{orderSource}', to_jsonb(p_order_source), true);
  end if;

  -- 2. Update Payment Proof info if needed
  if v_proof_type is not null then
    update public.orders
    set data = jsonb_set(
      jsonb_set(data, '{paymentProofType}', to_jsonb(v_proof_type), true),
      '{paymentProof}',
      to_jsonb(v_proof),
      true
    )
    where id = v_order_id;

    v_order := jsonb_set(
      jsonb_set(v_order, '{paymentProofType}', to_jsonb(v_proof_type), true),
      '{paymentProof}',
      to_jsonb(v_proof),
      true
    );
  end if;

  return v_order;
end;
$_$;


ALTER FUNCTION "public"."create_order_secure_with_payment_proof"("p_items" "jsonb", "p_delivery_zone_id" "uuid", "p_payment_method" "text", "p_notes" "text", "p_address" "text", "p_location" "jsonb", "p_customer_name" "text", "p_phone_number" "text", "p_is_scheduled" boolean, "p_scheduled_at" timestamp with time zone, "p_coupon_code" "text", "p_points_redeemed_value" numeric, "p_payment_proof_type" "text", "p_payment_proof" "text", "p_order_source" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_order_secure_with_payment_proof"("p_items" "jsonb", "p_delivery_zone_id" "uuid", "p_payment_method" "text", "p_notes" "text", "p_address" "text", "p_location" "jsonb", "p_customer_name" "text", "p_phone_number" "text", "p_is_scheduled" boolean, "p_scheduled_at" timestamp with time zone, "p_coupon_code" "text" DEFAULT NULL::"text", "p_points_redeemed_value" numeric DEFAULT 0, "p_payment_proof_type" "text" DEFAULT NULL::"text", "p_payment_proof" "text" DEFAULT NULL::"text", "p_order_source" "text" DEFAULT 'online'::"text", "p_explicit_customer_id" "uuid" DEFAULT NULL::"uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
declare
  v_payment_method text;
  v_proof_type text;
  v_proof text;
  v_order jsonb;
  v_order_id uuid;
  v_coupon_id uuid;
  v_customer_name text;
  v_phone text;
  v_address text;
begin
  v_payment_method := lower(btrim(coalesce(p_payment_method, '')));
  if v_payment_method not in ('cash', 'kuraimi', 'network', 'mixed', 'unknown') then
     if p_order_source = 'online' then
        raise exception '   ';
     end if;
  end if;

  v_customer_name := btrim(coalesce(p_customer_name, ''));
  if length(v_customer_name) < 2 then
    if p_order_source = 'in_store' then
       v_customer_name := ' ';
    else
       raise exception '   ';
    end if;
  end if;

  v_phone := btrim(coalesce(p_phone_number, ''));
  if length(v_phone) > 0 then
      if v_phone !~ '^[0-9+]{9,15}$' and v_phone !~ '^(77|73|71|70)[0-9]{7}$' then
          if p_order_source = 'online' and v_phone !~ '^(77|73|71|70)[0-9]{7}$' then
             raise exception '   ';
          end if;
      end if;
  else
      if p_order_source = 'online' then
         raise exception '    ';
      end if;
  end if;

  v_address := btrim(coalesce(p_address, ''));
  if length(v_address) < 2 then
     if p_order_source = 'in_store' then
        v_address := ' ';
     else
        raise exception '  ';
     end if;
  end if;

  v_proof_type := nullif(btrim(coalesce(p_payment_proof_type, '')), '');
  v_proof := nullif(btrim(coalesce(p_payment_proof, '')), '');

  if v_payment_method = 'cash' then
    if v_proof_type is not null or v_proof is not null then
      null; 
    end if;
  else
    if v_payment_method in ('kuraimi', 'network') and p_order_source = 'online' then
       if v_proof_type is null or v_proof is null then
         raise exception '      ';
       end if;
    end if;
  end if;

  if p_coupon_code is not null and length(btrim(p_coupon_code)) > 0 then
    select c.id
    into v_coupon_id
    from public.coupons c
    where lower(c.code) = lower(btrim(p_coupon_code))
      and c.is_active = true
    for update;
  end if;

  v_order := public.create_order_secure(
    p_items,
    p_delivery_zone_id,
    v_payment_method,
    p_notes,
    v_address,
    p_location,
    v_customer_name,
    v_phone,
    p_is_scheduled,
    p_scheduled_at,
    p_coupon_code,
    p_points_redeemed_value,
    p_explicit_customer_id,
    p_order_source
  );

  v_order_id := (v_order->>'id')::uuid;

  if v_proof_type is not null then
    update public.orders
    set data = jsonb_set(
      jsonb_set(data, '{paymentProofType}', to_jsonb(v_proof_type), true),
      '{paymentProof}',
      to_jsonb(v_proof),
      true
    )
    where id = v_order_id;
    
    v_order := jsonb_set(
      jsonb_set(v_order, '{paymentProofType}', to_jsonb(v_proof_type), true),
      '{paymentProof}',
      to_jsonb(v_proof),
      true
    );
  end if;

  return v_order;
end;
$_$;


ALTER FUNCTION "public"."create_order_secure_with_payment_proof"("p_items" "jsonb", "p_delivery_zone_id" "uuid", "p_payment_method" "text", "p_notes" "text", "p_address" "text", "p_location" "jsonb", "p_customer_name" "text", "p_phone_number" "text", "p_is_scheduled" boolean, "p_scheduled_at" timestamp with time zone, "p_coupon_code" "text", "p_points_redeemed_value" numeric, "p_payment_proof_type" "text", "p_payment_proof" "text", "p_order_source" "text", "p_explicit_customer_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_production_order"("p_inputs" "jsonb", "p_outputs" "jsonb", "p_notes" "text" DEFAULT NULL::"text", "p_occurred_at" timestamp with time zone DEFAULT "now"()) RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_order_id uuid;
  v_in jsonb;
  v_out jsonb;
  v_item_id text;
  v_qty numeric;
  v_old_qty numeric;
  v_old_avg numeric;
  v_unit_cost numeric;
  v_total_cost numeric;
  v_inputs_total_cost numeric := 0;
  v_outputs_total_qty numeric := 0;
  v_out_unit_cost numeric := 0;
  v_movement_id uuid;
begin
  if not public.is_admin() then
    raise exception 'not allowed';
  end if;
  if p_inputs is null or jsonb_typeof(p_inputs) <> 'array' then
    raise exception 'p_inputs must be a json array';
  end if;
  if p_outputs is null or jsonb_typeof(p_outputs) <> 'array' then
    raise exception 'p_outputs must be a json array';
  end if;

  insert into public.production_orders(occurred_at, created_by, notes)
  values (coalesce(p_occurred_at, now()), auth.uid(), p_notes)
  returning id into v_order_id;

  for v_in in select value from jsonb_array_elements(p_inputs)
  loop
    v_item_id := v_in->>'itemId';
    v_qty := coalesce(nullif(v_in->>'quantity', '')::numeric, 0);
    if v_item_id is null or v_item_id = '' then
      raise exception 'Invalid input itemId';
    end if;
    if v_qty <= 0 then
      continue;
    end if;

    select coalesce(sm.available_quantity, 0), coalesce(sm.avg_cost, 0)
    into v_old_qty, v_old_avg
    from public.stock_management sm
    where sm.item_id = v_item_id
    for update;
    if not found then
      raise exception 'Stock record not found for input %', v_item_id;
    end if;
    if (v_old_qty + 1e-9) < v_qty then
      raise exception 'Insufficient stock for input % (available %, requested %)', v_item_id, v_old_qty, v_qty;
    end if;

    v_unit_cost := v_old_avg;
    v_total_cost := v_unit_cost * v_qty;
    v_inputs_total_cost := v_inputs_total_cost + v_total_cost;

    update public.stock_management
    set available_quantity = greatest(0, available_quantity - v_qty),
        last_updated = now(),
        updated_at = now()
    where item_id = v_item_id;

    insert into public.production_order_inputs(order_id, item_id, quantity, unit_cost, total_cost)
    values (v_order_id, v_item_id, v_qty, v_unit_cost, v_total_cost);

    insert into public.inventory_movements(
      item_id, movement_type, quantity, unit_cost, total_cost,
      reference_table, reference_id, occurred_at, created_by, data
    )
    values (
      v_item_id, 'adjust_out', v_qty, v_unit_cost, v_total_cost,
      'production_orders', v_order_id::text, coalesce(p_occurred_at, now()), auth.uid(),
      jsonb_build_object('reason', 'production_consume', 'productionOrderId', v_order_id)
    )
    returning id into v_movement_id;
  end loop;

  for v_out in select value from jsonb_array_elements(p_outputs)
  loop
    v_outputs_total_qty := v_outputs_total_qty + coalesce(nullif(v_out->>'quantity', '')::numeric, 0);
  end loop;
  if v_outputs_total_qty <= 0 then
    raise exception 'Total output quantity must be > 0';
  end if;
  v_out_unit_cost := v_inputs_total_cost / v_outputs_total_qty;

  for v_out in select value from jsonb_array_elements(p_outputs)
  loop
    v_item_id := v_out->>'itemId';
    v_qty := coalesce(nullif(v_out->>'quantity', '')::numeric, 0);
    if v_item_id is null or v_item_id = '' then
      raise exception 'Invalid output itemId';
    end if;
    if v_qty <= 0 then
      continue;
    end if;

    select coalesce(sm.available_quantity, 0), coalesce(sm.avg_cost, 0)
    into v_old_qty, v_old_avg
    from public.stock_management sm
    where sm.item_id = v_item_id
    for update;

    v_unit_cost := v_out_unit_cost;
    v_total_cost := v_unit_cost * v_qty;

    update public.stock_management
    set available_quantity = available_quantity + v_qty,
        avg_cost = case when (coalesce(v_old_qty, 0) + v_qty) <= 1e-9
                        then v_unit_cost
                        else ((coalesce(v_old_qty, 0) * coalesce(v_old_avg, 0)) + (v_qty * v_unit_cost)) / (coalesce(v_old_qty, 0) + v_qty)
                   end,
        last_updated = now(),
        updated_at = now()
    where item_id = v_item_id;

    insert into public.production_order_outputs(order_id, item_id, quantity, unit_cost, total_cost)
    values (v_order_id, v_item_id, v_qty, v_unit_cost, v_total_cost);

    insert into public.inventory_movements(
      item_id, movement_type, quantity, unit_cost, total_cost,
      reference_table, reference_id, occurred_at, created_by, data
    )
    values (
      v_item_id, 'adjust_in', v_qty, v_unit_cost, v_total_cost,
      'production_orders', v_order_id::text, coalesce(p_occurred_at, now()), auth.uid(),
      jsonb_build_object('reason', 'production_output', 'productionOrderId', v_order_id)
    )
    returning id into v_movement_id;
  end loop;

  perform public.post_production_order(v_order_id);
  return v_order_id;
end;
$$;


ALTER FUNCTION "public"."create_production_order"("p_inputs" "jsonb", "p_outputs" "jsonb", "p_notes" "text", "p_occurred_at" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_purchase_return"("p_order_id" "uuid", "p_items" "jsonb", "p_reason" "text" DEFAULT NULL::"text", "p_occurred_at" timestamp with time zone DEFAULT "now"()) RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
declare
  v_po record;
  v_item jsonb;
  v_item_id_text text;
  v_item_id_uuid uuid;
  v_qty numeric;
  v_po_unit_cost numeric;
  v_stock_available numeric;
  v_stock_reserved numeric;
  v_stock_avg_cost numeric;
  v_return_item_total numeric;
  v_return_total numeric := 0;
  v_new_total numeric;
  v_return_id uuid;
  v_movement_id uuid;
  v_stock_item_id_is_uuid boolean;
  v_return_items_item_id_is_uuid boolean;
  v_inventory_movements_item_id_is_uuid boolean;
  v_inventory_movements_reference_id_is_uuid boolean;
  v_has_sm_warehouse boolean := false;
  v_has_im_batch boolean := false;
  v_has_im_warehouse boolean := false;
  v_has_bb boolean := false;
  v_has_bb_warehouse boolean := false;
  v_wh uuid;
  v_received_qty numeric;
  v_prev_returned numeric;
  v_needed numeric;
  v_take numeric;
  v_batch record;
begin
  if not public.can_manage_stock() then
    raise exception 'not allowed';
  end if;
  if p_order_id is null then
    raise exception 'p_order_id is required';
  end if;
  if p_items is null or jsonb_typeof(p_items) <> 'array' then
    raise exception 'p_items must be a json array';
  end if;
  if not exists (
    select 1
    from jsonb_array_elements(p_items) e
    where coalesce(nullif(e.value->>'quantity', '')::numeric, 0) > 0
  ) then
    raise exception 'no return items';
  end if;
  v_has_sm_warehouse := exists (
    select 1
    from information_schema.columns
    where table_schema = 'public'
      and table_name = 'stock_management'
      and column_name = 'warehouse_id'
  );
  v_has_bb := to_regclass('public.batch_balances') is not null;
  if v_has_bb then
    v_has_bb_warehouse := exists (
      select 1
      from information_schema.columns
      where table_schema = 'public'
        and table_name = 'batch_balances'
        and column_name = 'warehouse_id'
    );
  end if;
  v_has_im_batch := exists (
    select 1
    from information_schema.columns
    where table_schema = 'public'
      and table_name = 'inventory_movements'
      and column_name = 'batch_id'
  );
  v_has_im_warehouse := exists (
    select 1
    from information_schema.columns
    where table_schema = 'public'
      and table_name = 'inventory_movements'
      and column_name = 'warehouse_id'
  );
  select (t.typname = 'uuid')
  into v_stock_item_id_is_uuid
  from pg_attribute a
  join pg_class c on a.attrelid = c.oid
  join pg_namespace n on c.relnamespace = n.oid
  join pg_type t on a.atttypid = t.oid
  where n.nspname = 'public'
    and c.relname = 'stock_management'
    and a.attname = 'item_id'
    and a.attnum > 0
    and not a.attisdropped;
  select (t.typname = 'uuid')
  into v_return_items_item_id_is_uuid
  from pg_attribute a
  join pg_class c on a.attrelid = c.oid
  join pg_namespace n on c.relnamespace = n.oid
  join pg_type t on a.atttypid = t.oid
  where n.nspname = 'public'
    and c.relname = 'purchase_return_items'
    and a.attname = 'item_id'
    and a.attnum > 0
    and not a.attisdropped;
  select (t.typname = 'uuid')
  into v_inventory_movements_item_id_is_uuid
  from pg_attribute a
  join pg_class c on a.attrelid = c.oid
  join pg_namespace n on c.relnamespace = n.oid
  join pg_type t on a.atttypid = t.oid
  where n.nspname = 'public'
    and c.relname = 'inventory_movements'
    and a.attname = 'item_id'
    and a.attnum > 0
    and not a.attisdropped;
  select (t.typname = 'uuid')
  into v_inventory_movements_reference_id_is_uuid
  from pg_attribute a
  join pg_class c on a.attrelid = c.oid
  join pg_namespace n on c.relnamespace = n.oid
  join pg_type t on a.atttypid = t.oid
  where n.nspname = 'public'
    and c.relname = 'inventory_movements'
    and a.attname = 'reference_id'
    and a.attnum > 0
    and not a.attisdropped;
  select *
  into v_po
  from public.purchase_orders
  where id = p_order_id
  for update;
  if not found then
    raise exception 'purchase order not found';
  end if;
  if v_po.status = 'cancelled' then
    raise exception 'cannot return for cancelled purchase order';
  end if;
  if v_has_sm_warehouse then
    v_wh := coalesce(v_po.warehouse_id, public._resolve_default_warehouse_id());
    if v_wh is null then
      raise exception 'warehouse_id is required';
    end if;
  else
    v_wh := null;
  end if;
  insert into public.purchase_returns(purchase_order_id, returned_at, created_by, reason)
  values (p_order_id, coalesce(p_occurred_at, now()), auth.uid(), nullif(trim(coalesce(p_reason, '')), ''))
  returning id into v_return_id;
  for v_item in select value from jsonb_array_elements(p_items)
  loop
    v_item_id_text := coalesce(v_item->>'itemId', v_item->>'id');
    v_qty := coalesce(nullif(v_item->>'quantity', '')::numeric, 0);
    if v_item_id_text is null or v_item_id_text = '' then
      raise exception 'Invalid itemId';
    end if;
    if v_qty <= 0 then
      continue;
    end if;
    if coalesce(v_stock_item_id_is_uuid, false)
      or coalesce(v_return_items_item_id_is_uuid, false)
      or coalesce(v_inventory_movements_item_id_is_uuid, false)
    then
      begin
        v_item_id_uuid := v_item_id_text::uuid;
      exception when others then
        raise exception 'Invalid itemId %', v_item_id_text;
      end;
    end if;
    select coalesce(pi.received_quantity, 0), coalesce(pi.unit_cost, 0)
    into v_received_qty, v_po_unit_cost
    from public.purchase_items pi
    where pi.purchase_order_id = p_order_id
      and pi.item_id::text = v_item_id_text
    for update;
    if not found then
      raise exception 'item % not found in purchase order', v_item_id_text;
    end if;
    select coalesce(sum(pri.quantity), 0)
    into v_prev_returned
    from public.purchase_returns pr
    join public.purchase_return_items pri on pri.return_id = pr.id
    where pr.purchase_order_id = p_order_id
      and pri.item_id::text = v_item_id_text;
    if (coalesce(v_prev_returned, 0) + v_qty) > (coalesce(v_received_qty, 0) + 1e-9) then
      raise exception 'return exceeds received for item %', v_item_id_text;
    end if;
    if v_has_sm_warehouse then
      if coalesce(v_stock_item_id_is_uuid, false) then
        execute $q$
          insert into public.stock_management(item_id, warehouse_id, available_quantity, reserved_quantity, unit, low_stock_threshold, last_updated, data)
          select $1, $2, 0, 0, coalesce(mi.unit_type, 'piece'), 5, now(), '{}'::jsonb
          from public.menu_items mi
          where mi.id::text = $3
          on conflict (item_id, warehouse_id) do nothing
        $q$
        using v_item_id_uuid, v_wh, v_item_id_text;
      else
        execute $q$
          insert into public.stock_management(item_id, warehouse_id, available_quantity, reserved_quantity, unit, low_stock_threshold, last_updated, data)
          select $1, $2, 0, 0, coalesce(mi.unit_type, 'piece'), 5, now(), '{}'::jsonb
          from public.menu_items mi
          where mi.id::text = $3
          on conflict (item_id, warehouse_id) do nothing
        $q$
        using v_item_id_text, v_wh, v_item_id_text;
      end if;
      select
        coalesce(sm.available_quantity, 0),
        coalesce(sm.reserved_quantity, 0),
        coalesce(sm.avg_cost, 0)
      into v_stock_available, v_stock_reserved, v_stock_avg_cost
      from public.stock_management sm
      where sm.item_id::text = v_item_id_text
        and sm.warehouse_id = v_wh
      for update;
    else
      if coalesce(v_stock_item_id_is_uuid, false) then
        execute $q$
          insert into public.stock_management(item_id, available_quantity, reserved_quantity, unit, low_stock_threshold, last_updated, data)
          select $1, 0, 0, coalesce(mi.unit_type, 'piece'), 5, now(), '{}'::jsonb
          from public.menu_items mi
          where mi.id::text = $2
          on conflict (item_id) do nothing
        $q$
        using v_item_id_uuid, v_item_id_text;
      else
        execute $q$
          insert into public.stock_management(item_id, available_quantity, reserved_quantity, unit, low_stock_threshold, last_updated, data)
          select $1, 0, 0, coalesce(mi.unit_type, 'piece'), 5, now(), '{}'::jsonb
          from public.menu_items mi
          where mi.id::text = $2
          on conflict (item_id) do nothing
        $q$
        using v_item_id_text, v_item_id_text;
      end if;
      select
        coalesce(sm.available_quantity, 0),
        coalesce(sm.reserved_quantity, 0),
        coalesce(sm.avg_cost, 0)
      into v_stock_available, v_stock_reserved, v_stock_avg_cost
      from public.stock_management sm
      where sm.item_id::text = v_item_id_text
      for update;
    end if;
    if not found then
      raise exception 'Stock record not found for item %', v_item_id_text;
    end if;
    if (coalesce(v_stock_available, 0) - coalesce(v_stock_reserved, 0) + 1e-9) < v_qty then
      raise exception 'insufficient stock for return for item %', v_item_id_text;
    end if;
    if v_has_sm_warehouse then
      update public.stock_management
      set available_quantity = available_quantity - v_qty,
          last_updated = now(),
          updated_at = now()
      where item_id::text = v_item_id_text
        and warehouse_id = v_wh;
    else
      update public.stock_management
      set available_quantity = available_quantity - v_qty,
          last_updated = now(),
          updated_at = now()
      where item_id::text = v_item_id_text;
    end if;
    v_return_item_total := v_qty * coalesce(v_po_unit_cost, 0);
    v_return_total := v_return_total + v_return_item_total;
    if coalesce(v_return_items_item_id_is_uuid, false) then
      execute $q$
        insert into public.purchase_return_items(return_id, item_id, quantity, unit_cost, total_cost)
        values ($1, $2, $3, $4, $5)
      $q$
      using v_return_id, v_item_id_uuid, v_qty, v_po_unit_cost, v_return_item_total;
    else
      execute $q$
        insert into public.purchase_return_items(return_id, item_id, quantity, unit_cost, total_cost)
        values ($1, $2, $3, $4, $5)
      $q$
      using v_return_id, v_item_id_text, v_qty, v_po_unit_cost, v_return_item_total;
    end if;
    if coalesce(v_stock_avg_cost, 0) <= 0 then
      v_stock_avg_cost := coalesce(v_po_unit_cost, 0);
    end if;
    v_needed := v_qty;
    if v_has_bb and v_has_bb_warehouse and v_has_im_batch and v_has_im_warehouse then
      for v_batch in
        select bb.batch_id, coalesce(bb.quantity, 0) as qty, bb.expiry_date
        from public.batch_balances bb
        where bb.item_id::text = v_item_id_text
          and bb.warehouse_id = v_wh
          and coalesce(bb.quantity, 0) > 0
        order by (bb.expiry_date is null) asc, bb.expiry_date asc, bb.batch_id asc
        for update
      loop
        exit when v_needed <= 0;
        v_take := least(v_needed, coalesce(v_batch.qty, 0));
        if v_take <= 0 then
          continue;
        end if;
        update public.batch_balances
        set quantity = quantity - v_take,
            updated_at = now()
        where item_id::text = v_item_id_text
          and batch_id = v_batch.batch_id
          and warehouse_id = v_wh;
        if coalesce(v_inventory_movements_item_id_is_uuid, false) then
          if coalesce(v_inventory_movements_reference_id_is_uuid, false) then
            execute $q$
              insert into public.inventory_movements(
                item_id, movement_type, quantity, unit_cost, total_cost,
                reference_table, reference_id, occurred_at, created_by, data, batch_id, warehouse_id
              )
              values (
                $1, 'return_out', $2, $3, ($2 * $3),
                'purchase_returns', $4, coalesce($5, now()), auth.uid(),
                jsonb_build_object('purchaseOrderId', $6, 'purchaseReturnId', $4::text, 'warehouseId', $7::text, 'batchId', $8::text),
                $8, $7
              )
              returning id
            $q$
            into v_movement_id
            using v_item_id_uuid, v_take, v_stock_avg_cost, v_return_id, p_occurred_at, p_order_id, v_wh, v_batch.batch_id;
          else
            execute $q$
              insert into public.inventory_movements(
                item_id, movement_type, quantity, unit_cost, total_cost,
                reference_table, reference_id, occurred_at, created_by, data, batch_id, warehouse_id
              )
              values (
                $1, 'return_out', $2, $3, ($2 * $3),
                'purchase_returns', $4::text, coalesce($5, now()), auth.uid(),
                jsonb_build_object('purchaseOrderId', $6, 'purchaseReturnId', $4::text, 'warehouseId', $7::text, 'batchId', $8::text),
                $8, $7
              )
              returning id
            $q$
            into v_movement_id
            using v_item_id_uuid, v_take, v_stock_avg_cost, v_return_id, p_occurred_at, p_order_id, v_wh, v_batch.batch_id;
          end if;
        else
          if coalesce(v_inventory_movements_reference_id_is_uuid, false) then
            execute $q$
              insert into public.inventory_movements(
                item_id, movement_type, quantity, unit_cost, total_cost,
                reference_table, reference_id, occurred_at, created_by, data, batch_id, warehouse_id
              )
              values (
                $1, 'return_out', $2, $3, ($2 * $3),
                'purchase_returns', $4, coalesce($5, now()), auth.uid(),
                jsonb_build_object('purchaseOrderId', $6, 'purchaseReturnId', $4::text, 'warehouseId', $7::text, 'batchId', $8::text),
                $8, $7
              )
              returning id
            $q$
            into v_movement_id
            using v_item_id_text, v_take, v_stock_avg_cost, v_return_id, p_occurred_at, p_order_id, v_wh, v_batch.batch_id;
          else
            execute $q$
              insert into public.inventory_movements(
                item_id, movement_type, quantity, unit_cost, total_cost,
                reference_table, reference_id, occurred_at, created_by, data, batch_id, warehouse_id
              )
              values (
                $1, 'return_out', $2, $3, ($2 * $3),
                'purchase_returns', $4::text, coalesce($5, now()), auth.uid(),
                jsonb_build_object('purchaseOrderId', $6, 'purchaseReturnId', $4::text, 'warehouseId', $7::text, 'batchId', $8::text),
                $8, $7
              )
              returning id
            $q$
            into v_movement_id
            using v_item_id_text, v_take, v_stock_avg_cost, v_return_id, p_occurred_at, p_order_id, v_wh, v_batch.batch_id;
          end if;
        end if;
        perform public.post_inventory_movement(v_movement_id);
        v_needed := v_needed - v_take;
      end loop;
      if v_needed > 0.000000001 then
        raise exception 'insufficient batch stock for return for item %', v_item_id_text;
      end if;
    else
      if v_has_im_warehouse then
        if coalesce(v_inventory_movements_item_id_is_uuid, false) then
          if coalesce(v_inventory_movements_reference_id_is_uuid, false) then
            execute $q$
              insert into public.inventory_movements(
                item_id, movement_type, quantity, unit_cost, total_cost,
                reference_table, reference_id, occurred_at, created_by, data, warehouse_id
              )
              values (
                $1, 'return_out', $2, $3, ($2 * $3),
                'purchase_returns', $4, coalesce($5, now()), auth.uid(),
                jsonb_build_object('purchaseOrderId', $6, 'purchaseReturnId', $4::text, 'warehouseId', $7::text),
                $7
              )
              returning id
            $q$
            into v_movement_id
            using v_item_id_uuid, v_qty, v_stock_avg_cost, v_return_id, p_occurred_at, p_order_id, v_wh;
          else
            execute $q$
              insert into public.inventory_movements(
                item_id, movement_type, quantity, unit_cost, total_cost,
                reference_table, reference_id, occurred_at, created_by, data, warehouse_id
              )
              values (
                $1, 'return_out', $2, $3, ($2 * $3),
                'purchase_returns', $4::text, coalesce($5, now()), auth.uid(),
                jsonb_build_object('purchaseOrderId', $6, 'purchaseReturnId', $4::text, 'warehouseId', $7::text),
                $7
              )
              returning id
            $q$
            into v_movement_id
            using v_item_id_uuid, v_qty, v_stock_avg_cost, v_return_id, p_occurred_at, p_order_id, v_wh;
          end if;
        else
          if coalesce(v_inventory_movements_reference_id_is_uuid, false) then
            execute $q$
              insert into public.inventory_movements(
                item_id, movement_type, quantity, unit_cost, total_cost,
                reference_table, reference_id, occurred_at, created_by, data, warehouse_id
              )
              values (
                $1, 'return_out', $2, $3, ($2 * $3),
                'purchase_returns', $4, coalesce($5, now()), auth.uid(),
                jsonb_build_object('purchaseOrderId', $6, 'purchaseReturnId', $4::text, 'warehouseId', $7::text),
                $7
              )
              returning id
            $q$
            into v_movement_id
            using v_item_id_text, v_qty, v_stock_avg_cost, v_return_id, p_occurred_at, p_order_id, v_wh;
          else
            execute $q$
              insert into public.inventory_movements(
                item_id, movement_type, quantity, unit_cost, total_cost,
                reference_table, reference_id, occurred_at, created_by, data, warehouse_id
              )
              values (
                $1, 'return_out', $2, $3, ($2 * $3),
                'purchase_returns', $4::text, coalesce($5, now()), auth.uid(),
                jsonb_build_object('purchaseOrderId', $6, 'purchaseReturnId', $4::text, 'warehouseId', $7::text),
                $7
              )
              returning id
            $q$
            into v_movement_id
            using v_item_id_text, v_qty, v_stock_avg_cost, v_return_id, p_occurred_at, p_order_id, v_wh;
          end if;
        end if;
      else
        if coalesce(v_inventory_movements_item_id_is_uuid, false) then
          if coalesce(v_inventory_movements_reference_id_is_uuid, false) then
            execute $q$
              insert into public.inventory_movements(
                item_id, movement_type, quantity, unit_cost, total_cost,
                reference_table, reference_id, occurred_at, created_by, data
              )
              values (
                $1, 'return_out', $2, $3, ($2 * $3),
                'purchase_returns', $4, coalesce($5, now()), auth.uid(),
                jsonb_build_object('purchaseOrderId', $6, 'purchaseReturnId', $4::text)
              )
              returning id
            $q$
            into v_movement_id
            using v_item_id_uuid, v_qty, v_stock_avg_cost, v_return_id, p_occurred_at, p_order_id;
          else
            execute $q$
              insert into public.inventory_movements(
                item_id, movement_type, quantity, unit_cost, total_cost,
                reference_table, reference_id, occurred_at, created_by, data
              )
              values (
                $1, 'return_out', $2, $3, ($2 * $3),
                'purchase_returns', $4::text, coalesce($5, now()), auth.uid(),
                jsonb_build_object('purchaseOrderId', $6, 'purchaseReturnId', $4::text)
              )
              returning id
            $q$
            into v_movement_id
            using v_item_id_uuid, v_qty, v_stock_avg_cost, v_return_id, p_occurred_at, p_order_id;
          end if;
        else
          if coalesce(v_inventory_movements_reference_id_is_uuid, false) then
            execute $q$
              insert into public.inventory_movements(
                item_id, movement_type, quantity, unit_cost, total_cost,
                reference_table, reference_id, occurred_at, created_by, data
              )
              values (
                $1, 'return_out', $2, $3, ($2 * $3),
                'purchase_returns', $4, coalesce($5, now()), auth.uid(),
                jsonb_build_object('purchaseOrderId', $6, 'purchaseReturnId', $4::text)
              )
              returning id
            $q$
            into v_movement_id
            using v_item_id_text, v_qty, v_stock_avg_cost, v_return_id, p_occurred_at, p_order_id;
          else
            execute $q$
              insert into public.inventory_movements(
                item_id, movement_type, quantity, unit_cost, total_cost,
                reference_table, reference_id, occurred_at, created_by, data
              )
              values (
                $1, 'return_out', $2, $3, ($2 * $3),
                'purchase_returns', $4::text, coalesce($5, now()), auth.uid(),
                jsonb_build_object('purchaseOrderId', $6, 'purchaseReturnId', $4::text)
              )
              returning id
            $q$
            into v_movement_id
            using v_item_id_text, v_qty, v_stock_avg_cost, v_return_id, p_occurred_at, p_order_id;
          end if;
        end if;
      end if;
      perform public.post_inventory_movement(v_movement_id);
    end if;
  end loop;
  if coalesce(v_po.total_amount, 0) > 0 and v_return_total > 0 then
    v_new_total := greatest(0, coalesce(v_po.total_amount, 0) - v_return_total);
    update public.purchase_orders
    set total_amount = v_new_total,
        paid_amount = least(coalesce(purchase_orders.paid_amount, 0), v_new_total),
        updated_at = now()
    where id = p_order_id;
  end if;
  insert into public.system_audit_logs(action, module, details, performed_by, performed_at, metadata)
  values (
    'return',
    'purchases',
    concat('Created purchase return ', v_return_id::text, ' for PO ', p_order_id::text),
    auth.uid(),
    coalesce(p_occurred_at, now()),
    jsonb_build_object('purchaseOrderId', p_order_id::text, 'purchaseReturnId', v_return_id::text, 'reason', nullif(trim(coalesce(p_reason, '')), ''))
  );
  return v_return_id;
end;
$_$;


ALTER FUNCTION "public"."create_purchase_return"("p_order_id" "uuid", "p_items" "jsonb", "p_reason" "text", "p_occurred_at" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_reversal_entry"("p_entry_id" "uuid", "p_reason" "text") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_entry record;
  v_new_id uuid;
begin
  select * into v_entry from public.journal_entries where id = p_entry_id;
  if not found then
    raise exception 'journal entry not found';
  end if;

  insert into public.journal_entries(entry_date, memo, source_table, source_id, source_event, created_by, document_id, branch_id, company_id)
  values (
    now(),
    concat('Reversal: ', coalesce(v_entry.memo, ''), ' ', coalesce(p_reason, '')),
    'journal_entries',
    v_entry.id::text,
    'reversal',
    auth.uid(),
    v_entry.document_id,
    v_entry.branch_id,
    v_entry.company_id
  )
  returning id into v_new_id;

  insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
  select v_new_id, jl.account_id, jl.credit, jl.debit, 'Reversal'
  from public.journal_lines jl
  where jl.journal_entry_id = p_entry_id;

  return v_new_id;
end;
$$;


ALTER FUNCTION "public"."create_reversal_entry"("p_entry_id" "uuid", "p_reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."deactivate_promotion"("p_promotion_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if not public.is_admin() then
    raise exception 'not allowed';
  end if;
  if p_promotion_id is null then
    raise exception 'p_promotion_id is required';
  end if;
  update public.promotions
  set is_active = false,
      updated_at = now()
  where id = p_promotion_id;
  if not found then
    raise exception 'promotion_not_found';
  end if;
end;
$$;


ALTER FUNCTION "public"."deactivate_promotion"("p_promotion_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."decrypt_text"("p_encrypted" "bytea") RETURNS "text"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'extensions', 'public'
    AS $$
DECLARE
  v_key text;
BEGIN
  SELECT key_value INTO v_key FROM private.keys WHERE key_name = 'app.encryption_key';
  IF v_key IS NULL OR v_key = '' THEN
    RAISE EXCEPTION 'Encryption key not configured';
  END IF;

  IF p_encrypted IS NULL THEN 
    RETURN NULL;
  END IF;

  -- Try decrypting
  BEGIN
    RETURN extensions.pgp_sym_decrypt(p_encrypted, v_key);
  EXCEPTION WHEN OTHERS THEN
    RETURN NULL; -- Return null if decryption fails (wrong key)
  END;
END;
$$;


ALTER FUNCTION "public"."decrypt_text"("p_encrypted" "bytea") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."deduct_stock_on_delivery_v2"("p_order_id" "uuid", "p_items" "jsonb") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  raise exception 'warehouse_id is required';
end;
$$;


ALTER FUNCTION "public"."deduct_stock_on_delivery_v2"("p_order_id" "uuid", "p_items" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."deduct_stock_on_delivery_v2"("p_order_id" "uuid", "p_items" "jsonb", "p_warehouse_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_is_in_store boolean := false;
  v_item jsonb;
  v_item_id text;
  v_requested numeric;
  v_needed numeric;
  v_item_batch_text text;
  v_is_food boolean;
  v_avg_cost numeric;
  v_batch record;
  v_alloc numeric;
  v_unit_cost numeric;
  v_total_cost numeric;
  v_movement_id uuid;
  v_qr numeric;
  v_qc numeric;
begin
  perform public._require_staff('deduct_stock_on_delivery_v2');
  if p_order_id is null then
    raise exception 'p_order_id is required';
  end if;
  if p_warehouse_id is null then
    raise exception 'warehouse_id is required';
  end if;
  if p_items is null or jsonb_typeof(p_items) <> 'array' then
    raise exception 'p_items must be a json array';
  end if;

  if exists (
    select 1
    from public.inventory_movements im
    where im.reference_table = 'orders'
      and im.reference_id = p_order_id::text
      and im.warehouse_id = p_warehouse_id
      and im.movement_type = 'sale_out'
  ) then
    return;
  end if;

  select (coalesce(nullif(o.data->>'orderSource',''), '') = 'in_store')
  into v_is_in_store
  from public.orders o
  where o.id = p_order_id
  for update;
  if not found then
    raise exception 'order not found';
  end if;

  delete from public.order_item_cogs where order_id = p_order_id;

  for v_item in select value from jsonb_array_elements(coalesce(p_items, '[]'::jsonb))
  loop
    v_item_id := coalesce(nullif(v_item->>'itemId',''), nullif(v_item->>'id',''));
    v_requested := coalesce(nullif(v_item->>'quantity','')::numeric, nullif(v_item->>'qty','')::numeric, 0);
    v_item_batch_text := nullif(v_item->>'batchId', '');
    if v_item_id is null or v_item_id = '' or v_requested <= 0 then
      continue;
    end if;

    select (coalesce(mi.category,'') = 'food')
    into v_is_food
    from public.menu_items mi
    where mi.id::text = v_item_id::text;

    select coalesce(sm.avg_cost, 0)
    into v_avg_cost
    from public.stock_management sm
    where sm.item_id::text = v_item_id::text
      and sm.warehouse_id = p_warehouse_id;

    v_needed := v_requested;

    if not coalesce(v_is_in_store, false) then
      for v_batch in
        select
          r.id as reservation_id,
          r.quantity as reserved_qty,
          b.id as batch_id,
          b.expiry_date,
          b.unit_cost,
          greatest(
            coalesce(b.quantity_received,0)
            - coalesce(b.quantity_consumed,0)
            - coalesce(b.quantity_transferred,0),
            0
          ) as remaining_qty
        from public.order_item_reservations r
        join public.batches b on b.id = r.batch_id
        where r.order_id = p_order_id
          and r.item_id::text = v_item_id::text
          and r.warehouse_id = p_warehouse_id
          and (v_item_batch_text is null or r.batch_id <> v_item_batch_text::uuid)
          and coalesce(b.status,'active') = 'active'
          and coalesce(b.qc_status,'') = 'released'
          and not exists (
            select 1 from public.batch_recalls br
            where br.batch_id = b.id and br.status = 'active'
          )
          and (
            not coalesce(v_is_food, false)
            or (b.expiry_date is not null and b.expiry_date >= current_date)
          )
        order by b.expiry_date asc nulls last, r.created_at asc, r.batch_id asc
        for update
      loop
        exit when v_needed <= 0;
        v_alloc := least(v_needed, coalesce(v_batch.reserved_qty, 0));
        if v_alloc <= 0 then
          continue;
        end if;

        update public.batches
        set quantity_consumed = quantity_consumed + v_alloc
        where id = v_batch.batch_id
        returning quantity_received, quantity_consumed into v_qr, v_qc;
        if coalesce(v_qc,0) > coalesce(v_qr,0) then
          raise exception 'Over-consumption detected for batch %', v_batch.batch_id;
        end if;

        v_unit_cost := coalesce(v_batch.unit_cost, v_avg_cost, 0);
        v_total_cost := v_alloc * v_unit_cost;
        insert into public.order_item_cogs(order_id, item_id, quantity, unit_cost, total_cost, created_at)
        values (p_order_id, v_item_id::text, v_alloc, v_unit_cost, v_total_cost, now());

        insert into public.inventory_movements(
          item_id, movement_type, quantity, unit_cost, total_cost,
          reference_table, reference_id, occurred_at, created_by, data, batch_id, warehouse_id
        )
        values (
          v_item_id::text, 'sale_out', v_alloc, v_unit_cost, v_total_cost,
          'orders', p_order_id::text, now(), auth.uid(),
          jsonb_build_object('orderId', p_order_id, 'warehouseId', p_warehouse_id, 'batchId', v_batch.batch_id),
          v_batch.batch_id,
          p_warehouse_id
        )
        returning id into v_movement_id;

        perform public.post_inventory_movement(v_movement_id);

        update public.order_item_reservations
        set quantity = quantity - v_alloc,
            updated_at = now()
        where id = v_batch.reservation_id;

        delete from public.order_item_reservations
        where id = v_batch.reservation_id
          and quantity <= 0;

        v_needed := v_needed - v_alloc;
      end loop;

      if v_needed > 0 then
        raise exception 'INSUFFICIENT_RESERVED_BATCH_STOCK_FOR_ITEM_%', v_item_id;
      end if;
    else
      if v_item_batch_text is not null then
        select
          b.id as batch_id,
          b.expiry_date,
          b.unit_cost,
          greatest(
            coalesce(b.quantity_received,0)
            - coalesce(b.quantity_consumed,0)
            - coalesce(b.quantity_transferred,0),
            0
          ) as remaining_qty
        into v_batch
        from public.batches b
        where b.id = v_item_batch_text::uuid
          and b.item_id::text = v_item_id::text
          and b.warehouse_id = p_warehouse_id
          and coalesce(b.status,'active') = 'active'
          and coalesce(b.qc_status,'') = 'released'
          and not exists (
            select 1 from public.batch_recalls br
            where br.batch_id = b.id and br.status = 'active'
          )
        for update;
        if not found then
          raise exception 'Batch % not found for item % in warehouse %', v_item_batch_text, v_item_id, p_warehouse_id;
        end if;
        if coalesce(v_is_food, false) and (v_batch.expiry_date is null or v_batch.expiry_date < current_date) then
          raise exception 'NO_VALID_BATCH_AVAILABLE';
        end if;
        v_alloc := least(v_needed, coalesce(v_batch.remaining_qty, 0));
        if v_alloc > 0 then
          update public.batches
          set quantity_consumed = quantity_consumed + v_alloc
          where id = v_batch.batch_id
          returning quantity_received, quantity_consumed into v_qr, v_qc;
          if coalesce(v_qc,0) > coalesce(v_qr,0) then
            raise exception 'Over-consumption detected for batch %', v_batch.batch_id;
          end if;

          v_unit_cost := coalesce(v_batch.unit_cost, v_avg_cost, 0);
          v_total_cost := v_alloc * v_unit_cost;
          insert into public.order_item_cogs(order_id, item_id, quantity, unit_cost, total_cost, created_at)
          values (p_order_id, v_item_id::text, v_alloc, v_unit_cost, v_total_cost, now());

          insert into public.inventory_movements(
            item_id, movement_type, quantity, unit_cost, total_cost,
            reference_table, reference_id, occurred_at, created_by, data, batch_id, warehouse_id
          )
          values (
            v_item_id::text, 'sale_out', v_alloc, v_unit_cost, v_total_cost,
            'orders', p_order_id::text, now(), auth.uid(),
            jsonb_build_object('orderId', p_order_id, 'warehouseId', p_warehouse_id, 'batchId', v_batch.batch_id),
            v_batch.batch_id,
            p_warehouse_id
          )
          returning id into v_movement_id;

          perform public.post_inventory_movement(v_movement_id);

          v_needed := v_needed - v_alloc;
        end if;
      end if;

      for v_batch in
        select
          b.id as batch_id,
          b.expiry_date,
          b.unit_cost,
          greatest(
            coalesce(b.quantity_received,0)
            - coalesce(b.quantity_consumed,0)
            - coalesce(b.quantity_transferred,0),
            0
          ) as remaining_qty
        from public.batches b
        where b.item_id::text = v_item_id::text
          and b.warehouse_id = p_warehouse_id
          and coalesce(b.status,'active') = 'active'
          and coalesce(b.qc_status,'') = 'released'
          and not exists (
            select 1 from public.batch_recalls br
            where br.batch_id = b.id and br.status = 'active'
          )
          and greatest(
            coalesce(b.quantity_received,0)
            - coalesce(b.quantity_consumed,0)
            - coalesce(b.quantity_transferred,0),
            0
          ) > 0
          and (v_item_batch_text is null or b.id <> v_item_batch_text::uuid)
          and (
            not coalesce(v_is_food, false)
            or (b.expiry_date is not null and b.expiry_date >= current_date)
          )
        order by b.expiry_date asc nulls last, b.created_at asc, b.id asc
        for update
      loop
        exit when v_needed <= 0;
        v_alloc := least(v_needed, coalesce(v_batch.remaining_qty, 0));
        if v_alloc <= 0 then
          continue;
        end if;

        update public.batches
        set quantity_consumed = quantity_consumed + v_alloc
        where id = v_batch.batch_id
        returning quantity_received, quantity_consumed into v_qr, v_qc;
        if coalesce(v_qc,0) > coalesce(v_qr,0) then
          raise exception 'Over-consumption detected for batch %', v_batch.batch_id;
        end if;

        v_unit_cost := coalesce(v_batch.unit_cost, v_avg_cost, 0);
        v_total_cost := v_alloc * v_unit_cost;
        insert into public.order_item_cogs(order_id, item_id, quantity, unit_cost, total_cost, created_at)
        values (p_order_id, v_item_id::text, v_alloc, v_unit_cost, v_total_cost, now());

        insert into public.inventory_movements(
          item_id, movement_type, quantity, unit_cost, total_cost,
          reference_table, reference_id, occurred_at, created_by, data, batch_id, warehouse_id
        )
        values (
          v_item_id::text, 'sale_out', v_alloc, v_unit_cost, v_total_cost,
          'orders', p_order_id::text, now(), auth.uid(),
          jsonb_build_object('orderId', p_order_id, 'warehouseId', p_warehouse_id, 'batchId', v_batch.batch_id),
          v_batch.batch_id,
          p_warehouse_id
        )
        returning id into v_movement_id;

        perform public.post_inventory_movement(v_movement_id);

        v_needed := v_needed - v_alloc;
      end loop;

      if v_needed > 0 then
        raise exception 'INSUFFICIENT_BATCH_STOCK_FOR_ITEM_%', v_item_id;
      end if;
    end if;

    update public.stock_management sm
    set reserved_quantity = coalesce((
          select sum(r.quantity)
          from public.order_item_reservations r
          where r.item_id = v_item_id::text
            and r.warehouse_id = p_warehouse_id
        ), 0),
        available_quantity = coalesce((
          select sum(
            greatest(coalesce(b.quantity_received,0) - coalesce(b.quantity_consumed,0) - coalesce(b.quantity_transferred,0), 0)
          )
          from public.batches b
          where b.item_id::text = v_item_id::text
            and b.warehouse_id = p_warehouse_id
            and coalesce(b.status,'active') = 'active'
            and coalesce(b.qc_status,'') = 'released'
            and not exists (
              select 1 from public.batch_recalls br
              where br.batch_id = b.id and br.status = 'active'
            )
            and (
              not coalesce(v_is_food, false)
              or (b.expiry_date is not null and b.expiry_date >= current_date)
            )
        ), 0),
        last_updated = now(),
        updated_at = now()
    where sm.item_id::text = v_item_id::text
      and sm.warehouse_id = p_warehouse_id;
  end loop;
end;
$$;


ALTER FUNCTION "public"."deduct_stock_on_delivery_v2"("p_order_id" "uuid", "p_items" "jsonb", "p_warehouse_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."delete_user_account"("target_user_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  -- 1. Verify the caller is an admin
  if not public.is_admin() then
    raise exception 'Access denied: Only admins can delete users.';
  end if;

  -- 2. Delete from auth.users
  -- This will cascade to public.customers (ON DELETE CASCADE)
  -- This will set public.orders.customer_auth_user_id to NULL (ON DELETE SET NULL)
  delete from auth.users where id = target_user_id;

  -- Note: If the user doesn't exist in auth.users (e.g. only in public.customers due to sync error),
  -- we should also ensure public.customers is cleaned up.
  -- But cascade handles the common case.
  delete from public.customers where auth_user_id = target_user_id;
end;
$$;


ALTER FUNCTION "public"."delete_user_account"("target_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."dispatch_inventory_transfer"("p_transfer_id" "uuid", "p_idempotency_key" "text" DEFAULT NULL::"text", "p_cancel" boolean DEFAULT false) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_actor uuid;
  v_transfer record;
  v_item record;
  v_sm record;
  v_reserved_batches jsonb;
  v_reserved_list jsonb;
  v_reserved_sum numeric;
  v_remaining numeric;
  v_expiry_date date;
  v_movement_id uuid;
begin
  v_actor := auth.uid();
  if not public.is_admin() then
    raise exception 'not allowed';
  end if;
  if p_transfer_id is null then
    raise exception 'p_transfer_id is required';
  end if;

  perform pg_advisory_xact_lock(hashtext(p_transfer_id::text));

  select *
  into v_transfer
  from public.inventory_transfers it
  where it.id = p_transfer_id
  for update;

  if not found then
    raise exception 'transfer not found';
  end if;

  if p_idempotency_key is not null and btrim(p_idempotency_key) <> '' then
    if v_transfer.dispatch_idempotency_key is not null and v_transfer.dispatch_idempotency_key = p_idempotency_key then
      return jsonb_build_object('status', v_transfer.state, 'transferId', p_transfer_id::text);
    end if;
  end if;

  if v_transfer.state = 'CANCELLED' then
    return jsonb_build_object('status', 'CANCELLED', 'transferId', p_transfer_id::text);
  end if;

  if p_cancel then
    if v_transfer.state <> 'CREATED' then
      raise exception 'cannot cancel transfer in state %', v_transfer.state;
    end if;
    update public.inventory_transfers
    set state = 'CANCELLED',
        updated_at = now(),
        dispatch_idempotency_key = nullif(btrim(p_idempotency_key), '')
    where id = p_transfer_id;
    return jsonb_build_object('status', 'CANCELLED', 'transferId', p_transfer_id::text);
  end if;

  if v_transfer.state <> 'CREATED' then
    return jsonb_build_object('status', v_transfer.state, 'transferId', p_transfer_id::text);
  end if;

  for v_item in
    select *
    from public.inventory_transfer_items iti
    where iti.transfer_id = p_transfer_id
    order by iti.created_at asc, iti.id asc
    for update
  loop
    if exists (
      select 1
      from public.inventory_movements im
      where im.reference_table = 'inventory_transfers'
        and im.reference_id = p_transfer_id::text
        and im.movement_type = 'transfer_out'
        and im.item_id = v_item.item_id
        and im.batch_id = v_item.source_batch_id
        and im.warehouse_id is not distinct from v_transfer.from_warehouse_id
    ) then
      update public.inventory_transfer_items
      set dispatched_qty = quantity,
          updated_at = now()
      where id = v_item.id;
      continue;
    end if;

    select *
    into v_sm
    from public.stock_management sm
    where sm.item_id::text = v_item.item_id
      and sm.warehouse_id = v_transfer.from_warehouse_id
    for update;

    if not found then
      raise exception 'Stock record not found for item % in source warehouse', v_item.item_id;
    end if;

    if (coalesce(v_sm.available_quantity,0) - coalesce(v_sm.reserved_quantity,0)) + 1e-9 < v_item.quantity then
      raise exception 'Insufficient non-reserved stock for item % in source warehouse', v_item.item_id;
    end if;

    select
      greatest(
        coalesce(b.quantity_received,0)
        - coalesce(b.quantity_consumed,0)
        - coalesce(b.quantity_transferred,0),
        0
      ),
      b.expiry_date
    into v_remaining, v_expiry_date
    from public.batches b
    where b.id = v_item.source_batch_id
      and b.warehouse_id = v_transfer.from_warehouse_id
    for update;

    if not found then
      raise exception 'Batch not found for transfer item';
    end if;

    if v_expiry_date is not null and v_expiry_date < current_date then
      raise exception 'BATCH_EXPIRED';
    end if;

    v_reserved_batches := coalesce(v_sm.data->'reservedBatches', '{}'::jsonb);
    v_reserved_list := v_reserved_batches->(v_item.source_batch_id::text);
    if v_reserved_list is not null then
      v_reserved_list :=
        case
          when jsonb_typeof(v_reserved_list) = 'array' then v_reserved_list
          when jsonb_typeof(v_reserved_list) = 'object' then jsonb_build_array(v_reserved_list)
          else '[]'::jsonb
        end;
      select coalesce(sum(coalesce(nullif(x->>'qty','')::numeric, 0)), 0)
      into v_reserved_sum
      from jsonb_array_elements(v_reserved_list) as x;
      if coalesce(v_reserved_sum,0) > 0 then
        raise exception 'Cannot transfer reserved batch stock';
      end if;
    end if;

    if coalesce(v_remaining,0) + 1e-9 < v_item.quantity then
      raise exception 'Insufficient batch remaining for transfer';
    end if;

    update public.batches
    set quantity_transferred = quantity_transferred + v_item.quantity
    where id = v_item.source_batch_id;

    update public.stock_management
    set available_quantity = greatest(0, available_quantity - v_item.quantity),
        last_updated = now(),
        updated_at = now()
    where item_id::text = v_item.item_id
      and warehouse_id = v_transfer.from_warehouse_id;

    insert into public.inventory_movements(
      item_id, movement_type, quantity, unit_cost, total_cost,
      reference_table, reference_id, occurred_at, created_by, data, batch_id, warehouse_id
    )
    values (
      v_item.item_id,
      'transfer_out',
      v_item.quantity,
      v_item.unit_cost,
      0,
      'inventory_transfers',
      p_transfer_id::text,
      now(),
      v_actor,
      jsonb_build_object(
        'transferId', p_transfer_id,
        'direction', 'out',
        'fromWarehouseId', v_transfer.from_warehouse_id,
        'toWarehouseId', v_transfer.to_warehouse_id,
        'sourceBatchId', v_item.source_batch_id
      ),
      v_item.source_batch_id,
      v_transfer.from_warehouse_id
    )
    returning id into v_movement_id;

    perform public.post_inventory_movement(v_movement_id);

    update public.inventory_transfer_items
    set dispatched_qty = quantity,
        updated_at = now()
    where id = v_item.id;
  end loop;

  update public.inventory_transfers
  set state = 'IN_TRANSIT',
      dispatched_by = v_actor,
      dispatched_at = now(),
      updated_at = now(),
      dispatch_idempotency_key = nullif(btrim(p_idempotency_key), '')
  where id = p_transfer_id;

  return jsonb_build_object('status', 'IN_TRANSIT', 'transferId', p_transfer_id::text);
end;
$$;


ALTER FUNCTION "public"."dispatch_inventory_transfer"("p_transfer_id" "uuid", "p_idempotency_key" "text", "p_cancel" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."encrypt_text"("p_text" "text") RETURNS "bytea"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'extensions', 'public'
    AS $$
DECLARE
  v_key text;
BEGIN
  SELECT key_value INTO v_key FROM private.keys WHERE key_name = 'app.encryption_key';
  IF v_key IS NULL OR v_key = '' THEN
    RAISE EXCEPTION 'Encryption key not configured';
  END IF;
  IF p_text IS NULL OR p_text = '' THEN 
    RETURN NULL;
  END IF;
  RETURN extensions.pgp_sym_encrypt(p_text, v_key);
END;
$$;


ALTER FUNCTION "public"."encrypt_text"("p_text" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."enforce_purchase_items_editability"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
declare
  v_order_id uuid;
  v_status text;
  v_has_receipts boolean;
begin
  v_order_id := coalesce(new.purchase_order_id, old.purchase_order_id);

  select po.status
  into v_status
  from public.purchase_orders po
  where po.id = v_order_id;

  if not found then
    raise exception 'purchase order not found';
  end if;

  select exists(select 1 from public.purchase_receipts pr where pr.purchase_order_id = v_order_id)
  into v_has_receipts;

  if tg_op = 'INSERT' then
    if v_status <> 'draft' or coalesce(v_has_receipts, false) then
      raise exception 'cannot add purchase items after receiving';
    end if;
    return new;
  end if;

  if tg_op = 'DELETE' then
    if v_status <> 'draft' or coalesce(v_has_receipts, false) or coalesce(old.received_quantity, 0) > 0 then
      raise exception 'cannot delete purchase items after receiving';
    end if;
    return old;
  end if;

  if (new.quantity is distinct from old.quantity)
    or (new.unit_cost is distinct from old.unit_cost)
    or (new.item_id is distinct from old.item_id)
    or (new.purchase_order_id is distinct from old.purchase_order_id)
  then
    if v_status <> 'draft' or coalesce(v_has_receipts, false) or coalesce(old.received_quantity, 0) > 0 then
      raise exception 'cannot modify purchase items after receiving';
    end if;
  end if;

  return new;
end;
$$;


ALTER FUNCTION "public"."enforce_purchase_items_editability"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."enforce_purchase_orders_status_transition"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
declare
  v_has_receipts boolean;
  v_has_payments boolean;
  v_has_movements boolean;
begin
  if new.status is not distinct from old.status then
    return new;
  end if;

  if old.status = 'cancelled' then
    raise exception 'cannot change status from cancelled';
  end if;

  if new.status = 'draft' then
    raise exception 'cannot revert to draft';
  end if;

  if old.status = 'completed' and new.status is distinct from 'completed' then
    raise exception 'cannot change status from completed';
  end if;

  if not (
    (old.status = 'draft' and new.status in ('partial', 'completed', 'cancelled'))
    or (old.status = 'partial' and new.status = 'completed')
  ) then
    raise exception 'invalid status transition';
  end if;

  if new.status = 'cancelled' then
    select exists(select 1 from public.purchase_receipts pr where pr.purchase_order_id = new.id) into v_has_receipts;
    select exists(
      select 1
      from public.payments p
      where p.reference_table = 'purchase_orders'
        and p.reference_id::text = new.id::text
    ) into v_has_payments;
    select exists(
      select 1
      from public.inventory_movements im
      where (im.reference_table = 'purchase_orders' and im.reference_id::text = new.id::text)
         or (im.data ? 'purchaseOrderId' and im.data->>'purchaseOrderId' = new.id::text)
    ) into v_has_movements;

    if coalesce(v_has_receipts, false)
      or coalesce(v_has_payments, false)
      or coalesce(v_has_movements, false)
      or coalesce(old.paid_amount, 0) > 0
    then
      raise exception 'cannot cancel posted purchase order';
    end if;
  end if;

  return new;
end;
$$;


ALTER FUNCTION "public"."enforce_purchase_orders_status_transition"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."flag_payment_allocation_status"("p_payment_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_pay record;
  v_order record;
  v_delivered_at timestamptz;
  v_is_cod boolean := false;
  v_eligible boolean := false;
begin
  if p_payment_id is null then
    raise exception 'p_payment_id is required';
  end if;
  select *
  into v_pay
  from public.payments p
  where p.id = p_payment_id;
  if not found then
    raise exception 'payment not found';
  end if;
  if v_pay.direction <> 'in' or v_pay.reference_table <> 'orders' then
    return;
  end if;
  select *
  into v_order
  from public.orders o
  where o.id = (v_pay.reference_id)::uuid;
  if not found then
    return;
  end if;
  begin
    select public.order_delivered_at((v_pay.reference_id)::uuid) into v_delivered_at;
  exception when others then
    v_delivered_at := null;
  end;
  v_is_cod := public._is_cod_delivery_order(coalesce(v_order.data,'{}'::jsonb), v_order.delivery_zone_id);
  v_eligible := (v_delivered_at is not null) and (v_pay.occurred_at >= v_delivered_at) and (not v_is_cod);
  insert into public.ar_payment_status(payment_id, order_id, eligible, allocated, created_at, updated_at)
  values (p_payment_id, (v_pay.reference_id)::uuid, v_eligible, false, now(), now())
  on conflict (payment_id) do update
    set eligible = excluded.eligible,
        updated_at = now();
end;
$$;


ALTER FUNCTION "public"."flag_payment_allocation_status"("p_payment_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."general_ledger"("p_account_code" "text", "p_start" "date", "p_end" "date", "p_cost_center_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("entry_date" "date", "journal_entry_id" "uuid", "memo" "text", "source_table" "text", "source_id" "text", "source_event" "text", "debit" numeric, "credit" numeric, "amount" numeric, "running_balance" numeric)
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if not public.can_view_accounting_reports() then
    raise exception 'not allowed';
  end if;

  return query
  with acct as (
    select coa.id, coa.normal_balance
    from public.chart_of_accounts coa
    where coa.code = p_account_code
    limit 1
  ),
  opening as (
    select coalesce(sum(
      case
        when a.normal_balance = 'credit' then (jl.credit - jl.debit)
        else (jl.debit - jl.credit)
      end
    ), 0) as opening_balance
    from public.journal_lines jl
    join public.journal_entries je on je.id = jl.journal_entry_id
    join acct a on a.id = jl.account_id
    where p_start is not null
      and je.entry_date::date < p_start
      and (p_cost_center_id is null or jl.cost_center_id = p_cost_center_id)
  ),
  lines as (
    select
      je.entry_date::date as entry_date,
      je.id as journal_entry_id,
      je.memo,
      je.source_table,
      je.source_id,
      je.source_event,
      jl.debit,
      jl.credit,
      case
        when a.normal_balance = 'credit' then (jl.credit - jl.debit)
        else (jl.debit - jl.credit)
      end as amount,
      je.created_at as entry_created_at,
      jl.created_at as line_created_at
    from public.journal_lines jl
    join public.journal_entries je on je.id = jl.journal_entry_id
    join acct a on a.id = jl.account_id
    where (p_start is null or je.entry_date::date >= p_start)
      and (p_end is null or je.entry_date::date <= p_end)
      and (p_cost_center_id is null or jl.cost_center_id = p_cost_center_id)
  )
  select
    l.entry_date,
    l.journal_entry_id,
    l.memo,
    l.source_table,
    l.source_id,
    l.source_event,
    l.debit,
    l.credit,
    l.amount,
    (select opening_balance from opening)
      + sum(l.amount) over (order by l.entry_date, l.entry_created_at, l.line_created_at, l.journal_entry_id) as running_balance
  from lines l
  order by l.entry_date, l.entry_created_at, l.line_created_at, l.journal_entry_id;
end;
$$;


ALTER FUNCTION "public"."general_ledger"("p_account_code" "text", "p_start" "date", "p_end" "date", "p_cost_center_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_accounting_period_snapshot"("p_period_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_period record;
  v_as_of timestamptz;
begin
  if p_period_id is null then
    raise exception 'p_period_id is required';
  end if;

  if not public._is_migration_actor() and not public.has_admin_permission('accounting.periods.close') then
    raise exception 'not allowed';
  end if;

  select *
  into v_period
  from public.accounting_periods ap
  where ap.id = p_period_id
  for update;

  if not found then
    raise exception 'period not found';
  end if;

  if v_period.status <> 'closed' then
    raise exception 'period must be closed before snapshot';
  end if;

  v_as_of := ((v_period.end_date + 1)::timestamptz);

  insert into public.accounting_period_snapshots(period_id, account_id, closing_balance, created_by)
  select
    v_period.id,
    coa.id,
    coalesce(sum(
      case
        when coa.normal_balance = 'debit' then jl.debit - jl.credit
        else jl.credit - jl.debit
      end
    ), 0) as closing_balance,
    auth.uid()
  from public.chart_of_accounts coa
  left join public.journal_lines jl on jl.account_id = coa.id
  left join public.journal_entries je
    on je.id = jl.journal_entry_id
   and je.entry_date < v_as_of
  where coa.is_active = true
  group by coa.id
  on conflict (period_id, account_id) do nothing;
end;
$$;


ALTER FUNCTION "public"."generate_accounting_period_snapshot"("p_period_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."generate_accounting_period_snapshot"("p_period_id" "uuid") IS 'Purpose: create snapshot rows for a closed accounting period. Source of truth: journal_entries/journal_lines up to (end_date + 1 day). Expected output: one row per active account in accounting_period_snapshots.';



CREATE OR REPLACE FUNCTION "public"."generate_invoice_number"() RETURNS "text"
    LANGUAGE "plpgsql"
    AS $$
  BEGIN
    RETURN 'INV-' || lpad(nextval('public.invoice_seq')::text, 6, '0');
  END;
  $$;


ALTER FUNCTION "public"."generate_invoice_number"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_transfer_number"() RETURNS "text"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_date TEXT;
  v_seq INT;
  v_number TEXT;
BEGIN
  v_date := TO_CHAR(CURRENT_DATE, 'YYYYMMDD');
  
  SELECT COALESCE(MAX(
    CASE 
      WHEN transfer_number LIKE 'TRF-' || v_date || '-%' 
      THEN SUBSTRING(transfer_number FROM LENGTH('TRF-' || v_date || '-') + 1)::INT
      ELSE 0
    END
  ), 0) + 1
  INTO v_seq
  FROM public.warehouse_transfers;
  
  v_number := 'TRF-' || v_date || '-' || LPAD(v_seq::TEXT, 4, '0');
  
  RETURN v_number;
END;
$$;


ALTER FUNCTION "public"."generate_transfer_number"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_account_id_by_code"("p_code" "text") RETURNS "uuid"
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select coa.id
  from public.chart_of_accounts coa
  where coa.code = p_code and coa.is_active = true
  limit 1
$$;


ALTER FUNCTION "public"."get_account_id_by_code"("p_code" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_active_promotions"("p_customer_id" "uuid" DEFAULT NULL::"uuid", "p_warehouse_id" "uuid" DEFAULT NULL::"uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_actor uuid;
  v_customer_id uuid;
  v_now timestamptz := now();
  v_result jsonb := '[]'::jsonb;
  v_promo record;
begin
  v_actor := auth.uid();
  if v_actor is null then
    raise exception 'not authenticated';
  end if;

  v_customer_id := coalesce(p_customer_id, v_actor);

  for v_promo in
    select p.*
    from public.promotions p
    where p.is_active = true
      and p.approval_status = 'approved'
      and v_now >= p.start_at
      and v_now <= p.end_at
    order by p.end_at asc, p.created_at desc
  loop
    v_result := v_result || public._compute_promotion_price_only(v_promo.id, v_customer_id, 1);
  end loop;

  return v_result;
end;
$$;


ALTER FUNCTION "public"."get_active_promotions"("p_customer_id" "uuid", "p_warehouse_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_admin_session_scope"() RETURNS TABLE("company_id" "uuid", "branch_id" "uuid", "warehouse_id" "uuid")
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select
    coalesce(au.company_id, public.get_default_company_id()) as company_id,
    coalesce(au.branch_id, public.get_default_branch_id()) as branch_id,
    coalesce(au.warehouse_id, public._resolve_default_admin_warehouse_id()) as warehouse_id
  from public.admin_users au
  where au.auth_user_id = auth.uid()
    and au.is_active = true
  limit 1;
$$;


ALTER FUNCTION "public"."get_admin_session_scope"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_base_currency"() RETURNS "text"
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_settings jsonb;
  v_settings_base text;
  v_currency_base text;
  v_base_count int;
begin
  if to_regclass('public.app_settings') is null or to_regclass('public.currencies') is null then
    raise exception 'base currency configuration tables missing';
  end if;

  select s.data into v_settings
  from public.app_settings s
  where s.id = 'app'
  limit 1;

  if v_settings is null then
    select s.data into v_settings
    from public.app_settings s
    where s.id = 'singleton'
    limit 1;
  end if;

  v_settings_base := upper(nullif(btrim(coalesce(v_settings->'settings'->>'baseCurrency', '')), ''));
  if v_settings_base is null then
    raise exception 'base currency not configured in app_settings';
  end if;

  select count(*) into v_base_count from public.currencies c where c.is_base = true;
  if v_base_count <> 1 then
    raise exception 'invalid base currency state in currencies (count=%)', v_base_count;
  end if;
  select upper(c.code) into v_currency_base from public.currencies c where c.is_base = true limit 1;
  if v_currency_base is null then
    raise exception 'base currency not configured in currencies';
  end if;

  if v_settings_base <> v_currency_base then
    raise exception 'base currency mismatch (app_settings=% , currencies=%)', v_settings_base, v_currency_base;
  end if;

  return v_settings_base;
end;
$$;


ALTER FUNCTION "public"."get_base_currency"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_batch_recall_orders"("p_batch_id" "uuid", "p_warehouse_id" "uuid" DEFAULT NULL::"uuid", "p_branch_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("order_id" "uuid", "sold_at" timestamp with time zone, "warehouse_id" "uuid", "branch_id" "uuid", "item_id" "text", "item_name" "jsonb", "batch_id" "uuid", "expiry_date" "date", "supplier_id" "uuid", "supplier_name" "text", "quantity" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  perform public._require_staff('get_batch_recall_orders');
  if p_batch_id is null then
    raise exception 'p_batch_id is required';
  end if;

  return query
  select
    (im.reference_id)::uuid as order_id,
    im.occurred_at as sold_at,
    im.warehouse_id,
    im.branch_id,
    im.item_id::text as item_id,
    coalesce(mi.data->'name', '{}'::jsonb) as item_name,
    im.batch_id,
    b.expiry_date,
    po.supplier_id,
    s.name as supplier_name,
    im.quantity
  from public.inventory_movements im
  join public.menu_items mi on mi.id::text = im.item_id::text
  join public.batches b on b.id = im.batch_id
  left join public.purchase_receipts pr on pr.id = b.receipt_id
  left join public.purchase_orders po on po.id = pr.purchase_order_id
  left join public.suppliers s on s.id = po.supplier_id
  where im.movement_type = 'sale_out'
    and im.reference_table = 'orders'
    and im.batch_id = p_batch_id
    and (p_warehouse_id is null or im.warehouse_id = p_warehouse_id)
    and (p_branch_id is null or im.branch_id = p_branch_id)
  order by im.occurred_at desc;
end;
$$;


ALTER FUNCTION "public"."get_batch_recall_orders"("p_batch_id" "uuid", "p_warehouse_id" "uuid", "p_branch_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_catalog_with_stock"("p_category" "text" DEFAULT NULL::"text", "p_search" "text" DEFAULT NULL::"text") RETURNS TABLE("item_id" "text", "name" "jsonb", "unit_type" "text", "status" "text", "price" numeric, "is_out_of_stock" boolean, "is_low_stock" boolean, "data" "jsonb")
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  SELECT
    mi.id AS item_id,
    mi.data->'name' AS name,
    mi.unit_type,
    mi.status,
    COALESCE((mi.data->>'price')::numeric, 0) AS price,
    (COALESCE(sm.available_quantity, 0) <= 0) AS is_out_of_stock,
    (COALESCE(sm.available_quantity, 0) <= COALESCE(sm.low_stock_threshold, 5)) AS is_low_stock,
    mi.data AS data
  FROM public.menu_items mi
  LEFT JOIN public.stock_management sm ON sm.item_id::text = mi.id
  WHERE (p_category IS NULL OR mi.category = p_category)
    AND (
      p_search IS NULL OR
      lower(mi.data->'name'->>'ar') LIKE '%' || lower(p_search) || '%' OR
      lower(mi.data->'name'->>'en') LIKE '%' || lower(p_search) || '%'
    )
    AND mi.status = 'active';
$$;


ALTER FUNCTION "public"."get_catalog_with_stock"("p_category" "text", "p_search" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_cod_audit"("p_order_id" "uuid") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_order record;
  v_payments jsonb;
  v_delivery_entry jsonb;
  v_settlements jsonb;
BEGIN
  IF NOT public.has_admin_permission('accounting.view') THEN
    RAISE EXCEPTION 'not allowed';
  END IF;
  SELECT o.*
  INTO v_order
  FROM public.orders o
  WHERE o.id = p_order_id;
  IF NOT FOUND THEN
    RAISE EXCEPTION 'order not found';
  END IF;

  SELECT coalesce(jsonb_agg(to_jsonb(p) ORDER BY p.occurred_at), '[]'::jsonb)
  INTO v_payments
  FROM public.payments p
  WHERE p.reference_table = 'orders'
    AND p.reference_id = p_order_id::text
    AND p.direction = 'in';

  SELECT to_jsonb(le)
  INTO v_delivery_entry
  FROM public.ledger_entries le
  WHERE le.entry_type = 'delivery'
    AND le.reference_type = 'order'
    AND le.reference_id = p_order_id::text
  LIMIT 1;

  SELECT coalesce(jsonb_agg(
    jsonb_build_object(
      'settlement', to_jsonb(cs),
      'ledgerEntry', to_jsonb(le),
      'orders', (select coalesce(jsonb_agg(to_jsonb(cso)), '[]'::jsonb) from public.cod_settlement_orders cso where cso.settlement_id = cs.id)
    )
    ORDER BY cs.occurred_at
  ), '[]'::jsonb)
  INTO v_settlements
  FROM public.cod_settlements cs
  LEFT JOIN public.ledger_entries le
    ON le.entry_type = 'settlement' AND le.reference_type = 'settlement' AND le.reference_id = cs.id::text
  WHERE EXISTS (
    SELECT 1 FROM public.cod_settlement_orders cso
    WHERE cso.settlement_id = cs.id AND cso.order_id = p_order_id
  );

  RETURN json_build_object(
    'order', jsonb_build_object('id', v_order.id, 'status', v_order.status, 'data', v_order.data, 'delivery_zone_id', v_order.delivery_zone_id),
    'payments_in', v_payments,
    'delivery_ledger_entry', v_delivery_entry,
    'settlements', v_settlements,
    'cit_balance', (SELECT cash_in_transit_balance FROM public.v_cash_in_transit_balance),
    'reconciliation', (SELECT row_to_json(x) FROM (SELECT * FROM public.v_cod_reconciliation_check) x)
  );
END;
$$;


ALTER FUNCTION "public"."get_cod_audit"("p_order_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_coupon_by_code"("p_code" "text") RETURNS TABLE("id" "uuid", "code" "text", "is_active" boolean, "data" "jsonb")
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select c.id, c.code, c.is_active, c.data
  from public.coupons c
  where lower(c.code) = lower(p_code)
  limit 1;
$$;


ALTER FUNCTION "public"."get_coupon_by_code"("p_code" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_customer_credit_summary"("p_customer_id" "uuid") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_customer record;
  v_balance numeric := 0;
  v_available numeric := 0;
  v_company_id uuid;
begin
  select c.*
  into v_customer
  from public.customers c
  where c.auth_user_id = p_customer_id;

  if not found then
    return json_build_object('exists', false);
  end if;

  select s.company_id into v_company_id
  from public.get_admin_session_scope() s
  limit 1;

  if v_company_id is null then
    v_balance := public.compute_customer_ar_balance(p_customer_id);
    update public.customers
    set current_balance = v_balance,
        updated_at = now()
    where auth_user_id = p_customer_id;
  else
    v_balance := public.compute_customer_ar_balance_in_company(p_customer_id, v_company_id);
  end if;

  v_available := greatest(coalesce(v_customer.credit_limit, 0) - v_balance, 0);

  return json_build_object(
    'exists', true,
    'customer_id', p_customer_id,
    'company_id', v_company_id,
    'customer_type', v_customer.customer_type,
    'payment_terms', v_customer.payment_terms,
    'credit_limit', coalesce(v_customer.credit_limit, 0),
    'current_balance', v_balance,
    'available_credit', v_available
  );
end;
$$;


ALTER FUNCTION "public"."get_customer_credit_summary"("p_customer_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_daily_sales_stats"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid" DEFAULT NULL::"uuid", "p_invoice_only" boolean DEFAULT false) RETURNS TABLE("day_date" "date", "total_sales" numeric, "order_count" bigint)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
begin
  if not public.is_staff() then
    raise exception 'not allowed';
  end if;

  return query
  with effective_orders as (
    select
      o.id,
      o.status,
      nullif(o.data->>'paidAt', '')::timestamptz as paid_at,
      case
        when p_invoice_only
          then nullif(o.data->'invoiceSnapshot'->>'issuedAt', '')::timestamptz
        else coalesce(
          nullif(o.data->'invoiceSnapshot'->>'issuedAt', '')::timestamptz,
          nullif(o.data->>'paidAt', '')::timestamptz,
          nullif(o.data->>'deliveredAt', '')::timestamptz,
          o.created_at
        )
      end as date_by,
      coalesce(nullif((o.data->>'total')::numeric, null), 0) as total,
      coalesce(
        o.delivery_zone_id,
        case
          when nullif(o.data->>'deliveryZoneId','') is not null
               and (o.data->>'deliveryZoneId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
            then (o.data->>'deliveryZoneId')::uuid
          else null
        end
      ) as zone_effective
    from public.orders o
    where (p_zone_id is null or coalesce(
      o.delivery_zone_id,
      case
        when nullif(o.data->>'deliveryZoneId','') is not null
             and (o.data->>'deliveryZoneId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
          then (o.data->>'deliveryZoneId')::uuid
        else null
      end
    ) = p_zone_id)
  )
  select
    eo.date_by::date as day_date,
    sum(eo.total) as total_sales,
    count(*) as order_count
  from effective_orders eo
  where (eo.status = 'delivered' or eo.paid_at is not null)
    and eo.date_by >= p_start_date
    and eo.date_by <= p_end_date
  group by 1
  order by 1;
end;
$_$;


ALTER FUNCTION "public"."get_daily_sales_stats"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_default_branch_id"() RETURNS "uuid"
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select b.id
  from public.branches b
  where b.is_active = true
  order by b.created_at asc
  limit 1
$$;


ALTER FUNCTION "public"."get_default_branch_id"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_default_company_id"() RETURNS "uuid"
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select c.id
  from public.companies c
  where c.is_active = true
  order by c.created_at asc
  limit 1
$$;


ALTER FUNCTION "public"."get_default_company_id"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_driver_performance_stats"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone) RETURNS TABLE("driver_id" "uuid", "driver_name" "text", "delivered_count" bigint, "avg_delivery_minutes" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
begin
  if not public.is_staff() then
    raise exception 'not allowed';
  end if;

  return query
  with driver_stats as (
    select
      assigned_delivery_user_id as did,
      count(*) as d_count,
      avg(
        extract(epoch from (
          (data->>'deliveredAt')::timestamptz - (data->>'outForDeliveryAt')::timestamptz
        )) / 60
      ) as avg_mins
    from public.orders
    where status = 'delivered'
      and assigned_delivery_user_id is not null
      and (data->>'outForDeliveryAt') is not null
      and (data->>'deliveredAt') is not null
      and (
        case when (data->'invoiceSnapshot'->>'issuedAt') is not null
             then (data->'invoiceSnapshot'->>'issuedAt')::timestamptz
             else coalesce((data->>'paidAt')::timestamptz, (data->>'deliveredAt')::timestamptz, created_at)
        end
      ) between p_start_date and p_end_date
    group by 1
  )
  select
    ds.did,
    coalesce(au.raw_user_meta_data->>'full_name', au.email, 'Unknown') as d_name,
    ds.d_count,
    ds.avg_mins::numeric
  from driver_stats ds
  left join auth.users au on au.id = ds.did
  order by 3 desc;
end;
$$;


ALTER FUNCTION "public"."get_driver_performance_stats"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_expiring_contracts"("days_threshold" integer DEFAULT 30) RETURNS TABLE("contract_id" "uuid", "supplier_name" "text", "end_date" "date", "days_remaining" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    sc.id,
    s.name,
    sc.end_date,
    (sc.end_date - CURRENT_DATE)::INTEGER
  FROM supplier_contracts sc
  JOIN suppliers s ON sc.supplier_id = s.id
  WHERE sc.status = 'active'
    AND sc.end_date <= (CURRENT_DATE + days_threshold)
    AND sc.end_date >= CURRENT_DATE;
END;
$$;


ALTER FUNCTION "public"."get_expiring_contracts"("days_threshold" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_fefo_pricing"("p_item_id" "uuid", "p_warehouse_id" "uuid", "p_quantity" numeric) RETURNS TABLE("batch_id" "uuid", "unit_cost" numeric, "min_price" numeric, "suggested_price" numeric, "batch_code" "text", "expiry_date" "date", "next_batch_min_price" numeric, "warning_next_batch_price_diff" boolean, "reason_code" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_qty numeric := greatest(coalesce(p_quantity, 0), 0);
  v_batch record;
  v_next record;
  v_base_price numeric := 0;
  v_total_released numeric := 0;
  v_has_nonexpired boolean := false;
  v_has_nonexpired_unreleased boolean := false;
begin
  if p_item_id is null then
    raise exception 'p_item_id is required';
  end if;
  if p_warehouse_id is null then
    raise exception 'p_warehouse_id is required';
  end if;
  if v_qty <= 0 then
    v_qty := 1;
  end if;

  select
    b.id,
    b.cost_per_unit,
    b.min_selling_price,
    b.batch_code,
    b.expiry_date,
    greatest(coalesce(b.quantity_received,0) - coalesce(b.quantity_consumed,0) - coalesce(b.quantity_transferred,0), 0) as remaining
  into v_batch
  from public.batches b
  where b.item_id::text = p_item_id::text
    and b.warehouse_id = p_warehouse_id
    and coalesce(b.status, 'active') = 'active'
    and (b.expiry_date is null or b.expiry_date >= current_date)
    and greatest(coalesce(b.quantity_received,0) - coalesce(b.quantity_consumed,0) - coalesce(b.quantity_transferred,0), 0) > 0
    and coalesce(b.qc_status,'released') = 'released'
  order by b.expiry_date asc nulls last, b.created_at asc, b.id asc
  limit 1;

  select exists(
    select 1
    from public.batches b
    where b.item_id::text = p_item_id::text
      and b.warehouse_id = p_warehouse_id
      and coalesce(b.status, 'active') = 'active'
      and (b.expiry_date is null or b.expiry_date >= current_date)
      and greatest(coalesce(b.quantity_received,0) - coalesce(b.quantity_consumed,0) - coalesce(b.quantity_transferred,0), 0) > 0
  ) into v_has_nonexpired;

  select exists(
    select 1
    from public.batches b
    where b.item_id::text = p_item_id::text
      and b.warehouse_id = p_warehouse_id
      and coalesce(b.status, 'active') = 'active'
      and (b.expiry_date is null or b.expiry_date >= current_date)
      and greatest(coalesce(b.quantity_received,0) - coalesce(b.quantity_consumed,0) - coalesce(b.quantity_transferred,0), 0) > 0
      and coalesce(b.qc_status,'released') <> 'released'
  ) into v_has_nonexpired_unreleased;

  if v_batch.id is null then
    if v_has_nonexpired_unreleased then
      reason_code := 'BATCH_NOT_RELEASED';
    else
      reason_code := 'NO_VALID_BATCH';
    end if;
    batch_id := null;
    unit_cost := 0;
    min_price := 0;
    suggested_price := 0;
    batch_code := null;
    expiry_date := null;
    next_batch_min_price := null;
    warning_next_batch_price_diff := false;
    return next;
  end if;

  select coalesce(sum(greatest(coalesce(b.quantity_received,0) - coalesce(b.quantity_consumed,0) - coalesce(b.quantity_transferred,0), 0)), 0)
  into v_total_released
  from public.batches b
  where b.item_id::text = p_item_id::text
    and b.warehouse_id = p_warehouse_id
    and coalesce(b.status, 'active') = 'active'
    and (b.expiry_date is null or b.expiry_date >= current_date)
    and coalesce(b.qc_status,'released') = 'released';

  if v_total_released + 1e-9 < v_qty then
    reason_code := 'INSUFFICIENT_BATCH_QUANTITY';
  else
    reason_code := null;
  end if;

  v_base_price := public.get_item_price_with_discount(p_item_id::text, null::uuid, v_qty);

  batch_id := v_batch.id;
  unit_cost := coalesce(v_batch.cost_per_unit, 0);
  min_price := coalesce(v_batch.min_selling_price, 0);
  suggested_price := greatest(coalesce(v_base_price, 0), coalesce(v_batch.min_selling_price, 0));
  batch_code := v_batch.batch_code;
  expiry_date := v_batch.expiry_date;

  select
    b.min_selling_price
  into v_next
  from public.batches b
  where b.item_id::text = p_item_id::text
    and b.warehouse_id = p_warehouse_id
    and coalesce(b.status, 'active') = 'active'
    and (b.expiry_date is null or b.expiry_date >= current_date)
    and greatest(coalesce(b.quantity_received,0) - coalesce(b.quantity_consumed,0) - coalesce(b.quantity_transferred,0), 0) > 0
    and coalesce(b.qc_status,'released') = 'released'
    and b.id <> v_batch.id
  order by b.expiry_date asc nulls last, b.created_at asc, b.id asc
  limit 1;

  next_batch_min_price := nullif(coalesce(v_next.min_selling_price, null), null);
  warning_next_batch_price_diff :=
    case
      when next_batch_min_price is null then false
      else abs(next_batch_min_price - min_price) > 1e-9
    end;

  return next;
end;
$$;


ALTER FUNCTION "public"."get_fefo_pricing"("p_item_id" "uuid", "p_warehouse_id" "uuid", "p_quantity" numeric) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_fefo_pricing"("p_item_id" "uuid", "p_warehouse_id" "uuid", "p_quantity" numeric, "p_customer_id" "uuid") RETURNS TABLE("batch_id" "uuid", "unit_cost" numeric, "min_price" numeric, "suggested_price" numeric, "batch_code" "text", "expiry_date" "date", "next_batch_min_price" numeric, "warning_next_batch_price_diff" boolean, "reason_code" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_qty numeric := greatest(coalesce(p_quantity, 0), 0);
  v_base_price numeric := 0;
  v_row record;
begin
  if v_qty <= 0 then
    v_qty := 1;
  end if;

  select * into v_row from public.get_fefo_pricing(p_item_id, p_warehouse_id, v_qty);
  batch_id := v_row.batch_id;
  unit_cost := v_row.unit_cost;
  min_price := v_row.min_price;
  batch_code := v_row.batch_code;
  expiry_date := v_row.expiry_date;
  next_batch_min_price := v_row.next_batch_min_price;
  warning_next_batch_price_diff := v_row.warning_next_batch_price_diff;
  reason_code := v_row.reason_code;

  if batch_id is null then
    suggested_price := 0;
    return next;
  end if;

  v_base_price := public.get_item_price_with_discount(p_item_id::text, p_customer_id, v_qty);
  suggested_price := greatest(coalesce(v_base_price, 0), coalesce(min_price, 0));
  return next;
end;
$$;


ALTER FUNCTION "public"."get_fefo_pricing"("p_item_id" "uuid", "p_warehouse_id" "uuid", "p_quantity" numeric, "p_customer_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_food_expired_in_stock_alert"() RETURNS TABLE("item_id" "text", "item_name" "text", "batch_id" "uuid", "warehouse_id" "uuid", "warehouse_code" "text", "warehouse_name" "text", "expiry_date" "date", "days_expired" integer, "qty_remaining" numeric)
    LANGUAGE "sql" STABLE
    SET "search_path" TO 'public'
    AS $$
  select
    mi.id as item_id,
    coalesce(mi.data->'name'->>'ar', mi.data->'name'->>'en', mi.data->>'name', mi.id) as item_name,
    b.batch_id,
    w.id as warehouse_id,
    w.code as warehouse_code,
    w.name as warehouse_name,
    b.expiry_date,
    (current_date - b.expiry_date)::int as days_expired,
    b.remaining_qty as qty_remaining
  from public.v_food_batch_balances b
  join public.menu_items mi on mi.id = b.item_id
  left join public.warehouses w on w.id = b.warehouse_id
  where mi.category = 'food'
    and b.expiry_date is not null
    and b.remaining_qty > 0
    and b.expiry_date < current_date;
$$;


ALTER FUNCTION "public"."get_food_expired_in_stock_alert"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_food_near_expiry_alert"("p_threshold_days" integer DEFAULT 7) RETURNS TABLE("item_id" "text", "item_name" "text", "batch_id" "uuid", "warehouse_id" "uuid", "warehouse_code" "text", "warehouse_name" "text", "expiry_date" "date", "days_remaining" integer, "qty_remaining" numeric)
    LANGUAGE "sql" STABLE
    SET "search_path" TO 'public'
    AS $$
  select
    mi.id as item_id,
    coalesce(mi.data->'name'->>'ar', mi.data->'name'->>'en', mi.data->>'name', mi.id) as item_name,
    b.batch_id,
    w.id as warehouse_id,
    w.code as warehouse_code,
    w.name as warehouse_name,
    b.expiry_date,
    (b.expiry_date - current_date)::int as days_remaining,
    b.remaining_qty as qty_remaining
  from public.v_food_batch_balances b
  join public.menu_items mi on mi.id = b.item_id
  left join public.warehouses w on w.id = b.warehouse_id
  where mi.category = 'food'
    and b.expiry_date is not null
    and b.remaining_qty > 0
    and b.expiry_date >= current_date
    and b.expiry_date <= current_date + greatest(coalesce(p_threshold_days, 0), 0);
$$;


ALTER FUNCTION "public"."get_food_near_expiry_alert"("p_threshold_days" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_food_reservation_block_reason"("p_item_id" "text" DEFAULT NULL::"text") RETURNS TABLE("item_id" "text", "item_name" "text", "batch_id" "uuid", "expiry_date" "date", "days_from_today" integer, "qty_remaining" numeric, "reason" "text")
    LANGUAGE "sql" STABLE
    SET "search_path" TO 'public'
    AS $$
  select
    mi.id as item_id,
    coalesce(mi.data->'name'->>'ar', mi.data->'name'->>'en', mi.data->>'name', mi.id) as item_name,
    b.batch_id,
    b.expiry_date,
    case
      when b.expiry_date is null then null
      else (b.expiry_date - current_date)::int
    end as days_from_today,
    b.remaining_qty as qty_remaining,
    case
      when b.expiry_date is null then 'missing_expiry'
      when b.expiry_date < current_date then 'expired'
      else 'ok'
    end as reason
  from public.v_food_batch_balances b
  join public.menu_items mi on mi.id = b.item_id
  where mi.category = 'food'
    and b.remaining_qty > 0
    and (
      b.expiry_date is null
      or b.expiry_date < current_date
    )
    and (p_item_id is null or b.item_id = p_item_id);
$$;


ALTER FUNCTION "public"."get_food_reservation_block_reason"("p_item_id" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_food_sales_movements_report"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_warehouse_id" "uuid" DEFAULT NULL::"uuid", "p_branch_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("order_id" "uuid", "sold_at" timestamp with time zone, "warehouse_id" "uuid", "branch_id" "uuid", "item_id" "text", "item_name" "jsonb", "batch_id" "uuid", "expiry_date" "date", "supplier_id" "uuid", "supplier_name" "text", "quantity" numeric, "unit_cost" numeric, "total_cost" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  perform public._require_staff('get_food_sales_movements_report');

  return query
  select
    (im.reference_id)::uuid as order_id,
    im.occurred_at as sold_at,
    im.warehouse_id,
    im.branch_id,
    im.item_id::text as item_id,
    coalesce(mi.data->'name', '{}'::jsonb) as item_name,
    im.batch_id,
    b.expiry_date,
    po.supplier_id,
    s.name as supplier_name,
    im.quantity,
    im.unit_cost,
    im.total_cost
  from public.inventory_movements im
  join public.menu_items mi on mi.id::text = im.item_id::text
  join public.batches b on b.id = im.batch_id
  left join public.purchase_receipts pr on pr.id = b.receipt_id
  left join public.purchase_orders po on po.id = pr.purchase_order_id
  left join public.suppliers s on s.id = po.supplier_id
  where im.movement_type = 'sale_out'
    and im.reference_table = 'orders'
    and im.occurred_at >= p_start_date
    and im.occurred_at <= p_end_date
    and coalesce(mi.category,'') = 'food'
    and (p_warehouse_id is null or im.warehouse_id = p_warehouse_id)
    and (p_branch_id is null or im.branch_id = p_branch_id)
  order by im.occurred_at desc;
end;
$$;


ALTER FUNCTION "public"."get_food_sales_movements_report"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_warehouse_id" "uuid", "p_branch_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_fx_rate"("p_currency" "text", "p_date" "date", "p_rate_type" "text") RETURNS numeric
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_currency text;
  v_type text;
  v_date date;
  v_base text;
  v_rate numeric;
  v_base_high boolean := false;
begin
  v_currency := upper(nullif(btrim(coalesce(p_currency, '')), ''));
  v_type := lower(nullif(btrim(coalesce(p_rate_type, '')), ''));
  v_date := coalesce(p_date, current_date);
  v_base := public.get_base_currency();

  if v_type is null then
    v_type := 'operational';
  end if;
  if v_currency is null then
    v_currency := v_base;
  end if;

  if v_currency = v_base then
    if v_type = 'accounting' then
      select coalesce(c.is_high_inflation, false)
      into v_base_high
      from public.currencies c
      where upper(c.code) = upper(v_base)
      limit 1;
      if v_base_high then
        select fr.rate
        into v_rate
        from public.fx_rates fr
        where upper(fr.currency_code) = v_base
          and fr.rate_type = v_type
          and fr.rate_date <= v_date
        order by fr.rate_date desc
        limit 1;
        return v_rate;
      end if;
    end if;
    return 1;
  end if;

  select fr.rate
  into v_rate
  from public.fx_rates fr
  where upper(fr.currency_code) = v_currency
    and fr.rate_type = v_type
    and fr.rate_date <= v_date
  order by fr.rate_date desc
  limit 1;

  return v_rate;
end;
$$;


ALTER FUNCTION "public"."get_fx_rate"("p_currency" "text", "p_date" "date", "p_rate_type" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_hourly_sales_stats"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid" DEFAULT NULL::"uuid", "p_invoice_only" boolean DEFAULT false) RETURNS TABLE("hour_of_day" integer, "total_sales" numeric, "order_count" bigint)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
begin
  if not public.is_staff() then
    raise exception 'not allowed';
  end if;

  return query
  with effective_orders as (
    select
      o.id,
      o.status,
      nullif(o.data->>'paidAt', '')::timestamptz as paid_at,
      case
        when p_invoice_only
          then nullif(o.data->'invoiceSnapshot'->>'issuedAt', '')::timestamptz
        else coalesce(
          nullif(o.data->'invoiceSnapshot'->>'issuedAt', '')::timestamptz,
          nullif(o.data->>'paidAt', '')::timestamptz,
          nullif(o.data->>'deliveredAt', '')::timestamptz,
          o.created_at
        )
      end as date_by,
      coalesce(nullif((o.data->>'total')::numeric, null), 0) as total,
      coalesce(
        o.delivery_zone_id,
        case
          when nullif(o.data->>'deliveryZoneId','') is not null
               and (o.data->>'deliveryZoneId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
            then (o.data->>'deliveryZoneId')::uuid
          else null
        end
      ) as zone_effective
    from public.orders o
    where (p_zone_id is null or coalesce(
      o.delivery_zone_id,
      case
        when nullif(o.data->>'deliveryZoneId','') is not null
             and (o.data->>'deliveryZoneId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
          then (o.data->>'deliveryZoneId')::uuid
        else null
      end
    ) = p_zone_id)
  )
  select
    extract(hour from eo.date_by)::int as hour_of_day,
    sum(eo.total) as total_sales,
    count(*) as order_count
  from effective_orders eo
  where (eo.status = 'delivered' or eo.paid_at is not null)
    and eo.date_by >= p_start_date
    and eo.date_by <= p_end_date
  group by 1
  order by 1;
end;
$_$;


ALTER FUNCTION "public"."get_hourly_sales_stats"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_invoice_audit"("p_order_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_actor uuid;
  v_order record;
  v_invoice_snapshot jsonb;
  v_journal_entry_id uuid;
  v_promotions jsonb;
  v_manual_discount numeric := 0;
  v_discount_type text := 'None';
begin
  v_actor := auth.uid();
  if v_actor is null then
    raise exception 'not authenticated';
  end if;

  select o.*, o.data->'invoiceSnapshot' as invoice_snapshot
  into v_order
  from public.orders o
  where o.id = p_order_id;

  if not found then
    raise exception 'order not found';
  end if;

  if not (
    public.is_admin()
    or public.has_admin_permission('orders.view')
    or v_order.customer_auth_user_id = v_actor
  ) then
    raise exception 'not authorized';
  end if;

  v_invoice_snapshot := coalesce(v_order.invoice_snapshot, '{}'::jsonb);

  select je.id
  into v_journal_entry_id
  from public.journal_entries je
  where je.source_table = 'orders'
    and je.source_id = p_order_id::text
    and je.source_event = 'delivered'
  order by je.created_at desc
  limit 1;

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'promotionUsageId', pu.id::text,
        'promotionLineId', pu.promotion_line_id::text,
        'promotionId', pu.promotion_id::text,
        'promotionName', coalesce(nullif(pu.snapshot->>'name',''), pr.name),
        'approvalRequestId', case when pr.approval_request_id is null then null else pr.approval_request_id::text end,
        'approvalStatus', pr.approval_status,
        'bundleQty', pu.bundle_qty,
        'computedOriginalTotal', nullif(pu.snapshot->>'computedOriginalTotal','')::numeric,
        'finalTotal', nullif(pu.snapshot->>'finalTotal','')::numeric,
        'promotionExpense', nullif(pu.snapshot->>'promotionExpense','')::numeric
      )
      order by pu.created_at asc
    ),
    '[]'::jsonb
  )
  into v_promotions
  from public.promotion_usage pu
  left join public.promotions pr on pr.id = pu.promotion_id
  where pu.order_id = p_order_id;

  v_manual_discount := coalesce(
    nullif(v_invoice_snapshot->>'discountAmount','')::numeric,
    nullif(v_order.data->>'discountAmount','')::numeric,
    0
  );

  if jsonb_typeof(v_promotions) = 'array' and jsonb_array_length(v_promotions) > 0 then
    v_discount_type := 'Promotion';
  elsif v_manual_discount > 0 then
    v_discount_type := 'Manual Discount';
  end if;

  return jsonb_build_object(
    'orderId', p_order_id::text,
    'invoiceNumber', coalesce(
      nullif(v_invoice_snapshot->>'invoiceNumber',''),
      nullif(v_order.invoice_number,'')
    ),
    'invoiceIssuedAt', nullif(v_invoice_snapshot->>'issuedAt',''),
    'discountType', v_discount_type,
    'manualDiscountAmount', v_manual_discount,
    'manualDiscountApprovalRequestId', case when v_order.discount_approval_request_id is null then null else v_order.discount_approval_request_id::text end,
    'manualDiscountApprovalStatus', v_order.discount_approval_status,
    'promotions', v_promotions,
    'journalEntryId', case when v_journal_entry_id is null then null else v_journal_entry_id::text end
  );
end;
$$;


ALTER FUNCTION "public"."get_invoice_audit"("p_order_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_item_all_prices"("p_item_id" "text") RETURNS TABLE("customer_type" "text", "min_qty" numeric, "max_qty" numeric, "price" numeric, "discount_pct" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'not allowed';
  END IF;

  RETURN QUERY
  SELECT 
    pt.customer_type,
    pt.min_quantity,
    pt.max_quantity,
    pt.price,
    pt.discount_percentage
  FROM public.price_tiers pt
  WHERE pt.item_id = p_item_id
    AND pt.is_active = true
    AND (pt.valid_from IS NULL OR pt.valid_from <= CURRENT_DATE)
    AND (pt.valid_to IS NULL OR pt.valid_to >= CURRENT_DATE)
  ORDER BY pt.customer_type, pt.min_quantity;
END;
$$;


ALTER FUNCTION "public"."get_item_all_prices"("p_item_id" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_item_batches"("p_item_id" "uuid", "p_warehouse_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("batch_id" "uuid", "occurred_at" timestamp with time zone, "unit_cost" numeric, "received_quantity" numeric, "consumed_quantity" numeric, "remaining_quantity" numeric, "qc_status" "text", "last_qc_result" "text", "last_qc_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_wh uuid;
begin
  perform public._require_staff('get_item_batches');

  v_wh := coalesce(p_warehouse_id, public._resolve_default_admin_warehouse_id());
  if v_wh is null then
    raise exception 'warehouse_id is required';
  end if;

  return query
  select
    b.id as batch_id,
    max(im.occurred_at) as occurred_at,
    max(im.unit_cost) as unit_cost,
    sum(case when im.movement_type = 'purchase_in' then im.quantity else 0 end) as received_quantity,
    sum(case when im.movement_type = 'sale_out' then im.quantity else 0 end) as consumed_quantity,
    sum(case when im.movement_type = 'purchase_in' then im.quantity else 0 end)
      - sum(case when im.movement_type = 'sale_out' then im.quantity else 0 end) as remaining_quantity,
    coalesce(b.qc_status,'released') as qc_status,
    q.last_result as last_qc_result,
    q.last_at as last_qc_at
  from public.inventory_movements im
  join public.batches b on b.id = im.batch_id
  left join lateral (
    select qc.result as last_result, qc.checked_at as last_at
    from public.qc_checks qc
    where qc.batch_id = b.id
      and qc.check_type = 'inspection'
    order by qc.checked_at desc
    limit 1
  ) q on true
  where b.item_id::uuid = p_item_id
    and b.warehouse_id = v_wh
    and im.batch_id is not null
  group by b.id, b.qc_status, q.last_result, q.last_at
  having (
    sum(case when im.movement_type = 'purchase_in' then im.quantity else 0 end)
      - sum(case when im.movement_type = 'sale_out' then im.quantity else 0 end)
  ) > 0
  order by occurred_at desc;
end;
$$;


ALTER FUNCTION "public"."get_item_batches"("p_item_id" "uuid", "p_warehouse_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_item_discount"("p_item_id" "text", "p_quantity" numeric, "p_customer_id" "uuid" DEFAULT NULL::"uuid") RETURNS numeric
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_customer_type TEXT;
  v_discount NUMERIC;
  v_base_price NUMERIC;
  v_tier_price NUMERIC;
BEGIN
  --       
  IF p_customer_id IS NULL THEN
    RETURN 0;
  END IF;

  IF auth.uid() IS NULL THEN
    RETURN 0;
  END IF;

  IF p_customer_id <> auth.uid() AND not public.is_admin() THEN
    RETURN 0;
  END IF;
  
  --    
  SELECT COALESCE(customer_type, 'retail') INTO v_customer_type 
  FROM public.customers WHERE auth_user_id = p_customer_id;
  
  IF NOT FOUND THEN
    RETURN 0;
  END IF;
  
  --       
  SELECT discount_percentage INTO v_discount
  FROM public.price_tiers
  WHERE item_id = p_item_id
    AND customer_type = v_customer_type
    AND min_quantity <= p_quantity
    AND (max_quantity IS NULL OR max_quantity >= p_quantity)
    AND is_active = true
    AND (valid_from IS NULL OR valid_from <= CURRENT_DATE)
    AND (valid_to IS NULL OR valid_to >= CURRENT_DATE)
    AND discount_percentage IS NOT NULL
  ORDER BY min_quantity DESC
  LIMIT 1;
  
  RETURN COALESCE(v_discount, 0);
END;
$$;


ALTER FUNCTION "public"."get_item_discount"("p_item_id" "text", "p_quantity" numeric, "p_customer_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_item_price"("p_item_id" "text", "p_quantity" numeric, "p_customer_id" "uuid" DEFAULT NULL::"uuid") RETURNS numeric
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_customer_type text;
  v_special_price numeric;
  v_tier_price numeric;
  v_base_price numeric;
begin
  if p_customer_id is null then
    v_customer_type := 'retail';
  else
    if auth.uid() is null then
      v_customer_type := 'retail';
    elsif p_customer_id <> auth.uid() and not public.is_admin() then
      v_customer_type := 'retail';
    else
      select coalesce(customer_type, 'retail') into v_customer_type
      from public.customers
      where auth_user_id = p_customer_id;

      if not found then
        v_customer_type := 'retail';
      end if;

      select special_price into v_special_price
      from public.customer_special_prices
      where customer_id = p_customer_id
        and item_id = p_item_id
        and (valid_from is null or valid_from <= current_date)
        and (valid_to is null or valid_to >= current_date);

      if v_special_price is not null then
        return v_special_price;
      end if;
    end if;
  end if;

  select price into v_tier_price
  from public.price_tiers
  where item_id = p_item_id
    and customer_type = v_customer_type
    and min_quantity <= p_quantity
    and (max_quantity is null or max_quantity >= p_quantity)
    and is_active = true
    and (valid_from is null or valid_from <= current_date)
    and (valid_to is null or valid_to >= current_date)
  order by min_quantity desc
  limit 1;

  if v_tier_price is not null then
    return v_tier_price;
  end if;

  select mi.price into v_base_price
  from public.menu_items mi
  where mi.id = p_item_id;

  return coalesce(v_base_price, 0);
end;
$$;


ALTER FUNCTION "public"."get_item_price"("p_item_id" "text", "p_quantity" numeric, "p_customer_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_item_price_with_discount"("p_item_id" "uuid", "p_customer_id" "uuid" DEFAULT NULL::"uuid", "p_quantity" numeric DEFAULT 1) RETURNS numeric
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_customer_type text := 'retail';
  v_special_price numeric;
  v_tier_price numeric;
  v_tier_discount numeric;
  v_base_unit_price numeric;
  v_unit_type text;
  v_price_per_unit numeric;
  v_final_unit_price numeric;
BEGIN
  IF p_item_id IS NULL THEN
    RAISE EXCEPTION 'p_item_id is required';
  END IF;
  
  IF p_quantity IS NULL OR p_quantity <= 0 THEN
    p_quantity := 1;
  END IF;

  SELECT
    COALESCE(mi.unit_type, 'piece'),
    COALESCE(NULLIF((mi.data->>'pricePerUnit')::numeric, NULL), 0),
    COALESCE(NULLIF((mi.data->>'price')::numeric, NULL), mi.price, 0)
  INTO v_unit_type, v_price_per_unit, v_base_unit_price
  FROM public.menu_items mi
  WHERE mi.id::text = p_item_id::text;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Item not found: %', p_item_id;
  END IF;

  IF v_unit_type = 'gram' AND COALESCE(v_price_per_unit, 0) > 0 THEN
    v_base_unit_price := v_price_per_unit / 1000;
  END IF;

  IF p_customer_id IS NOT NULL THEN
    SELECT COALESCE(c.customer_type, 'retail')
    INTO v_customer_type
    FROM public.customers c
    WHERE c.auth_user_id::text = p_customer_id::text;

    IF NOT FOUND THEN
      v_customer_type := 'retail';
    END IF;

    SELECT csp.special_price
    INTO v_special_price
    FROM public.customer_special_prices csp
    WHERE csp.customer_id::text = p_customer_id::text
      AND csp.item_id::text = p_item_id::text
      AND csp.is_active = true
      AND (csp.valid_from IS NULL OR csp.valid_from <= now())
      AND (csp.valid_to IS NULL OR csp.valid_to >= now())
    ORDER BY csp.created_at DESC
    LIMIT 1;

    IF v_special_price IS NOT NULL THEN
      RETURN v_special_price;
    END IF;
  END IF;

  SELECT pt.price, pt.discount_percentage
  INTO v_tier_price, v_tier_discount
  FROM public.price_tiers pt
  WHERE pt.item_id::text = p_item_id::text
    AND pt.customer_type = v_customer_type
    AND pt.is_active = true
    AND pt.min_quantity <= p_quantity
    AND (pt.max_quantity IS NULL OR pt.max_quantity >= p_quantity)
    AND (pt.valid_from IS NULL OR pt.valid_from <= now())
    AND (pt.valid_to IS NULL OR pt.valid_to >= now())
  ORDER BY pt.min_quantity DESC
  LIMIT 1;

  IF v_tier_price IS NOT NULL AND v_tier_price > 0 THEN
    v_final_unit_price := v_tier_price;
  ELSE
    v_final_unit_price := v_base_unit_price;
    IF COALESCE(v_tier_discount, 0) > 0 THEN
      v_final_unit_price := v_base_unit_price * (1 - (LEAST(100, GREATEST(0, v_tier_discount)) / 100));
    END IF;
  END IF;

  RETURN COALESCE(v_final_unit_price, 0);
END;
$$;


ALTER FUNCTION "public"."get_item_price_with_discount"("p_item_id" "uuid", "p_customer_id" "uuid", "p_quantity" numeric) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_item_suggested_sell_price"("p_item_id" "text", "p_warehouse_id" "uuid", "p_cost_per_unit" numeric DEFAULT NULL::numeric, "p_margin_pct" numeric DEFAULT NULL::numeric) RETURNS TABLE("cost_per_unit" numeric, "margin_pct" numeric, "suggested_price" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_cost numeric;
  v_margin numeric;
begin
  perform public._require_staff('get_item_suggested_sell_price');

  v_cost := coalesce(p_cost_per_unit, 0);
  if v_cost <= 0 and p_item_id is not null then
    begin
      select coalesce(sm.avg_cost, 0)
      into v_cost
      from public.stock_management sm
      where sm.item_id::text = p_item_id::text
        and (p_warehouse_id is null or sm.warehouse_id = p_warehouse_id)
      order by (sm.warehouse_id = p_warehouse_id) desc, sm.updated_at desc
      limit 1;
    exception when others then
      v_cost := coalesce(p_cost_per_unit, 0);
    end;
  end if;

  v_margin := coalesce(p_margin_pct, 0);
  if v_margin <= 0 then
    v_margin := public._resolve_default_min_margin_pct(p_item_id, p_warehouse_id);
  end if;

  cost_per_unit := public._money_round(greatest(coalesce(v_cost, 0), 0), 6);
  margin_pct := public._money_round(greatest(coalesce(v_margin, 0), 0), 6);
  suggested_price := public._money_round(cost_per_unit * (1 + (margin_pct / 100)));

  return next;
end;
$$;


ALTER FUNCTION "public"."get_item_suggested_sell_price"("p_item_id" "text", "p_warehouse_id" "uuid", "p_cost_per_unit" numeric, "p_margin_pct" numeric) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_open_reservations_report"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_warehouse_id" "uuid" DEFAULT NULL::"uuid", "p_search" "text" DEFAULT NULL::"text", "p_limit" integer DEFAULT 500, "p_offset" integer DEFAULT 0) RETURNS TABLE("order_id" "uuid", "order_status" "text", "order_created_at" timestamp with time zone, "order_source" "text", "customer_name" "text", "delivery_zone_id" "uuid", "delivery_zone_name" "text", "item_id" "text", "item_name" "jsonb", "reserved_quantity" numeric, "warehouse_id" "uuid", "warehouse_name" "text", "reservation_updated_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
declare
  v_search text;
begin
  if not public.is_staff() then
    raise exception 'not allowed';
  end if;
  if p_start_date is null or p_end_date is null then
    raise exception 'start and end dates are required';
  end if;

  v_search := nullif(trim(p_search), '');

  return query
  with base as (
    select
      r.order_id,
      o.status::text as order_status,
      o.created_at as order_created_at,
      coalesce(nullif(o.data->>'orderSource',''), '') as order_source,
      coalesce(nullif(o.data->>'customerName',''), '') as customer_name,
      coalesce(
        o.delivery_zone_id,
        case
          when nullif(o.data->>'deliveryZoneId','') is not null
               and (o.data->>'deliveryZoneId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
            then (o.data->>'deliveryZoneId')::uuid
          else null
        end
      ) as delivery_zone_id,
      r.item_id,
      r.quantity as reserved_quantity,
      r.warehouse_id,
      r.updated_at as reservation_updated_at
    from public.order_item_reservations r
    join public.orders o on o.id = r.order_id
    where r.quantity > 0
      and o.status not in ('delivered','cancelled')
      and o.created_at >= p_start_date
      and o.created_at <= p_end_date
      and (p_warehouse_id is null or r.warehouse_id = p_warehouse_id)
  )
  select
    b.order_id,
    b.order_status,
    b.order_created_at,
    b.order_source,
    b.customer_name,
    b.delivery_zone_id,
    coalesce(dz.name, '') as delivery_zone_name,
    b.item_id,
    coalesce(mi.data->'name', jsonb_build_object('ar', b.item_id)) as item_name,
    b.reserved_quantity,
    b.warehouse_id,
    coalesce(w.name, '') as warehouse_name,
    b.reservation_updated_at
  from base b
  left join public.delivery_zones dz on dz.id = b.delivery_zone_id
  left join public.warehouses w on w.id = b.warehouse_id
  left join public.menu_items mi on mi.id::text = b.item_id
  where (
    v_search is null
    or right(b.order_id::text, 6) ilike '%' || v_search || '%'
    or b.customer_name ilike '%' || v_search || '%'
    or coalesce(w.name, '') ilike '%' || v_search || '%'
    or coalesce(dz.name, '') ilike '%' || v_search || '%'
    or b.item_id ilike '%' || v_search || '%'
    or coalesce(mi.data->'name'->>'ar', '') ilike '%' || v_search || '%'
    or coalesce(mi.data->'name'->>'en', '') ilike '%' || v_search || '%'
  )
  order by b.reservation_updated_at desc, b.order_created_at desc
  limit greatest(1, least(p_limit, 20000))
  offset greatest(0, p_offset);
end;
$_$;


ALTER FUNCTION "public"."get_open_reservations_report"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_warehouse_id" "uuid", "p_search" "text", "p_limit" integer, "p_offset" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_or_create_uom"("p_code" "text") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_id uuid;
begin
  select id into v_id from public.uom where code = p_code limit 1;
  if v_id is null then
    insert into public.uom(code, name) values (p_code, p_code) returning id into v_id;
  end if;
  return v_id;
end;
$$;


ALTER FUNCTION "public"."get_or_create_uom"("p_code" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_order_customer_type"("p_order_id" "uuid") RETURNS "text"
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select c.customer_type
  from public.orders o
  join public.customers c
    on c.auth_user_id::text = coalesce(o.customer_auth_user_id::text, nullif(o.data->>'customerId',''))
  where o.id = p_order_id
$$;


ALTER FUNCTION "public"."get_order_customer_type"("p_order_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_order_item_reservations"("p_order_id" "uuid") RETURNS TABLE("item_id" "text", "warehouse_id" "uuid", "quantity" numeric, "created_at" timestamp with time zone, "updated_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_actor uuid;
  v_owner uuid;
begin
  v_actor := auth.uid();
  if v_actor is null then
    raise exception 'not authenticated';
  end if;
  if p_order_id is null then
    raise exception 'p_order_id is required';
  end if;

  select o.customer_auth_user_id into v_owner
  from public.orders o
  where o.id = p_order_id;

  if not found then
    raise exception 'order not found';
  end if;

  if not public.is_staff() and v_owner <> v_actor then
    raise exception 'not allowed';
  end if;

  return query
  select r.item_id, r.warehouse_id, r.quantity, r.created_at, r.updated_at
  from public.order_item_reservations r
  where r.order_id = p_order_id
  order by r.created_at asc, r.item_id asc;
end;
$$;


ALTER FUNCTION "public"."get_order_item_reservations"("p_order_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_order_source_revenue"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid" DEFAULT NULL::"uuid", "p_invoice_only" boolean DEFAULT false) RETURNS TABLE("source" "text", "total_sales" numeric, "order_count" bigint)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
begin
  if not public.is_staff() then
    raise exception 'not allowed';
  end if;

  return query
  with effective_orders as (
    select
      o.status,
      nullif(o.data->>'paidAt', '')::timestamptz as paid_at,
      coalesce(nullif(o.data->>'orderSource',''), '') as order_source,
      case
        when p_invoice_only
          then nullif(o.data->'invoiceSnapshot'->>'issuedAt', '')::timestamptz
        else coalesce(
          nullif(o.data->'invoiceSnapshot'->>'issuedAt', '')::timestamptz,
          nullif(o.data->>'paidAt', '')::timestamptz,
          nullif(o.data->>'deliveredAt', '')::timestamptz,
          o.created_at
        )
      end as date_by,
      coalesce(nullif((o.data->>'total')::numeric, null), 0) as total,
      coalesce(
        o.delivery_zone_id,
        case
          when nullif(o.data->>'deliveryZoneId','') is not null
               and (o.data->>'deliveryZoneId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
            then (o.data->>'deliveryZoneId')::uuid
          else null
        end
      ) as zone_effective
    from public.orders o
    where (p_zone_id is null or coalesce(
      o.delivery_zone_id,
      case
        when nullif(o.data->>'deliveryZoneId','') is not null
             and (o.data->>'deliveryZoneId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
          then (o.data->>'deliveryZoneId')::uuid
        else null
      end
    ) = p_zone_id)
  )
  select
    case when eo.order_source = 'in_store' then 'in_store' else 'online' end as source,
    sum(eo.total) as total_sales,
    count(*) as order_count
  from effective_orders eo
  where (eo.status = 'delivered' or eo.paid_at is not null)
    and eo.date_by >= p_start_date
    and eo.date_by <= p_end_date
  group by 1
  order by 2 desc;
end;
$_$;


ALTER FUNCTION "public"."get_order_source_revenue"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_payment_method_stats"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid" DEFAULT NULL::"uuid", "p_invoice_only" boolean DEFAULT false) RETURNS TABLE("method" "text", "total_sales" numeric, "order_count" bigint)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
begin
  if not public.is_staff() then
    raise exception 'not allowed';
  end if;

  return query
  with effective_orders as (
    select
      o.id,
      o.status,
      coalesce(o.data->>'paymentMethod', 'unknown') as method,
      nullif(o.data->>'paidAt', '')::timestamptz as paid_at,
      case
        when p_invoice_only
          then nullif(o.data->'invoiceSnapshot'->>'issuedAt', '')::timestamptz
        else coalesce(
          nullif(o.data->'invoiceSnapshot'->>'issuedAt', '')::timestamptz,
          nullif(o.data->>'paidAt', '')::timestamptz,
          nullif(o.data->>'deliveredAt', '')::timestamptz,
          o.created_at
        )
      end as date_by,
      coalesce(nullif((o.data->>'total')::numeric, null), 0) as total,
      coalesce(
        o.delivery_zone_id,
        case
          when nullif(o.data->>'deliveryZoneId','') is not null
               and (o.data->>'deliveryZoneId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
            then (o.data->>'deliveryZoneId')::uuid
          else null
        end
      ) as zone_effective
    from public.orders o
    where (p_zone_id is null or coalesce(
      o.delivery_zone_id,
      case
        when nullif(o.data->>'deliveryZoneId','') is not null
             and (o.data->>'deliveryZoneId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
          then (o.data->>'deliveryZoneId')::uuid
        else null
      end
    ) = p_zone_id)
  )
  select
    eo.method,
    sum(eo.total) as total_sales,
    count(*) as order_count
  from effective_orders eo
  where (
      eo.paid_at is not null
      or (eo.status = 'delivered' and eo.method <> 'cash')
  )
    and eo.date_by >= p_start_date
    and eo.date_by <= p_end_date
  group by eo.method
  order by 2 desc;
end;
$_$;


ALTER FUNCTION "public"."get_payment_method_stats"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_pos_offline_sales_dashboard"("p_state" "text" DEFAULT NULL::"text", "p_limit" integer DEFAULT 200) RETURNS TABLE("offline_id" "text", "order_id" "uuid", "warehouse_id" "uuid", "state" "text", "created_by" "uuid", "created_at" timestamp with time zone, "synced_at" timestamp with time zone, "updated_at" timestamp with time zone, "last_error" "text", "reconciliation_status" "text", "reconciliation_approval_request_id" "uuid", "reconciled_by" "uuid", "reconciled_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if auth.uid() is null then
    raise exception 'not authenticated';
  end if;
  if not (public.has_admin_permission('reports.view') or public.has_admin_permission('accounting.view')) then
    raise exception 'not authorized';
  end if;

  return query
  select
    s.offline_id,
    s.order_id,
    s.warehouse_id,
    s.state,
    s.created_by,
    s.created_at,
    case when s.state = 'CREATED_OFFLINE' then null else s.updated_at end as synced_at,
    s.updated_at,
    s.last_error,
    s.reconciliation_status,
    s.reconciliation_approval_request_id,
    s.reconciled_by,
    s.reconciled_at
  from public.pos_offline_sales s
  where (p_state is null or s.state = p_state)
  order by s.created_at desc
  limit greatest(1, least(coalesce(p_limit, 200), 500));
end;
$$;


ALTER FUNCTION "public"."get_pos_offline_sales_dashboard"("p_state" "text", "p_limit" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_product_sales_quantity_from_movements"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("item_id" "text", "quantity_sold" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
begin
  if not public.is_staff() then
    raise exception 'not allowed';
  end if;

  return query
  select
    im.item_id::text as item_id,
    coalesce(sum(im.quantity), 0) as quantity_sold
  from public.inventory_movements im
  join public.orders o on o.id = (im.reference_id)::uuid
    and o.status = 'delivered'
  where im.movement_type = 'sale_out'
    and im.reference_table = 'orders'
    and im.occurred_at >= p_start_date
    and im.occurred_at <= p_end_date
    and (p_zone_id is null or coalesce(
      o.delivery_zone_id,
      case
        when nullif(o.data->>'deliveryZoneId','') is not null
             and (o.data->>'deliveryZoneId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
          then (o.data->>'deliveryZoneId')::uuid
        else null
      end
    ) = p_zone_id)
  group by im.item_id::text;
end;
$_$;


ALTER FUNCTION "public"."get_product_sales_quantity_from_movements"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_product_sales_quantity_from_movements"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid") IS 'ERP Audit: quantity_sold from inventory_movements (single source of truth) for product report merge';



CREATE OR REPLACE FUNCTION "public"."get_product_sales_report_v9"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid" DEFAULT NULL::"uuid", "p_invoice_only" boolean DEFAULT false) RETURNS TABLE("item_id" "text", "item_name" "jsonb", "unit_type" "text", "quantity_sold" numeric, "total_sales" numeric, "total_cost" numeric, "total_profit" numeric, "current_stock" numeric, "reserved_stock" numeric, "current_cost_price" numeric, "avg_inventory" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
begin
  if not public.is_staff() then
    raise exception 'not allowed';
  end if;

  return query
  with effective_orders as (
    select
      o.id,
      o.status,
      o.created_at,
      nullif(o.data->>'paidAt','')::timestamptz as paid_at,
      coalesce(nullif(o.data->>'paymentMethod', ''), '') as payment_method,
      case
        when p_invoice_only
          then nullif(o.data->'invoiceSnapshot'->>'issuedAt', '')::timestamptz
        else coalesce(
          nullif(o.data->'invoiceSnapshot'->>'issuedAt', '')::timestamptz,
          nullif(o.data->>'paidAt', '')::timestamptz,
          nullif(o.data->>'deliveredAt', '')::timestamptz,
          o.created_at
        )
      end as date_by,
      coalesce(
        o.delivery_zone_id,
        case
          when nullif(o.data->>'deliveryZoneId','') is not null
               and (o.data->>'deliveryZoneId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
            then (o.data->>'deliveryZoneId')::uuid
          else null
        end
      ) as zone_effective,
      o.data
    from public.orders o
    where (p_zone_id is null or coalesce(
      o.delivery_zone_id,
      case
        when nullif(o.data->>'deliveryZoneId','') is not null
             and (o.data->>'deliveryZoneId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
          then (o.data->>'deliveryZoneId')::uuid
        else null
      end
    ) = p_zone_id)
  ),
  sales_orders as (
    select
      eo.*,
      coalesce(
        nullif(eo.data->>'discountAmount','')::numeric,
        nullif(eo.data->>'discountTotal','')::numeric,
        nullif(eo.data->>'discount','')::numeric,
        0
      ) as discount_amount,
      coalesce(nullif(eo.data->>'subtotal','')::numeric, 0) as subtotal_amount
    from effective_orders eo
    where (
        eo.paid_at is not null
        or (eo.status = 'delivered' and eo.payment_method <> 'cash')
    )
      and eo.date_by >= p_start_date
      and eo.date_by <= p_end_date
  ),
  expanded_items as (
    select
      so.id as order_id,
      item as item,
      mi_res.resolved_id as resolved_item_id,
      mi_res.resolved_unit_type as resolved_unit_type,
      mi_res.resolved_name as resolved_name
    from sales_orders so
    cross join lateral jsonb_array_elements(
      case
        when p_invoice_only then
          case
            when jsonb_typeof(so.data->'invoiceSnapshot'->'items') = 'array'
                 and jsonb_array_length(so.data->'invoiceSnapshot'->'items') > 0 then so.data->'invoiceSnapshot'->'items'
            else '[]'::jsonb
          end
        else
          case
            when jsonb_typeof(so.data->'invoiceSnapshot'->'items') = 'array'
                 and jsonb_array_length(so.data->'invoiceSnapshot'->'items') > 0 then so.data->'invoiceSnapshot'->'items'
            when jsonb_typeof(so.data->'items') = 'array' then so.data->'items'
            else '[]'::jsonb
          end
      end
    ) as item
    left join lateral (
      select
        mi.id::text as resolved_id,
        mi.unit_type as resolved_unit_type,
        mi.data->'name' as resolved_name
      from public.menu_items mi
      where (
        (item->'name'->>'ar' is not null and mi.data->'name'->>'ar' = item->'name'->>'ar')
        or (item->'name'->>'en' is not null and mi.data->'name'->>'en' = item->'name'->>'en')
      )
      order by mi.updated_at desc
      limit 1
    ) as mi_res on true
  ),
  normalized_items as (
    select
      ei.order_id,
      coalesce(
        nullif(ei.item->>'itemId', ''),
        nullif(ei.item->>'id', ''),
        nullif(ei.item->>'menuItemId', ''),
        nullif(ei.resolved_item_id, '')
      ) as item_id_text,
      coalesce(ei.item->'name', ei.resolved_name) as item_name,
      coalesce(
        nullif(ei.item->>'unitType', ''),
        nullif(ei.item->>'unit', ''),
        nullif(ei.resolved_unit_type, ''),
        'piece'
      ) as unit_type,
      coalesce(nullif(ei.item->>'quantity', '')::numeric, 0) as quantity,
      coalesce(nullif(ei.item->>'weight', '')::numeric, 0) as weight,
      coalesce(nullif(ei.item->>'price', '')::numeric, 0) as price,
      coalesce(nullif(ei.item->>'pricePerUnit', '')::numeric, 0) as price_per_unit,
      ei.item->'selectedAddons' as addons,
      case
        when jsonb_typeof(ei.item->'selectedAddons') = 'object' then coalesce((
          select sum(
            coalesce((addon_value->'addon'->>'price')::numeric, 0) *
            coalesce((addon_value->>'quantity')::numeric, 0)
          )
          from jsonb_each(ei.item->'selectedAddons') as a(key, addon_value)
        ), 0)
        when jsonb_typeof(ei.item->'selectedAddons') = 'array' then coalesce((
          select sum(
            coalesce((addon_value->'addon'->>'price')::numeric, 0) *
            coalesce((addon_value->>'quantity')::numeric, 0)
          )
          from jsonb_array_elements(ei.item->'selectedAddons') as addon_value
        ), 0)
        else 0
      end as addons_total
    from expanded_items ei
  ),
  order_item_gross as (
    select
      ni.order_id,
      ni.item_id_text,
      max(ni.item_name::text) as any_name,
      max(ni.unit_type) as any_unit,
      sum(
        case
          when ni.unit_type in ('kg', 'gram') and ni.weight > 0
            then (ni.weight * greatest(ni.quantity, 1))
          else greatest(ni.quantity, 0)
        end
      ) as qty_sold,
      sum(
        (
          (
            case
              when ni.unit_type = 'gram'
                   and ni.price_per_unit > 0
                   and ni.weight > 0 then (ni.price_per_unit / 1000.0) * ni.weight
              when ni.unit_type in ('kg', 'gram')
                   and ni.weight > 0 then ni.price * ni.weight
              else ni.price
            end
            + ni.addons_total
          )
          *
          case
            when ni.unit_type in ('kg', 'gram') and ni.weight > 0
              then greatest(ni.quantity, 1)
            else greatest(ni.quantity, 0)
          end
        )
      ) as line_gross
    from normalized_items ni
    where nullif(ni.item_id_text, '') is not null
    group by ni.order_id, ni.item_id_text
  ),
  order_totals as (
    select
      so.id as order_id,
      coalesce(sum(oig.line_gross), 0) as items_gross_sum,
      max(so.discount_amount) as discount_amount,
      max(so.subtotal_amount) as subtotal_amount
    from sales_orders so
    left join order_item_gross oig on oig.order_id = so.id
    group by so.id
  ),
  order_scaling as (
    select
      ot.order_id,
      greatest(coalesce(ot.items_gross_sum, 0), 0) as items_gross_sum,
      greatest(coalesce(ot.subtotal_amount, 0), 0) as subtotal_amount,
      greatest(coalesce(ot.discount_amount, 0), 0) as discount_amount,
      greatest(
        case
          when coalesce(ot.subtotal_amount, 0) > 0 then ot.subtotal_amount
          else coalesce(ot.items_gross_sum, 0)
        end,
        0
      ) as base_amount,
      case
        when coalesce(ot.subtotal_amount, 0) > 0 and coalesce(ot.items_gross_sum, 0) > 0
          then (ot.subtotal_amount / ot.items_gross_sum)
        else 1
      end as scale_to_subtotal
    from order_totals ot
  ),
  order_item_net as (
    select
      oig.order_id,
      oig.item_id_text,
      max(oig.any_name) as any_name,
      max(oig.any_unit) as any_unit,
      sum(oig.qty_sold) as qty_sold,
      sum(
        greatest(
          (oig.line_gross * os.scale_to_subtotal)
          - (least(os.discount_amount, os.base_amount) * ((oig.line_gross * os.scale_to_subtotal) / nullif(os.base_amount, 0))),
          0
        )
      ) as net_sales
    from order_item_gross oig
    join order_scaling os on os.order_id = oig.order_id
    group by oig.order_id, oig.item_id_text
  ),
  sales_lines as (
    select
      oin.item_id_text,
      max(oin.any_name) as any_name,
      max(oin.any_unit) as any_unit,
      sum(coalesce(oin.qty_sold, 0)) as qty_sold,
      sum(coalesce(oin.net_sales, 0)) as net_sales
    from order_item_net oin
    group by oin.item_id_text
  ),
  returns_base as (
    select
      sr.id as return_id,
      sr.order_id,
      sr.total_refund_amount as return_amount,
      sr.items as items,
      o.data as order_data,
      coalesce(nullif((o.data->>'discountAmount')::numeric, null), 0) as discount_amount,
      coalesce(nullif((o.data->>'subtotal')::numeric, null), 0) as subtotal_amount
    from public.sales_returns sr
    join public.orders o on o.id = sr.order_id
    where sr.status = 'completed'
      and sr.return_date >= p_start_date
      and sr.return_date <= p_end_date
      and (p_zone_id is null or coalesce(
        o.delivery_zone_id,
        case
          when nullif(o.data->>'deliveryZoneId','') is not null
               and (o.data->>'deliveryZoneId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
            then (o.data->>'deliveryZoneId')::uuid
          else null
        end
      ) = p_zone_id)
  ),
  returns_items as (
    select
      rb.return_id,
      rb.order_id,
      rb.return_amount,
      coalesce(nullif(ri->>'itemId',''), nullif(ri->>'id','')) as item_id_text,
      coalesce(nullif(ri->>'quantity','')::numeric, 0) as qty_returned
    from returns_base rb
    cross join lateral jsonb_array_elements(coalesce(rb.items, '[]'::jsonb)) as ri
    where coalesce(nullif(ri->>'quantity','')::numeric, 0) > 0
  ),
  return_expanded_items as (
    select
      rb.order_id,
      item as item,
      mi_res.resolved_id as resolved_item_id,
      mi_res.resolved_unit_type as resolved_unit_type
    from returns_base rb
    cross join lateral jsonb_array_elements(
      case
        when jsonb_typeof(rb.order_data->'invoiceSnapshot'->'items') = 'array'
             and jsonb_array_length(rb.order_data->'invoiceSnapshot'->'items') > 0 then rb.order_data->'invoiceSnapshot'->'items'
        when jsonb_typeof(rb.order_data->'items') = 'array' then rb.order_data->'items'
        else '[]'::jsonb
      end
    ) as item
    left join lateral (
      select
        mi.id::text as resolved_id,
        mi.unit_type as resolved_unit_type
      from public.menu_items mi
      where (
        (item->'name'->>'ar' is not null and mi.data->'name'->>'ar' = item->'name'->>'ar')
        or (item->'name'->>'en' is not null and mi.data->'name'->>'en' = item->'name'->>'en')
      )
      order by mi.updated_at desc
      limit 1
    ) as mi_res on true
  ),
  normalized_return_items as (
    select
      rei.order_id,
      coalesce(
        nullif(rei.item->>'itemId', ''),
        nullif(rei.item->>'id', ''),
        nullif(rei.item->>'menuItemId', ''),
        nullif(rei.resolved_item_id, '')
      ) as item_id_text,
      coalesce(nullif(rei.item->>'unitType', ''), nullif(rei.item->>'unit', ''), nullif(rei.resolved_unit_type, ''), 'piece') as unit_type,
      coalesce(nullif(rei.item->>'quantity', '')::numeric, 0) as quantity,
      coalesce(nullif(rei.item->>'weight', '')::numeric, 0) as weight,
      coalesce(nullif(rei.item->>'price', '')::numeric, 0) as price,
      coalesce(nullif(rei.item->>'pricePerUnit', '')::numeric, 0) as price_per_unit,
      case
        when jsonb_typeof(rei.item->'selectedAddons') = 'object' then coalesce((
          select sum(
            coalesce((addon_value->'addon'->>'price')::numeric, 0) *
            coalesce((addon_value->>'quantity')::numeric, 0)
          )
          from jsonb_each(rei.item->'selectedAddons') as a(key, addon_value)
        ), 0)
        when jsonb_typeof(rei.item->'selectedAddons') = 'array' then coalesce((
          select sum(
            coalesce((addon_value->'addon'->>'price')::numeric, 0) *
            coalesce((addon_value->>'quantity')::numeric, 0)
          )
          from jsonb_array_elements(rei.item->'selectedAddons') as addon_value
        ), 0)
        else 0
      end as addons_total
    from return_expanded_items rei
  ),
  return_order_item_gross as (
    select
      nri.order_id,
      nri.item_id_text,
      sum(
        case
          when nri.unit_type in ('kg', 'gram') and nri.weight > 0
            then (nri.weight * greatest(nri.quantity, 1))
          else greatest(nri.quantity, 0)
        end
      ) as qty_stock,
      sum(
        (
          (
            case
              when nri.unit_type = 'gram'
                   and nri.price_per_unit > 0
                   and nri.weight > 0 then (nri.price_per_unit / 1000.0) * nri.weight
              when nri.unit_type in ('kg', 'gram')
                   and nri.weight > 0 then nri.price * nri.weight
              else nri.price
            end
            + nri.addons_total
          )
          *
          case
            when nri.unit_type in ('kg', 'gram') and nri.weight > 0
              then greatest(nri.quantity, 1)
            else greatest(nri.quantity, 0)
          end
        )
      ) as line_gross
    from normalized_return_items nri
    where nullif(nri.item_id_text,'') is not null
    group by nri.order_id, nri.item_id_text
  ),
  return_order_totals as (
    select
      rb.order_id,
      coalesce(sum(roig.line_gross), 0) as items_gross_sum,
      max(rb.discount_amount) as discount_amount,
      max(rb.subtotal_amount) as subtotal_amount
    from returns_base rb
    left join return_order_item_gross roig on roig.order_id = rb.order_id
    group by rb.order_id
  ),
  return_order_scaling as (
    select
      rot.order_id,
      greatest(coalesce(rot.items_gross_sum, 0), 0) as items_gross_sum,
      greatest(coalesce(rot.subtotal_amount, 0), 0) as subtotal_amount,
      greatest(coalesce(rot.discount_amount, 0), 0) as discount_amount,
      greatest(
        case
          when coalesce(rot.subtotal_amount, 0) > 0 then rot.subtotal_amount
          else coalesce(rot.items_gross_sum, 0)
        end,
        0
      ) as base_amount,
      case
        when coalesce(rot.subtotal_amount, 0) > 0 and coalesce(rot.items_gross_sum, 0) > 0
          then (rot.subtotal_amount / rot.items_gross_sum)
        else 1
      end as scale_to_subtotal
    from return_order_totals rot
  ),
  return_order_item_net as (
    select
      roig.order_id,
      roig.item_id_text,
      roig.qty_stock,
      greatest(
        (roig.line_gross * ros.scale_to_subtotal)
        - (least(ros.discount_amount, ros.base_amount) * ((roig.line_gross * ros.scale_to_subtotal) / nullif(ros.base_amount, 0))),
        0
      ) as net_sales_amount
    from return_order_item_gross roig
    join return_order_scaling ros on ros.order_id = roig.order_id
  ),
  return_item_gross_value as (
    select
      ri.return_id,
      ri.order_id,
      ri.item_id_text,
      ri.qty_returned,
      ri.return_amount,
      case
        when roin.qty_stock > 0
          then (ri.qty_returned * (roin.net_sales_amount / roin.qty_stock))
        else 0
      end as gross_value
    from returns_items ri
    left join return_order_item_net roin
      on roin.order_id = ri.order_id
     and roin.item_id_text = ri.item_id_text
  ),
  return_scaling as (
    select
      rigv.return_id,
      max(rigv.return_amount) as return_amount,
      sum(rigv.gross_value) as gross_value_sum
    from return_item_gross_value rigv
    group by rigv.return_id
  ),
  returns_sales as (
    select
      rigv.item_id_text,
      sum(rigv.qty_returned) as qty_returned,
      sum(
        case
          when rs.gross_value_sum > 0
            then rigv.gross_value * (rs.return_amount / rs.gross_value_sum)
          else 0
        end
      ) as returned_sales
    from return_item_gross_value rigv
    join return_scaling rs on rs.return_id = rigv.return_id
    group by rigv.item_id_text
  ),
  returns_cost as (
    select
      im.item_id::text as item_id_text,
      sum(im.quantity) as qty_returned_cost,
      sum(im.total_cost) as returned_cost
    from public.inventory_movements im
    where im.reference_table = 'sales_returns'
      and im.movement_type = 'return_in'
      and im.occurred_at >= p_start_date
      and im.occurred_at <= p_end_date
      and (
        p_zone_id is null or exists (
          select 1 from public.orders o
          where o.id::text = (im.data->>'orderId')
            and coalesce(
              o.delivery_zone_id,
              case
                when nullif(o.data->>'deliveryZoneId','') is not null
                     and (o.data->>'deliveryZoneId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
                  then (o.data->>'deliveryZoneId')::uuid
                else null
              end
            ) = p_zone_id
        )
      )
    group by im.item_id::text
  ),
  cogs_gross as (
    select
      oic.item_id::text as item_id_text,
      sum(oic.total_cost) as gross_cost
    from public.order_item_cogs oic
    join sales_orders so on so.id = oic.order_id
    group by oic.item_id::text
  ),
  period_movements as (
    select
      im.item_id::text as item_id_text,
      sum(case when im.movement_type in ('purchase_in','adjust_in','return_in') then im.quantity else 0 end)
      -
      sum(case when im.movement_type in ('sale_out','wastage_out','adjust_out','return_out') then im.quantity else 0 end)
      as net_qty_period
    from public.inventory_movements im
    where im.occurred_at >= p_start_date
      and im.occurred_at <= p_end_date
    group by im.item_id::text
  ),
  item_keys as (
    select item_id_text from sales_lines
    union
    select item_id_text from returns_sales
    union
    select item_id_text from returns_cost
    union
    select item_id_text from cogs_gross
  )
  select
    k.item_id_text as item_id,
    coalesce(mi.data->'name', sl.any_name::jsonb, jsonb_build_object('ar', k.item_id_text)) as item_name,
    coalesce(nullif(mi.unit_type, ''), nullif(sl.any_unit, ''), 'piece') as unit_type,
    greatest(coalesce(sl.qty_sold, 0) - coalesce(rs.qty_returned, 0), 0) as quantity_sold,
    greatest(coalesce(sl.net_sales, 0) - coalesce(rs.returned_sales, 0), 0) as total_sales,
    greatest(coalesce(cg.gross_cost, 0) - coalesce(rc.returned_cost, 0), 0) as total_cost,
    (
      greatest(coalesce(sl.net_sales, 0) - coalesce(rs.returned_sales, 0), 0)
      - greatest(coalesce(cg.gross_cost, 0) - coalesce(rc.returned_cost, 0), 0)
    ) as total_profit,
    coalesce(sm.available_quantity, 0) as current_stock,
    coalesce(sm.reserved_quantity, 0) as reserved_stock,
    coalesce(sm.avg_cost, mi.cost_price, 0) as current_cost_price,
    (
      (
        greatest(
          coalesce(sm.available_quantity, 0) - coalesce(pm.net_qty_period, 0),
          0
        )
        + coalesce(sm.available_quantity, 0)
      ) / 2.0
    ) as avg_inventory
  from item_keys k
  left join public.menu_items mi on mi.id::text = k.item_id_text
  left join sales_lines sl on sl.item_id_text = k.item_id_text
  left join returns_sales rs on rs.item_id_text = k.item_id_text
  left join returns_cost rc on rc.item_id_text = k.item_id_text
  left join cogs_gross cg on cg.item_id_text = k.item_id_text
  left join public.stock_management sm on sm.item_id::text = k.item_id_text
  left join period_movements pm on pm.item_id_text = k.item_id_text
  where (coalesce(sl.qty_sold, 0) + coalesce(rs.qty_returned, 0) + coalesce(rc.qty_returned_cost, 0)) > 0
  order by total_sales desc;
end;
$_$;


ALTER FUNCTION "public"."get_product_sales_report_v9"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_promotion_expense_drilldown"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_min_amount" numeric DEFAULT 0) RETURNS TABLE("entry_date" timestamp with time zone, "journal_entry_id" "uuid", "order_id" "uuid", "invoice_number" "text", "debit" numeric, "credit" numeric, "amount" numeric, "promotion_usage_ids" "uuid"[], "promotion_ids" "uuid"[])
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_actor uuid;
begin
  v_actor := auth.uid();
  if v_actor is null then
    raise exception 'not authenticated';
  end if;
  if not public.has_admin_permission('accounting.view') then
    raise exception 'not authorized';
  end if;

  return query
  with promo_usage as (
    select
      pu.order_id,
      array_agg(pu.id) as usage_ids,
      array_agg(distinct pu.promotion_id) as promo_ids
    from public.promotion_usage pu
    group by pu.order_id
  ),
  promo_account as (
    select coa.id
    from public.chart_of_accounts coa
    where coa.code = '6150' and coa.is_active = true
    limit 1
  )
  select
    je.entry_date,
    je.id as journal_entry_id,
    (je.source_id)::uuid as order_id,
    coalesce(nullif(o.data->'invoiceSnapshot'->>'invoiceNumber',''), nullif(o.invoice_number,'')) as invoice_number,
    jl.debit,
    jl.credit,
    (jl.debit - jl.credit) as amount,
    coalesce(pu.usage_ids, '{}'::uuid[]) as promotion_usage_ids,
    coalesce(pu.promo_ids, '{}'::uuid[]) as promotion_ids
  from public.journal_entries je
  join public.journal_lines jl on jl.journal_entry_id = je.id
  join promo_account pa on pa.id = jl.account_id
  left join public.orders o on o.id = (je.source_id)::uuid
  left join promo_usage pu on pu.order_id = (je.source_id)::uuid
  where je.source_table = 'orders'
    and je.source_event = 'delivered'
    and je.entry_date >= p_start_date
    and je.entry_date <= p_end_date
    and abs(jl.debit - jl.credit) >= coalesce(p_min_amount, 0)
  order by je.entry_date desc, je.id desc;
end;
$$;


ALTER FUNCTION "public"."get_promotion_expense_drilldown"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_min_amount" numeric) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_promotion_performance"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_promotion_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("promotion_id" "uuid", "promotion_name" "text", "usage_count" bigint, "bundles_sold" numeric, "gross_before_promo" numeric, "net_after_promo" numeric, "promotion_expense" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if not public.can_view_sales_reports() then
    raise exception 'not allowed';
  end if;

  return query
  select
    p.id as promotion_id,
    p.name as promotion_name,
    count(*) as usage_count,
    public._money_round(sum(coalesce(u.bundle_qty, 0)), 6) as bundles_sold,
    public._money_round(sum(coalesce(nullif((u.snapshot->>'computedOriginalTotal')::numeric, null), 0))) as gross_before_promo,
    public._money_round(sum(coalesce(nullif((u.snapshot->>'finalTotal')::numeric, null), 0))) as net_after_promo,
    public._money_round(sum(coalesce(nullif((u.snapshot->>'promotionExpense')::numeric, null), 0))) as promotion_expense
  from public.promotion_usage u
  join public.promotions p on p.id = u.promotion_id
  left join public.orders o on o.id = u.order_id
  where (p_promotion_id is null or u.promotion_id = p_promotion_id)
    and u.created_at >= p_start_date
    and u.created_at <= p_end_date
    and (o.id is null or o.status = 'delivered')
  group by p.id, p.name
  order by promotion_expense desc, net_after_promo desc;
end;
$$;


ALTER FUNCTION "public"."get_promotion_performance"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_promotion_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_promotion_usage_drilldown"("p_promotion_id" "uuid", "p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone) RETURNS TABLE("promotion_usage_id" "uuid", "order_id" "uuid", "invoice_number" "text", "channel" "text", "created_at" timestamp with time zone, "computed_original_total" numeric, "final_total" numeric, "promotion_expense" numeric, "journal_entry_id" "uuid")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_actor uuid;
begin
  v_actor := auth.uid();
  if v_actor is null then
    raise exception 'not authenticated';
  end if;
  if not (public.has_admin_permission('reports.view') or public.has_admin_permission('accounting.view')) then
    raise exception 'not authorized';
  end if;

  return query
  select
    pu.id as promotion_usage_id,
    pu.order_id,
    coalesce(nullif(o.data->'invoiceSnapshot'->>'invoiceNumber',''), nullif(o.invoice_number,'')) as invoice_number,
    pu.channel,
    pu.created_at,
    coalesce(nullif(pu.snapshot->>'computedOriginalTotal','')::numeric, 0) as computed_original_total,
    coalesce(nullif(pu.snapshot->>'finalTotal','')::numeric, 0) as final_total,
    coalesce(nullif(pu.snapshot->>'promotionExpense','')::numeric, 0) as promotion_expense,
    je.id as journal_entry_id
  from public.promotion_usage pu
  left join public.orders o on o.id = pu.order_id
  left join public.journal_entries je
    on je.source_table = 'orders'
   and je.source_id = pu.order_id::text
   and je.source_event = 'delivered'
  where pu.promotion_id = p_promotion_id
    and pu.created_at >= p_start_date
    and pu.created_at <= p_end_date
  order by pu.created_at desc;
end;
$$;


ALTER FUNCTION "public"."get_promotion_usage_drilldown"("p_promotion_id" "uuid", "p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_promotions_admin"() RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_result jsonb;
begin
  if not public.is_admin() then
    raise exception 'not allowed';
  end if;

  select coalesce(jsonb_agg(row_to_json(t)), '[]'::jsonb)
  into v_result
  from (
    select
      p.id,
      p.name,
      p.start_at,
      p.end_at,
      p.is_active,
      p.discount_mode,
      p.fixed_total,
      p.percent_off,
      p.display_original_total,
      p.max_uses,
      p.stack_policy,
      p.exclusive_with_coupon,
      p.requires_approval,
      p.approval_status,
      p.approval_request_id,
      p.data,
      p.created_by,
      p.created_at,
      p.updated_at,
      coalesce((
        select jsonb_agg(jsonb_build_object(
          'id', pi.id,
          'itemId', pi.item_id,
          'quantity', pi.quantity,
          'sortOrder', pi.sort_order
        ) order by pi.sort_order asc, pi.created_at asc, pi.id asc)
        from public.promotion_items pi
        where pi.promotion_id = p.id
      ), '[]'::jsonb) as items
    from public.promotions p
    order by p.created_at desc, p.id desc
  ) t;

  return v_result;
end;
$$;


ALTER FUNCTION "public"."get_promotions_admin"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_sales_by_category"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid" DEFAULT NULL::"uuid", "p_invoice_only" boolean DEFAULT false) RETURNS TABLE("category_name" "text", "total_sales" numeric, "quantity_sold" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
begin
  if not public.is_staff() then
    raise exception 'not allowed';
  end if;

  return query
  with effective_orders as (
    select
      o.data,
      o.status,
      nullif(o.data->>'paidAt', '')::timestamptz as paid_at,
      case
        when p_invoice_only
          then nullif(o.data->'invoiceSnapshot'->>'issuedAt', '')::timestamptz
        else coalesce(
          nullif(o.data->'invoiceSnapshot'->>'issuedAt', '')::timestamptz,
          nullif(o.data->>'paidAt', '')::timestamptz,
          nullif(o.data->>'deliveredAt', '')::timestamptz,
          o.created_at
        )
      end as date_by,
      coalesce(
        o.delivery_zone_id,
        case
          when nullif(o.data->>'deliveryZoneId','') is not null
               and (o.data->>'deliveryZoneId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
            then (o.data->>'deliveryZoneId')::uuid
          else null
        end
      ) as zone_effective
    from public.orders o
    where (p_zone_id is null or coalesce(
      o.delivery_zone_id,
      case
        when nullif(o.data->>'deliveryZoneId','') is not null
             and (o.data->>'deliveryZoneId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
          then (o.data->>'deliveryZoneId')::uuid
        else null
      end
    ) = p_zone_id)
  ),
  filtered_orders as (
    select *
    from effective_orders eo
    where (eo.status = 'delivered' or eo.paid_at is not null)
      and eo.date_by >= p_start_date
      and eo.date_by <= p_end_date
  ),
  expanded_items as (
    select
      jsonb_array_elements(
        case
          when p_invoice_only then
            case
              when jsonb_typeof(fo.data->'invoiceSnapshot'->'items') = 'array' then fo.data->'invoiceSnapshot'->'items'
              else '[]'::jsonb
            end
          else
            case
              when jsonb_typeof(fo.data->'invoiceSnapshot'->'items') = 'array' then fo.data->'invoiceSnapshot'->'items'
              when jsonb_typeof(fo.data->'items') = 'array' then fo.data->'items'
              else '[]'::jsonb
            end
        end
      ) as item
    from filtered_orders fo
  ),
  lines as (
    select
      coalesce(
        nullif(item->>'category',''),
        nullif(item->>'categoryId',''),
        'Uncategorized'
      ) as category_key,
      nullif(item->>'categoryName','') as category_name_raw,
      coalesce((item->>'quantity')::numeric, 0) as quantity,
      coalesce((item->>'weight')::numeric, 0) as weight,
      coalesce(item->>'unitType', item->>'unit', 'piece') as unit_type,
      coalesce((item->>'price')::numeric, 0) as price,
      coalesce((item->>'pricePerUnit')::numeric, 0) as price_per_unit,
      item->'selectedAddons' as addons
    from expanded_items
  ),
  computed_lines as (
    select
      l.category_key,
      l.category_name_raw,
      (
        case
          when l.unit_type in ('kg', 'gram') and l.weight > 0
            then (l.weight * greatest(l.quantity, 1))
          else greatest(l.quantity, 0)
        end
      ) as qty_sold,
      (
        (
          (
            case
              when l.unit_type = 'gram'
                   and l.price_per_unit > 0
                   and l.weight > 0 then (l.price_per_unit / 1000.0) * l.weight
              when l.unit_type in ('kg', 'gram')
                   and l.weight > 0 then l.price * l.weight
              else l.price
            end
            +
            coalesce((
              select sum(
                coalesce((addon_value->'addon'->>'price')::numeric, 0) *
                coalesce((addon_value->>'quantity')::numeric, 0)
              )
              from jsonb_each(l.addons) as a(key, addon_value)
            ), 0)
          )
          *
          case
            when l.unit_type in ('kg', 'gram') and l.weight > 0
              then greatest(l.quantity, 1)
            else greatest(l.quantity, 0)
          end
        )
      ) as sales_amount
    from lines l
  ),
  labeled as (
    select
      coalesce(
        nullif(cl.category_name_raw, ''),
        nullif(ic.data->'name'->>'ar', ''),
        nullif(ic.data->'name'->>'en', ''),
        case when cl.category_key = 'Uncategorized' then ' ' else cl.category_key end
      ) as category_name,
      cl.qty_sold,
      cl.sales_amount
    from computed_lines cl
    left join public.item_categories ic on ic.key = cl.category_key
  )
  select
    l.category_name,
    coalesce(sum(l.sales_amount), 0) as total_sales,
    coalesce(sum(l.qty_sold), 0) as quantity_sold
  from labeled l
  group by l.category_name
  order by 2 desc;
end;
$_$;


ALTER FUNCTION "public"."get_sales_by_category"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_sales_report_orders"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid" DEFAULT NULL::"uuid", "p_invoice_only" boolean DEFAULT false, "p_search" "text" DEFAULT NULL::"text", "p_limit" integer DEFAULT 500, "p_offset" integer DEFAULT 0) RETURNS TABLE("id" "uuid", "status" "text", "date_by" timestamp with time zone, "total" numeric, "payment_method" "text", "order_source" "text", "customer_name" "text", "invoice_number" "text", "invoice_issued_at" timestamp with time zone, "delivery_zone_id" "uuid", "delivery_zone_name" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
begin
  return query
  with effective_orders as (
    select
      o.id,
      o.status::text as status,
      nullif(o.data->>'deliveredAt', '')::timestamptz as delivered_at,
      nullif(o.data->'invoiceSnapshot'->>'issuedAt', '')::timestamptz as invoice_issued_at,
      case
        when p_invoice_only
          then nullif(o.data->'invoiceSnapshot'->>'issuedAt', '')::timestamptz
        else coalesce(
          nullif(o.data->'invoiceSnapshot'->>'issuedAt', '')::timestamptz,
          nullif(o.data->>'deliveredAt', '')::timestamptz,
          o.created_at
        )
      end as date_by,
      coalesce(nullif((o.data->>'total')::numeric, null), 0) as total,
      coalesce(nullif(o.data->>'paymentMethod',''), 'unknown') as payment_method,
      coalesce(nullif(o.data->>'orderSource',''), '') as order_source,
      coalesce(nullif(o.data->>'customerName',''), '') as customer_name,
      coalesce(
        nullif(o.data->'invoiceSnapshot'->>'invoiceNumber',''),
        nullif(o.data->>'invoiceNumber','')
      ) as invoice_number,
      coalesce(
        o.delivery_zone_id,
        case
          when nullif(o.data->>'deliveryZoneId','') is not null
               and (o.data->>'deliveryZoneId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
            then (o.data->>'deliveryZoneId')::uuid
          else null
        end
      ) as zone_effective
    from public.orders o
    where (p_zone_id is null or coalesce(
      o.delivery_zone_id,
      case
        when nullif(o.data->>'deliveryZoneId','') is not null
             and (o.data->>'deliveryZoneId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
          then (o.data->>'deliveryZoneId')::uuid
        else null
      end
    ) = p_zone_id)
  )
  select
    eo.id,
    eo.status,
    eo.date_by,
    eo.total,
    eo.payment_method,
    eo.order_source,
    eo.customer_name,
    eo.invoice_number,
    eo.invoice_issued_at,
    eo.zone_effective as delivery_zone_id,
    coalesce(dz.name, '') as delivery_zone_name
  from effective_orders eo
  left join public.delivery_zones dz on dz.id = eo.zone_effective
  where eo.status = 'delivered'
    and (not p_invoice_only or eo.invoice_issued_at is not null)
    and eo.date_by >= p_start_date
    and eo.date_by <= p_end_date
    and (
      p_search is null
      or nullif(trim(p_search),'') is null
      or right(eo.id::text, 6) ilike '%' || trim(p_search) || '%'
      or coalesce(eo.invoice_number,'') ilike '%' || trim(p_search) || '%'
      or coalesce(eo.customer_name,'') ilike '%' || trim(p_search) || '%'
      or coalesce(eo.payment_method,'') ilike '%' || trim(p_search) || '%'
      or coalesce(dz.name,'') ilike '%' || trim(p_search) || '%'
    )
  order by eo.date_by desc
  limit greatest(1, least(p_limit, 20000))
  offset greatest(0, p_offset);
end;
$_$;


ALTER FUNCTION "public"."get_sales_report_orders"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean, "p_search" "text", "p_limit" integer, "p_offset" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_sales_report_summary"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid" DEFAULT NULL::"uuid", "p_invoice_only" boolean DEFAULT false) RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
declare
  v_total_collected numeric := 0;
  v_total_tax numeric := 0;
  v_total_delivery numeric := 0;
  v_total_discounts numeric := 0;
  v_gross_subtotal numeric := 0;
  v_total_orders integer := 0;
  v_cancelled_orders integer := 0;
  v_delivered_orders integer := 0;
  v_total_returns numeric := 0;
  v_total_cogs numeric := 0;
  v_total_returns_cogs numeric := 0;
  v_total_wastage numeric := 0;
  v_total_expenses numeric := 0;
  v_total_delivery_cost numeric := 0;
  v_out_for_delivery integer := 0;
  v_in_store integer := 0;
  v_online integer := 0;
  v_tax_refunds numeric := 0;
  v_result json;
begin
  if not public.is_staff() then
    raise exception 'not allowed';
  end if;

  with effective_orders as (
    select
      o.id,
      o.status,
      o.created_at,
      coalesce(nullif(o.data->>'paymentMethod', ''), '') as payment_method,
      nullif(o.data->>'paidAt', '')::timestamptz as paid_at,
      case
        when p_invoice_only
          then nullif(o.data->'invoiceSnapshot'->>'issuedAt', '')::timestamptz
        else coalesce(
          nullif(o.data->'invoiceSnapshot'->>'issuedAt', '')::timestamptz,
          nullif(o.data->>'paidAt', '')::timestamptz,
          nullif(o.data->>'deliveredAt', '')::timestamptz,
          o.created_at
        )
      end as date_by,
      coalesce(nullif((o.data->>'total')::numeric, null), 0) as total,
      coalesce(nullif((o.data->>'taxAmount')::numeric, null), 0) as tax_amount,
      coalesce(nullif((o.data->>'deliveryFee')::numeric, null), 0) as delivery_fee,
      coalesce(nullif((o.data->>'discountAmount')::numeric, null), 0) as discount_amount,
      coalesce(nullif((o.data->>'subtotal')::numeric, null), 0) as subtotal,
      coalesce(
        o.delivery_zone_id,
        case
          when nullif(o.data->>'deliveryZoneId','') is not null
               and (o.data->>'deliveryZoneId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
            then (o.data->>'deliveryZoneId')::uuid
          else null
        end
      ) as zone_effective
    from public.orders o
    where (p_zone_id is null or coalesce(
      o.delivery_zone_id,
      case
        when nullif(o.data->>'deliveryZoneId','') is not null
             and (o.data->>'deliveryZoneId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
          then (o.data->>'deliveryZoneId')::uuid
        else null
      end
    ) = p_zone_id)
  )
  select
    coalesce(sum(eo.total), 0),
    coalesce(sum(eo.tax_amount), 0),
    coalesce(sum(eo.delivery_fee), 0),
    coalesce(sum(eo.discount_amount), 0),
    coalesce(sum(eo.subtotal), 0),
    count(*),
    count(*) filter (where eo.status = 'delivered')
  into
    v_total_collected,
    v_total_tax,
    v_total_delivery,
    v_total_discounts,
    v_gross_subtotal,
    v_total_orders,
    v_delivered_orders
  from effective_orders eo
  where (
      eo.paid_at is not null
      or (eo.status = 'delivered' and eo.payment_method <> 'cash')
  )
    and eo.date_by >= p_start_date
    and eo.date_by <= p_end_date;

  with effective_orders as (
    select
      o.id,
      o.status,
      case
        when p_invoice_only
          then nullif(o.data->'invoiceSnapshot'->>'issuedAt', '')::timestamptz
        else coalesce(
          nullif(o.data->'invoiceSnapshot'->>'issuedAt', '')::timestamptz,
          nullif(o.data->>'paidAt', '')::timestamptz,
          nullif(o.data->>'deliveredAt', '')::timestamptz,
          o.created_at
        )
      end as date_by,
      coalesce(
        o.delivery_zone_id,
        case
          when nullif(o.data->>'deliveryZoneId','') is not null
               and (o.data->>'deliveryZoneId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
            then (o.data->>'deliveryZoneId')::uuid
          else null
        end
      ) as zone_effective
    from public.orders o
    where (p_zone_id is null or coalesce(
      o.delivery_zone_id,
      case
        when nullif(o.data->>'deliveryZoneId','') is not null
             and (o.data->>'deliveryZoneId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
          then (o.data->>'deliveryZoneId')::uuid
        else null
      end
    ) = p_zone_id)
  )
  select count(*)
  into v_cancelled_orders
  from effective_orders eo
  where eo.status = 'cancelled'
    and eo.date_by >= p_start_date
    and eo.date_by <= p_end_date;

  with returns_base as (
    select
      coalesce(nullif((o.data->>'subtotal')::numeric, null), 0) as order_subtotal,
      coalesce(nullif((o.data->>'discountAmount')::numeric, null), 0) as order_discount,
      greatest(
        coalesce(nullif((o.data->>'subtotal')::numeric, null), 0)
        - coalesce(nullif((o.data->>'discountAmount')::numeric, null), 0),
        0
      ) as order_net_subtotal,
      coalesce(nullif((o.data->>'taxAmount')::numeric, null), 0) as order_tax,
      coalesce(sum(coalesce(nullif((i->>'quantity')::numeric, null), 0) * coalesce(nullif((i->>'unitPrice')::numeric, null), 0)), 0) as return_subtotal,
      coalesce(sum(sr.total_refund_amount), 0) as total_refund_amount
    from public.sales_returns sr
    join public.orders o on o.id::text = sr.order_id::text
    cross join lateral jsonb_array_elements(coalesce(sr.items, '[]'::jsonb)) i
    where sr.status = 'completed'
      and sr.return_date >= p_start_date
      and sr.return_date <= p_end_date
      and (p_zone_id is null or coalesce(
        o.delivery_zone_id,
        case
          when nullif(o.data->>'deliveryZoneId','') is not null
               and (o.data->>'deliveryZoneId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
            then (o.data->>'deliveryZoneId')::uuid
          else null
        end
      ) = p_zone_id)
    group by o.id, o.data
  )
  select
    coalesce(sum(total_refund_amount), 0),
    coalesce(sum(
      case
        when order_net_subtotal > 0 and order_tax > 0
          then least(order_tax, (return_subtotal / order_net_subtotal) * order_tax)
        else 0
      end
    ), 0)
  into v_total_returns, v_tax_refunds
  from returns_base;

  v_total_tax := greatest(v_total_tax - v_tax_refunds, 0);

  with effective_orders as (
    select
      o.id,
      o.status,
      coalesce(nullif(o.data->>'paymentMethod', ''), '') as payment_method,
      nullif(o.data->>'paidAt', '')::timestamptz as paid_at,
      case
        when p_invoice_only
          then nullif(o.data->'invoiceSnapshot'->>'issuedAt', '')::timestamptz
        else coalesce(
          nullif(o.data->'invoiceSnapshot'->>'issuedAt', '')::timestamptz,
          nullif(o.data->>'paidAt', '')::timestamptz,
          nullif(o.data->>'deliveredAt', '')::timestamptz,
          o.created_at
        )
      end as date_by
    from public.orders o
    where (p_zone_id is null or coalesce(
      o.delivery_zone_id,
      case
        when nullif(o.data->>'deliveryZoneId','') is not null
             and (o.data->>'deliveryZoneId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
          then (o.data->>'deliveryZoneId')::uuid
        else null
      end
    ) = p_zone_id)
  )
  select coalesce(sum(oic.total_cost), 0)
  into v_total_cogs
  from public.order_item_cogs oic
  join effective_orders eo on oic.order_id = eo.id
  where (
      eo.paid_at is not null
      or (eo.status = 'delivered' and eo.payment_method <> 'cash')
  )
    and eo.date_by >= p_start_date
    and eo.date_by <= p_end_date;

  select coalesce(sum(im.total_cost), 0)
  into v_total_returns_cogs
  from public.inventory_movements im
  where im.reference_table = 'sales_returns'
    and im.movement_type = 'return_in'
    and im.occurred_at >= p_start_date
    and im.occurred_at <= p_end_date
    and (
      p_zone_id is null or exists (
        select 1 from public.orders o
        where o.id::text = (im.data->>'orderId') and coalesce(
          o.delivery_zone_id,
          case
            when nullif(o.data->>'deliveryZoneId','') is not null
                 and (o.data->>'deliveryZoneId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
              then (o.data->>'deliveryZoneId')::uuid
            else null
          end
        ) = p_zone_id
      )
    );

  v_total_cogs := greatest(v_total_cogs - v_total_returns_cogs, 0);

  if p_zone_id is null then
    select coalesce(sum(quantity * cost_at_time), 0)
    into v_total_wastage
    from public.stock_wastage
    where created_at >= p_start_date and created_at <= p_end_date;

    select coalesce(sum(amount), 0)
    into v_total_expenses
    from public.expenses
    where date >= p_start_date::date and date <= p_end_date::date;
  else
    v_total_wastage := 0;
    v_total_expenses := 0;
  end if;

  if to_regclass('public.delivery_costs') is not null then
    select coalesce(sum(dc.cost_amount), 0)
    into v_total_delivery_cost
    from public.delivery_costs dc
    where dc.occurred_at >= p_start_date
      and dc.occurred_at <= p_end_date
      and (
        p_zone_id is null or exists (
          select 1 from public.orders o
          where o.id = dc.order_id and coalesce(
            o.delivery_zone_id,
            case
              when nullif(o.data->>'deliveryZoneId','') is not null
                   and (o.data->>'deliveryZoneId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
                then (o.data->>'deliveryZoneId')::uuid
              else null
            end
          ) = p_zone_id
        )
      );
  else
    v_total_delivery_cost := 0;
  end if;

  with effective_orders as (
    select
      o.id,
      o.status,
      o.created_at,
      coalesce(nullif(o.data->>'orderSource', ''), '') as order_source,
      case
        when p_invoice_only
          then nullif(o.data->'invoiceSnapshot'->>'issuedAt', '')::timestamptz
        else coalesce(
          nullif(o.data->'invoiceSnapshot'->>'issuedAt', '')::timestamptz,
          nullif(o.data->>'paidAt', '')::timestamptz,
          nullif(o.data->>'deliveredAt', '')::timestamptz,
          o.created_at
        )
      end as date_by,
      o.delivery_zone_id
    from public.orders o
    where (p_zone_id is null or coalesce(
      o.delivery_zone_id,
      case
        when nullif(o.data->>'deliveryZoneId','') is not null
             and (o.data->>'deliveryZoneId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
          then (o.data->>'deliveryZoneId')::uuid
        else null
      end
    ) = p_zone_id)
  )
  select
    coalesce(count(*) filter (where status = 'out_for_delivery'), 0),
    coalesce(count(*) filter (where status = 'delivered' and order_source = 'in_store'), 0),
    coalesce(count(*) filter (where status = 'delivered' and order_source <> 'in_store'), 0)
  into v_out_for_delivery, v_in_store, v_online
  from effective_orders eo
  where eo.date_by >= p_start_date
    and eo.date_by <= p_end_date;

  v_result := json_build_object(
    'total_collected', v_total_collected,
    'gross_subtotal', v_gross_subtotal,
    'returns', v_total_returns,
    'discounts', v_total_discounts,
    'tax', v_total_tax,
    'delivery_fees', v_total_delivery,
    'delivery_cost', v_total_delivery_cost,
    'cogs', v_total_cogs,
    'wastage', v_total_wastage,
    'expenses', v_total_expenses,
    'total_orders', v_total_orders,
    'delivered_orders', v_delivered_orders,
    'cancelled_orders', v_cancelled_orders,
    'out_for_delivery_count', v_out_for_delivery,
    'in_store_count', v_in_store,
    'online_count', v_online
  );

  return v_result;
end;
$_$;


ALTER FUNCTION "public"."get_sales_report_summary"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."guard_admin_users_update"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if auth.uid() is null then
    return new;
  end if;

  if auth.uid() = old.auth_user_id and not public.is_owner() then
    if new.role is distinct from old.role then
      raise exception '    .';
    end if;
    if new.permissions is distinct from old.permissions then
      raise exception '    .';
    end if;
    if new.is_active is distinct from old.is_active then
      raise exception '     .';
    end if;
  end if;

  return new;
end;
$$;


ALTER FUNCTION "public"."guard_admin_users_update"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."has_admin_permission"("p" "text") RETURNS boolean
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_role text;
  v_perms text[];
begin
  select au.role, au.permissions
  into v_role, v_perms
  from public.admin_users au
  where au.auth_user_id = auth.uid()
    and au.is_active = true;

  if v_role is null then
    return false;
  end if;

  -- Owners/Managers: full access
  if v_role in ('owner', 'manager') then
    return true;
  end if;

  -- Special hard guard: 'import.close' allowed only for owner/manager
  if p = 'import.close' then
    return false;
  end if;

  -- Explicit permission list assigned to the user
  if v_perms is not null and p = any(v_perms) then
    return true;
  end if;

  -- Role-based defaults (unchanged behavior)
  if v_role = 'cashier' then
    return p = any(array[
      'dashboard.view',
      'profile.view',
      'orders.view',
      'orders.markPaid',
      'orders.createInStore',
      'cashShifts.open',
      'cashShifts.viewOwn',
      'cashShifts.closeSelf',
      'cashShifts.cashIn',
      'cashShifts.cashOut'
    ]);
  end if;

  if v_role = 'delivery' then
    return p = any(array[
      'profile.view',
      'orders.view',
      'orders.updateStatus.delivery'
    ]);
  end if;

  if v_role = 'employee' then
    return p = any(array[
      'dashboard.view',
      'profile.view',
      'orders.view',
      'orders.markPaid'
    ]);
  end if;

  if v_role = 'accountant' then
    return p = any(array[
      'dashboard.view',
      'profile.view',
      'reports.view',
      'expenses.manage',
      'accounting.view',
      'accounting.manage',
      'accounting.periods.close'
    ]);
  end if;

  return false;
end;
$$;


ALTER FUNCTION "public"."has_admin_permission"("p" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."haversine_distance_meters"("lat1" double precision, "lng1" double precision, "lat2" double precision, "lng2" double precision) RETURNS double precision
    LANGUAGE "sql" IMMUTABLE
    AS $$
  select 2 * 6371000.0 * asin(
    sqrt(
      power(sin(radians((lat2 - lat1) / 2.0)), 2)
      + cos(radians(lat1)) * cos(radians(lat2))
      * power(sin(radians((lng2 - lng1) / 2.0)), 2)
    )
  );
$$;


ALTER FUNCTION "public"."haversine_distance_meters"("lat1" double precision, "lng1" double precision, "lat2" double precision, "lng2" double precision) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."income_statement"("p_start" "date", "p_end" "date", "p_cost_center_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("income" numeric, "expenses" numeric, "net_profit" numeric)
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  with tb as (
    select *
    from public.trial_balance(p_start, p_end, p_cost_center_id)
  )
  select
    coalesce(sum(case when tb.account_type = 'income' then (tb.credit - tb.debit) else 0 end), 0) as income,
    coalesce(sum(case when tb.account_type = 'expense' then (tb.debit - tb.credit) else 0 end), 0) as expenses,
    coalesce(sum(case when tb.account_type = 'income' then (tb.credit - tb.debit) else 0 end), 0)
      - coalesce(sum(case when tb.account_type = 'expense' then (tb.debit - tb.credit) else 0 end), 0) as net_profit
  from tb;
$$;


ALTER FUNCTION "public"."income_statement"("p_start" "date", "p_end" "date", "p_cost_center_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."income_statement_series"("p_start" "date", "p_end" "date", "p_cost_center_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("period" "date", "income" numeric, "expenses" numeric, "net_profit" numeric)
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if not public.can_view_accounting_reports() then
    raise exception 'not allowed';
  end if;

  return query
  with series as (
    select date_trunc('month', gs)::date as period
    from generate_series(
      coalesce(p_start, current_date),
      coalesce(p_end, current_date),
      interval '1 month'
    ) gs
  ),
  joined as (
    select
      s.period,
      coa.account_type,
      jl.debit,
      jl.credit
    from series s
    left join public.journal_entries je
      on je.entry_date::date >= s.period
     and je.entry_date::date < (s.period + interval '1 month')::date
    left join public.journal_lines jl
      on jl.journal_entry_id = je.id
    left join public.chart_of_accounts coa
      on coa.id = jl.account_id
    where (p_cost_center_id is null or jl.cost_center_id = p_cost_center_id)
  )
  select
    j.period,
    coalesce(sum(case when j.account_type = 'income' then (j.credit - j.debit) else 0 end), 0) as income,
    coalesce(sum(case when j.account_type = 'expense' then (j.debit - j.credit) else 0 end), 0) as expenses,
    coalesce(sum(case when j.account_type = 'income' then (j.credit - j.debit) else 0 end), 0)
      - coalesce(sum(case when j.account_type = 'expense' then (j.debit - j.credit) else 0 end), 0) as net_profit
  from joined j
  group by j.period
  order by j.period;
end;
$$;


ALTER FUNCTION "public"."income_statement_series"("p_start" "date", "p_end" "date", "p_cost_center_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."inv_batch_vs_stock_invariant"() RETURNS TABLE("item_id" "text", "warehouse_id" "uuid", "batch_qty" numeric, "stock_qty" numeric)
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  with batch_totals as (
    select
      b.item_id::text as item_id,
      b.warehouse_id,
      sum(
        greatest(
          coalesce(b.quantity_received,0)
          - coalesce(b.quantity_consumed,0)
          - coalesce(b.quantity_transferred,0),
          0
        )
      ) as batch_qty
    from public.batches b
    where b.warehouse_id is not null
    group by 1,2
  ),
  stock_totals as (
    select
      sm.item_id::text as item_id,
      sm.warehouse_id,
      sum(coalesce(sm.available_quantity,0)) as stock_qty
    from public.stock_management sm
    where sm.warehouse_id is not null
    group by 1,2
  )
  select
    coalesce(bt.item_id, st.item_id) as item_id,
    coalesce(bt.warehouse_id, st.warehouse_id) as warehouse_id,
    coalesce(bt.batch_qty,0) as batch_qty,
    coalesce(st.stock_qty,0) as stock_qty
  from batch_totals bt
  full join stock_totals st
    on st.item_id = bt.item_id
   and st.warehouse_id = bt.warehouse_id
  where abs(coalesce(bt.batch_qty,0) - coalesce(st.stock_qty,0)) > 0.0001;
$$;


ALTER FUNCTION "public"."inv_batch_vs_stock_invariant"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."inv_cogs_outside_inventory_movements"() RETURNS TABLE("journal_entry_id" "uuid", "movement_id" "uuid", "movement_type" "text", "cogs_account_id" "uuid")
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  with cogs as (
    select public.get_account_id_by_code('5010') as account_id
  )
  select
    je.id as journal_entry_id,
    im.id as movement_id,
    im.movement_type,
    c.account_id as cogs_account_id
  from public.journal_entries je
  join public.inventory_movements im
    on je.source_table = 'inventory_movements'
   and je.source_id = im.id::text
  join public.journal_lines jl
    on jl.journal_entry_id = je.id
  cross join cogs c
  where c.account_id is not null
    and jl.account_id = c.account_id
    and im.movement_type not in ('sale_out','expired_out','wastage_out');
$$;


ALTER FUNCTION "public"."inv_cogs_outside_inventory_movements"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."inv_duplicate_sale_out_lines"() RETURNS TABLE("order_id" "text", "item_id" "text", "batch_id" "uuid", "warehouse_id" "uuid", "cnt" bigint)
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select
    im.reference_id as order_id,
    im.item_id,
    im.batch_id,
    im.warehouse_id,
    count(*) as cnt
  from public.inventory_movements im
  where im.reference_table = 'orders'
    and im.movement_type = 'sale_out'
    and im.batch_id is not null
  group by 1,2,3,4
  having count(*) > 1;
$$;


ALTER FUNCTION "public"."inv_duplicate_sale_out_lines"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."inv_duplicate_transfer_movements"() RETURNS TABLE("transfer_id" "text", "movement_type" "text", "item_id" "text", "batch_id" "uuid", "warehouse_id" "uuid", "cnt" bigint)
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select
    im.reference_id as transfer_id,
    im.movement_type,
    im.item_id,
    im.batch_id,
    im.warehouse_id,
    count(*) as cnt
  from public.inventory_movements im
  where im.reference_table = 'inventory_transfers'
    and im.movement_type in ('transfer_out','transfer_in')
  group by 1,2,3,4,5
  having count(*) > 1;
$$;


ALTER FUNCTION "public"."inv_duplicate_transfer_movements"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."inv_expired_batches_with_remaining"() RETURNS TABLE("batch_id" "uuid", "item_id" "text", "warehouse_id" "uuid", "expiry_date" "date", "remaining_qty" numeric)
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select
    b.id as batch_id,
    b.item_id,
    b.warehouse_id,
    b.expiry_date,
    greatest(coalesce(b.quantity_received,0) - coalesce(b.quantity_consumed,0), 0) as remaining_qty
  from public.batches b
  where b.expiry_date is not null
    and b.expiry_date < current_date
    and greatest(coalesce(b.quantity_received,0) - coalesce(b.quantity_consumed,0), 0) > 0;
$$;


ALTER FUNCTION "public"."inv_expired_batches_with_remaining"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."inv_journal_entries_for_transfer_movements"() RETURNS TABLE("journal_entry_id" "uuid", "movement_id" "uuid", "movement_type" "text")
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select
    je.id as journal_entry_id,
    im.id as movement_id,
    im.movement_type
  from public.journal_entries je
  join public.inventory_movements im
    on je.source_table = 'inventory_movements'
   and je.source_id = im.id::text
  where im.movement_type in ('transfer_out','transfer_in');
$$;


ALTER FUNCTION "public"."inv_journal_entries_for_transfer_movements"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."inv_negative_batch_remaining"() RETURNS TABLE("batch_id" "uuid", "item_id" "text", "warehouse_id" "uuid", "quantity_received" numeric, "quantity_consumed" numeric, "quantity_transferred" numeric, "remaining_qty" numeric)
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select
    b.id,
    b.item_id::text,
    b.warehouse_id,
    b.quantity_received,
    b.quantity_consumed,
    b.quantity_transferred,
    (coalesce(b.quantity_received,0) - coalesce(b.quantity_consumed,0) - coalesce(b.quantity_transferred,0)) as remaining_qty
  from public.batches b
  where (coalesce(b.quantity_received,0) - coalesce(b.quantity_consumed,0) - coalesce(b.quantity_transferred,0)) < -0.0001;
$$;


ALTER FUNCTION "public"."inv_negative_batch_remaining"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."inv_negative_stock"() RETURNS TABLE("item_id" "text", "warehouse_id" "uuid", "available_quantity" numeric, "reserved_quantity" numeric)
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select sm.item_id::text, sm.warehouse_id, sm.available_quantity, sm.reserved_quantity
  from public.stock_management sm
  where sm.available_quantity < 0
     or sm.reserved_quantity < 0;
$$;


ALTER FUNCTION "public"."inv_negative_stock"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."inv_sale_out_from_expired_batches"() RETURNS TABLE("movement_id" "uuid", "item_id" "text", "batch_id" "uuid", "movement_created_at" "date", "batch_expiry_date" "date", "warehouse_id" "uuid", "reference_id" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if exists (
    select 1
    from information_schema.columns c
    where c.table_schema = 'public'
      and c.table_name = 'inventory_movements'
      and c.column_name = 'warehouse_id'
  ) then
    return query
    select
      im.id as movement_id,
      im.item_id,
      im.batch_id,
      im.created_at::date as movement_created_at,
      b.expiry_date as batch_expiry_date,
      im.warehouse_id,
      im.reference_id
    from public.inventory_movements im
    join public.batches b on b.id = im.batch_id
    where im.movement_type = 'sale_out'
      and b.expiry_date is not null
      and b.expiry_date < im.created_at::date;
  else
    return query
    select
      im.id as movement_id,
      im.item_id,
      im.batch_id,
      im.created_at::date as movement_created_at,
      b.expiry_date as batch_expiry_date,
      null::uuid as warehouse_id,
      im.reference_id
    from public.inventory_movements im
    join public.batches b on b.id = im.batch_id
    where im.movement_type = 'sale_out'
      and b.expiry_date is not null
      and b.expiry_date < im.created_at::date;
  end if;
end;
$$;


ALTER FUNCTION "public"."inv_sale_out_from_expired_batches"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."inv_transfer_batch_lineage_mismatch"() RETURNS TABLE("transfer_id" "uuid", "item_id" "text", "source_batch_id" "uuid", "received_batch_id" "uuid", "expected_expiry_date" "date", "received_expiry_date" "date")
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select
    iti.transfer_id,
    iti.item_id,
    iti.source_batch_id,
    iti.received_batch_id,
    b_src.expiry_date as expected_expiry_date,
    b_dst.expiry_date as received_expiry_date
  from public.inventory_transfer_items iti
  join public.batches b_src on b_src.id = iti.source_batch_id
  join public.batches b_dst on b_dst.id = iti.received_batch_id
  where coalesce((b_dst.data->>'sourceBatchId')::uuid, '00000000-0000-0000-0000-000000000000'::uuid) <> iti.source_batch_id
     or b_dst.expiry_date is distinct from b_src.expiry_date
     or b_dst.unit_cost is distinct from iti.unit_cost;
$$;


ALTER FUNCTION "public"."inv_transfer_batch_lineage_mismatch"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."inv_transfer_global_qty_invariant"() RETURNS TABLE("item_id" "text", "total_qty" numeric)
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select
    sm.item_id::text,
    sum(sm.available_quantity) as total_qty
  from public.stock_management sm
  group by sm.item_id
  having sum(sm.available_quantity) < 0;
$$;


ALTER FUNCTION "public"."inv_transfer_global_qty_invariant"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."inv_transfer_movements_in_cogs"() RETURNS TABLE("movement_id" "uuid", "movement_type" "text")
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select im.id, im.movement_type
  from public.v_cogs_movements im
  where im.movement_type in ('transfer_out','transfer_in');
$$;


ALTER FUNCTION "public"."inv_transfer_movements_in_cogs"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."inv_transfer_qty_mismatch"() RETURNS TABLE("transfer_id" "uuid", "item_id" "text", "source_batch_id" "uuid", "qty_out" numeric, "qty_in" numeric)
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  with out_mv as (
    select
      im.reference_id::uuid as transfer_id,
      im.item_id,
      im.batch_id as source_batch_id,
      sum(im.quantity) as qty_out
    from public.inventory_movements im
    where im.reference_table = 'inventory_transfers'
      and im.movement_type = 'transfer_out'
    group by 1,2,3
  ),
  in_mv as (
    select
      im.reference_id::uuid as transfer_id,
      im.item_id,
      (im.data->>'sourceBatchId')::uuid as source_batch_id,
      sum(im.quantity) as qty_in
    from public.inventory_movements im
    where im.reference_table = 'inventory_transfers'
      and im.movement_type = 'transfer_in'
      and (im.data ? 'sourceBatchId')
    group by 1,2,3
  )
  select
    coalesce(o.transfer_id, i.transfer_id) as transfer_id,
    coalesce(o.item_id, i.item_id) as item_id,
    coalesce(o.source_batch_id, i.source_batch_id) as source_batch_id,
    coalesce(o.qty_out, 0) as qty_out,
    coalesce(i.qty_in, 0) as qty_in
  from out_mv o
  full join in_mv i
    on i.transfer_id = o.transfer_id
   and i.item_id = o.item_id
   and i.source_batch_id = o.source_batch_id
  where coalesce(o.qty_out, 0) <> coalesce(i.qty_in, 0);
$$;


ALTER FUNCTION "public"."inv_transfer_qty_mismatch"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."inv_transfer_state_mismatch"() RETURNS TABLE("transfer_id" "uuid", "state" "text", "item_id" "text", "source_batch_id" "uuid", "expected_qty" numeric, "out_qty" numeric, "in_qty" numeric)
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  with items as (
    select iti.transfer_id, iti.item_id, iti.source_batch_id, iti.quantity
    from public.inventory_transfer_items iti
  ),
  out_mv as (
    select im.reference_id::uuid as transfer_id, im.item_id, im.batch_id as source_batch_id, sum(im.quantity) as qty
    from public.inventory_movements im
    where im.reference_table = 'inventory_transfers'
      and im.movement_type = 'transfer_out'
    group by 1,2,3
  ),
  in_mv as (
    select im.reference_id::uuid as transfer_id, im.item_id, (im.data->>'sourceBatchId')::uuid as source_batch_id, sum(im.quantity) as qty
    from public.inventory_movements im
    where im.reference_table = 'inventory_transfers'
      and im.movement_type = 'transfer_in'
      and (im.data ? 'sourceBatchId')
    group by 1,2,3
  )
  select
    it.id as transfer_id,
    it.state,
    i.item_id,
    i.source_batch_id,
    i.quantity as expected_qty,
    coalesce(o.qty, 0) as out_qty,
    coalesce(n.qty, 0) as in_qty
  from public.inventory_transfers it
  join items i on i.transfer_id = it.id
  left join out_mv o on o.transfer_id = it.id and o.item_id = i.item_id and o.source_batch_id = i.source_batch_id
  left join in_mv n on n.transfer_id = it.id and n.item_id = i.item_id and n.source_batch_id = i.source_batch_id
  where (it.state in ('IN_TRANSIT','RECEIVED') and coalesce(o.qty,0) <> i.quantity)
     or (it.state = 'RECEIVED' and coalesce(n.qty,0) <> i.quantity);
$$;


ALTER FUNCTION "public"."inv_transfer_state_mismatch"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."inv_transfer_unit_cost_mismatch"() RETURNS TABLE("transfer_id" "uuid", "item_id" "text", "source_batch_id" "uuid", "expected_unit_cost" numeric, "source_batch_unit_cost" numeric, "received_batch_unit_cost" numeric)
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select
    iti.transfer_id,
    iti.item_id,
    iti.source_batch_id,
    iti.unit_cost as expected_unit_cost,
    b_src.unit_cost as source_batch_unit_cost,
    b_dst.unit_cost as received_batch_unit_cost
  from public.inventory_transfer_items iti
  join public.batches b_src on b_src.id = iti.source_batch_id
  left join public.batches b_dst on b_dst.id = iti.received_batch_id
  where b_src.unit_cost is distinct from iti.unit_cost
     or (iti.received_batch_id is not null and b_dst.unit_cost is distinct from iti.unit_cost);
$$;


ALTER FUNCTION "public"."inv_transfer_unit_cost_mismatch"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_active_admin"() RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.admin_users
    WHERE auth_user_id = auth.uid()
    AND is_active = true
  );
END;
$$;


ALTER FUNCTION "public"."is_active_admin"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_admin"() RETURNS boolean
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
      select exists (
        select 1
        from public.admin_users au
        where au.auth_user_id = auth.uid()
          and au.is_active = true
      );
    $$;


ALTER FUNCTION "public"."is_admin"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_in_closed_period"("p_ts" timestamp with time zone) RETURNS boolean
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select exists (
    select 1
    from public.accounting_periods ap
    where ap.status = 'closed'
      and (p_ts::date) between ap.start_date and ap.end_date
  );
$$;


ALTER FUNCTION "public"."is_in_closed_period"("p_ts" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_maintenance_on"() RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v jsonb;
  v_on boolean;
BEGIN
  SELECT data INTO v FROM public.app_settings WHERE id = 'app';
  IF v IS NULL THEN
    SELECT data INTO v FROM public.app_settings WHERE id = 'general_settings';
  END IF;
  v_on := COALESCE((v->'settings'->>'maintenanceEnabled')::boolean, false);
  RETURN v_on;
END;
$$;


ALTER FUNCTION "public"."is_maintenance_on"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_owner"() RETURNS boolean
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select exists (
    select 1
    from public.admin_users au
    where au.auth_user_id = auth.uid()
      and au.is_active = true
      and au.role = 'owner'
  );
$$;


ALTER FUNCTION "public"."is_owner"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_owner_or_manager"() RETURNS boolean
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select exists (
    select 1
    from public.admin_users au
    where au.auth_user_id = auth.uid()
      and au.is_active = true
      and au.role in ('owner','manager')
  );
$$;


ALTER FUNCTION "public"."is_owner_or_manager"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_staff"() RETURNS boolean
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select exists (
    select 1
    from public.admin_users au
    where au.auth_user_id = auth.uid()
      and au.is_active = true
      and au.role in ('owner', 'manager', 'employee', 'cashier', 'delivery')
  );
$$;


ALTER FUNCTION "public"."is_staff"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."issue_invoice_on_delivery"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_has_invoice boolean;
  v_invoice text;
  v_issued_at timestamptz;
  v_snapshot jsonb;
  v_subtotal numeric;
  v_discount numeric;
  v_delivery_fee numeric;
  v_total numeric;
  v_tax numeric;
BEGIN
  IF NEW.status = 'delivered' AND (OLD.status IS DISTINCT FROM NEW.status) THEN
    v_has_invoice := (NEW.data ? 'invoiceIssuedAt') AND (NEW.data ? 'invoiceNumber');
    IF NOT coalesce(v_has_invoice, false) THEN
      v_invoice := public.generate_invoice_number();
      v_issued_at := coalesce(
        nullif(NEW.data->>'paidAt', '')::timestamptz,
        nullif(NEW.data->>'deliveredAt', '')::timestamptz,
        now()
      );

      v_subtotal := coalesce(nullif((NEW.data->>'subtotal')::numeric, null), 0);
      v_discount := coalesce(nullif((NEW.data->>'discountAmount')::numeric, null), 0);
      v_delivery_fee := coalesce(nullif((NEW.data->>'deliveryFee')::numeric, null), 0);
      v_tax := coalesce(nullif((NEW.data->>'taxAmount')::numeric, null), 0);
      v_total := coalesce(nullif((NEW.data->>'total')::numeric, null), v_subtotal - v_discount + v_delivery_fee + v_tax);

      v_snapshot := jsonb_build_object(
        'issuedAt', to_jsonb(v_issued_at),
        'invoiceNumber', to_jsonb(v_invoice),
        'createdAt', to_jsonb(coalesce(nullif(NEW.data->>'createdAt',''), NEW.created_at::text)),
        'orderSource', to_jsonb(coalesce(nullif(NEW.data->>'orderSource',''), 'online')),
        'items', coalesce(NEW.data->'items', '[]'::jsonb),
        'subtotal', to_jsonb(v_subtotal),
        'deliveryFee', to_jsonb(v_delivery_fee),
        'discountAmount', to_jsonb(v_discount),
        'total', to_jsonb(v_total),
        'paymentMethod', to_jsonb(coalesce(nullif(NEW.data->>'paymentMethod',''), 'cash')),
        'customerName', to_jsonb(coalesce(NEW.data->>'customerName', '')),
        'phoneNumber', to_jsonb(coalesce(NEW.data->>'phoneNumber', '')),
        'address', to_jsonb(coalesce(NEW.data->>'address', '')),
        'deliveryZoneId', CASE WHEN NEW.data ? 'deliveryZoneId' THEN to_jsonb(NEW.data->>'deliveryZoneId') ELSE NULL END
      );

      NEW.data := jsonb_set(NEW.data, '{invoiceNumber}', to_jsonb(v_invoice), true);
      NEW.data := jsonb_set(NEW.data, '{invoiceIssuedAt}', to_jsonb(v_issued_at), true);
      NEW.data := jsonb_set(NEW.data, '{invoiceSnapshot}', v_snapshot, true);
      IF NOT (NEW.data ? 'invoicePrintCount') THEN
        NEW.data := jsonb_set(NEW.data, '{invoicePrintCount}', '0'::jsonb, true);
      END IF;
    END IF;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."issue_invoice_on_delivery"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."list_active_accounts"() RETURNS TABLE("id" "uuid", "code" "text", "name" "text", "account_type" "text", "normal_balance" "text")
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if not public.has_admin_permission('accounting.view') then
    raise exception 'not allowed';
  end if;
  return query
  select id, code, name, account_type, normal_balance
  from public.chart_of_accounts
  where is_active = true
  order by code asc;
end;
$$;


ALTER FUNCTION "public"."list_active_accounts"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."list_approval_requests"("p_status" "text" DEFAULT 'pending'::"text", "p_limit" integer DEFAULT 200) RETURNS TABLE("id" "uuid", "target_table" "text", "target_id" "text", "request_type" "text", "status" "text", "requested_by" "uuid", "approved_by" "uuid", "approved_at" timestamp with time zone, "rejected_by" "uuid", "rejected_at" timestamp with time zone, "created_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_status text;
  v_limit int;
begin
  perform public._require_staff('list_approval_requests');
  v_status := nullif(trim(coalesce(p_status, '')), '');
  v_limit := coalesce(p_limit, 200);
  if v_limit < 1 then v_limit := 1; end if;
  if v_limit > 500 then v_limit := 500; end if;

  if v_status is null or v_status = 'all' then
    return query
    select
      ar.id,
      ar.target_table,
      ar.target_id,
      ar.request_type,
      ar.status,
      ar.requested_by,
      ar.approved_by,
      ar.approved_at,
      ar.rejected_by,
      ar.rejected_at,
      ar.created_at
    from public.approval_requests ar
    order by ar.created_at desc nulls last
    limit v_limit;
  end if;

  if v_status not in ('pending','approved','rejected') then
    raise exception 'invalid status';
  end if;

  return query
  select
    ar.id,
    ar.target_table,
    ar.target_id,
    ar.request_type,
    ar.status,
    ar.requested_by,
    ar.approved_by,
    ar.approved_at,
    ar.rejected_by,
    ar.rejected_at,
    ar.created_at
  from public.approval_requests ar
  where ar.status = v_status
  order by ar.created_at desc nulls last
  limit v_limit;
end;
$$;


ALTER FUNCTION "public"."list_approval_requests"("p_status" "text", "p_limit" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."list_approval_steps"("p_request_ids" "uuid"[]) RETURNS TABLE("id" "uuid", "request_id" "uuid", "step_no" integer, "approver_role" "text", "status" "text", "action_by" "uuid", "action_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  perform public._require_staff('list_approval_steps');
  if p_request_ids is null or array_length(p_request_ids, 1) is null then
    return;
  end if;
  return query
  select
    s.id,
    s.request_id,
    s.step_no,
    s.approver_role,
    s.status,
    s.action_by,
    s.action_at
  from public.approval_steps s
  where s.request_id = any(p_request_ids)
  order by s.request_id asc, s.step_no asc;
end;
$$;


ALTER FUNCTION "public"."list_approval_steps"("p_request_ids" "uuid"[]) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."list_chart_of_accounts"("p_include_inactive" boolean DEFAULT true) RETURNS TABLE("id" "uuid", "code" "text", "name" "text", "account_type" "text", "normal_balance" "text", "is_active" boolean, "created_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if not public.has_admin_permission('accounting.view') then
    raise exception 'not allowed';
  end if;

  return query
  select
    coa.id,
    coa.code,
    coa.name,
    coa.account_type,
    coa.normal_balance,
    coa.is_active,
    coa.created_at
  from public.chart_of_accounts coa
  where p_include_inactive = true or coa.is_active = true
  order by coa.code asc;
end;
$$;


ALTER FUNCTION "public"."list_chart_of_accounts"("p_include_inactive" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."log_admin_changes"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.system_audit_logs(action, module, details, performed_by, performed_at, metadata)
    VALUES (
      'create',
      'admin_users',
      concat('Created admin user ', COALESCE(NEW.full_name, NEW.username), ' with role ', NEW.role),
      auth.uid(),
      now(),
      jsonb_build_object(
        'user_id', NEW.auth_user_id,
        'username', NEW.username,
        'full_name', NEW.full_name,
        'role', NEW.role,
        'permissions', NEW.permissions
      )
    );
    
  ELSIF TG_OP = 'UPDATE' THEN
    -- Log role changes
    IF OLD.role IS DISTINCT FROM NEW.role THEN
      INSERT INTO public.system_audit_logs(action, module, details, performed_by, performed_at, metadata)
      VALUES (
        'role_change',
        'admin_users',
        concat('Role changed for user ', COALESCE(NEW.full_name, NEW.username), ' from ', OLD.role, ' to ', NEW.role),
        auth.uid(),
        now(),
        jsonb_build_object(
          'user_id', NEW.auth_user_id,
          'username', NEW.username,
          'full_name', NEW.full_name,
          'old_role', OLD.role,
          'new_role', NEW.role
        )
      );
    END IF;
    
    -- Log permission changes
    IF OLD.permissions IS DISTINCT FROM NEW.permissions THEN
      INSERT INTO public.system_audit_logs(action, module, details, performed_by, performed_at, metadata)
      VALUES (
        'permission_change',
        'admin_users',
        concat('Permissions changed for user ', COALESCE(NEW.full_name, NEW.username)),
        auth.uid(),
        now(),
        jsonb_build_object(
          'user_id', NEW.auth_user_id,
          'username', NEW.username,
          'full_name', NEW.full_name,
          'old_permissions', OLD.permissions,
          'new_permissions', NEW.permissions
        )
      );
    END IF;
    
    -- Log activation/deactivation
    IF OLD.is_active IS DISTINCT FROM NEW.is_active THEN
      INSERT INTO public.system_audit_logs(action, module, details, performed_by, performed_at, metadata)
      VALUES (
        CASE WHEN NEW.is_active THEN 'activate' ELSE 'deactivate' END,
        'admin_users',
        concat(
          CASE WHEN NEW.is_active THEN 'Activated' ELSE 'Deactivated' END,
          ' user ', COALESCE(NEW.full_name, NEW.username)
        ),
        auth.uid(),
        now(),
        jsonb_build_object(
          'user_id', NEW.auth_user_id,
          'username', NEW.username,
          'full_name', NEW.full_name,
          'is_active', NEW.is_active
        )
      );
    END IF;
    
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO public.system_audit_logs(action, module, details, performed_by, performed_at, metadata)
    VALUES (
      'delete',
      'admin_users',
      concat('Deleted admin user ', COALESCE(OLD.full_name, OLD.username)),
      auth.uid(),
      now(),
      jsonb_build_object(
        'user_id', OLD.auth_user_id,
        'username', OLD.username,
        'full_name', OLD.full_name,
        'role', OLD.role,
        'permissions', OLD.permissions
      )
    );
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$$;


ALTER FUNCTION "public"."log_admin_changes"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."log_admin_changes"() IS 'Audit trigger: Logs all admin user role and permission changes';



CREATE OR REPLACE FUNCTION "public"."log_coa_changes"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.system_audit_logs(action, module, details, performed_by, performed_at, metadata)
    VALUES (
      'create',
      'chart_of_accounts',
      concat('Created account ', NEW.code, ' - ', NEW.name),
      auth.uid(),
      now(),
      jsonb_build_object(
        'account_id', NEW.id,
        'code', NEW.code,
        'name', NEW.name,
        'account_type', NEW.account_type,
        'normal_balance', NEW.normal_balance
      )
    );
    
  ELSIF TG_OP = 'UPDATE' THEN
    INSERT INTO public.system_audit_logs(action, module, details, performed_by, performed_at, metadata)
    VALUES (
      'update',
      'chart_of_accounts',
      concat('Updated account ', NEW.code, ' - ', NEW.name),
      auth.uid(),
      now(),
      jsonb_build_object(
        'account_id', NEW.id,
        'code', NEW.code,
        'old_name', OLD.name,
        'new_name', NEW.name,
        'old_active', OLD.is_active,
        'new_active', NEW.is_active
      )
    );
    
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO public.system_audit_logs(action, module, details, performed_by, performed_at, metadata)
    VALUES (
      'delete',
      'chart_of_accounts',
      concat('Deleted account ', OLD.code, ' - ', OLD.name),
      auth.uid(),
      now(),
      jsonb_build_object(
        'account_id', OLD.id,
        'code', OLD.code,
        'name', OLD.name
      )
    );
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$$;


ALTER FUNCTION "public"."log_coa_changes"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."log_coa_changes"() IS 'Audit trigger: Logs all chart of accounts modifications';



CREATE OR REPLACE FUNCTION "public"."log_currencies_changes"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if tg_op = 'INSERT' then
    insert into public.system_audit_logs(action, module, details, performed_by, performed_at, metadata)
    values (
      'insert',
      'currencies',
      concat('Inserted currency ', new.code),
      auth.uid(),
      now(),
      jsonb_build_object('table','currencies','code',new.code,'is_base',new.is_base,'is_high_inflation',new.is_high_inflation)
    );
    return new;
  elsif tg_op = 'UPDATE' then
    insert into public.system_audit_logs(action, module, details, performed_by, performed_at, metadata)
    values (
      'update',
      'currencies',
      concat('Updated currency ', new.code),
      auth.uid(),
      now(),
      jsonb_build_object(
        'table','currencies',
        'code',new.code,
        'old_is_base',old.is_base,
        'new_is_base',new.is_base,
        'old_is_high_inflation',old.is_high_inflation,
        'new_is_high_inflation',new.is_high_inflation
      )
    );
    return new;
  elsif tg_op = 'DELETE' then
    insert into public.system_audit_logs(action, module, details, performed_by, performed_at, metadata)
    values (
      'delete',
      'currencies',
      concat('Deleted currency ', old.code),
      auth.uid(),
      now(),
      jsonb_build_object('table','currencies','code',old.code,'is_base',old.is_base,'is_high_inflation',old.is_high_inflation)
    );
    return old;
  end if;
  return coalesce(new, old);
end;
$$;


ALTER FUNCTION "public"."log_currencies_changes"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."log_customer_changes"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_changed_fields jsonb := '{}'::jsonb;
  v_field text;
BEGIN
  IF TG_OP = 'UPDATE' THEN
    -- Track which fields changed
    IF OLD.full_name IS DISTINCT FROM NEW.full_name THEN
      v_changed_fields := v_changed_fields || jsonb_build_object('full_name', jsonb_build_object('old', OLD.full_name, 'new', NEW.full_name));
    END IF;
    
    IF OLD.phone_number IS DISTINCT FROM NEW.phone_number THEN
      v_changed_fields := v_changed_fields || jsonb_build_object('phone_number', jsonb_build_object('old', OLD.phone_number, 'new', NEW.phone_number));
    END IF;
    
    IF OLD.email IS DISTINCT FROM NEW.email THEN
      v_changed_fields := v_changed_fields || jsonb_build_object('email', jsonb_build_object('old', OLD.email, 'new', NEW.email));
    END IF;
    
    IF OLD.loyalty_points IS DISTINCT FROM NEW.loyalty_points THEN
      v_changed_fields := v_changed_fields || jsonb_build_object('loyalty_points', jsonb_build_object('old', OLD.loyalty_points, 'new', NEW.loyalty_points, 'change', NEW.loyalty_points - OLD.loyalty_points));
    END IF;
    
    IF OLD.loyalty_tier IS DISTINCT FROM NEW.loyalty_tier THEN
      v_changed_fields := v_changed_fields || jsonb_build_object('loyalty_tier', jsonb_build_object('old', OLD.loyalty_tier, 'new', NEW.loyalty_tier));
    END IF;
    
    -- Only log if something actually changed
    IF v_changed_fields != '{}'::jsonb THEN
      INSERT INTO public.system_audit_logs(action, module, details, performed_by, performed_at, metadata)
      VALUES (
        'update',
        'customers',
        concat('Updated customer ', COALESCE(NEW.full_name, NEW.phone_number, NEW.email, NEW.auth_user_id::text)),
        auth.uid(),
        now(),
        jsonb_build_object(
          'customer_id', NEW.auth_user_id,
          'customer_name', NEW.full_name,
          'changed_fields', v_changed_fields
        )
      );
    END IF;
    
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO public.system_audit_logs(action, module, details, performed_by, performed_at, metadata)
    VALUES (
      'delete',
      'customers',
      concat('Deleted customer ', COALESCE(OLD.full_name, OLD.phone_number, OLD.email, OLD.auth_user_id::text)),
      auth.uid(),
      now(),
      jsonb_build_object(
        'customer_id', OLD.auth_user_id,
        'customer_name', OLD.full_name,
        'customer_phone', OLD.phone_number,
        'customer_email', OLD.email
      )
    );
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$$;


ALTER FUNCTION "public"."log_customer_changes"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."log_customer_changes"() IS 'Audit trigger: Logs all customer data modifications';



CREATE OR REPLACE FUNCTION "public"."log_fx_rates_changes"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if tg_op = 'INSERT' then
    insert into public.system_audit_logs(action, module, details, performed_by, performed_at, metadata)
    values (
      'insert',
      'fx_rates',
      concat('Inserted FX rate ', new.currency_code, ' ', new.rate_type, ' ', new.rate_date::text, ' = ', new.rate::text),
      auth.uid(),
      now(),
      jsonb_build_object(
        'table', 'fx_rates',
        'id', new.id,
        'currency_code', new.currency_code,
        'rate_type', new.rate_type,
        'rate_date', new.rate_date,
        'rate', new.rate
      )
    );
    return new;
  elsif tg_op = 'UPDATE' then
    insert into public.system_audit_logs(action, module, details, performed_by, performed_at, metadata)
    values (
      'update',
      'fx_rates',
      concat('Updated FX rate ', new.currency_code, ' ', new.rate_type, ' ', new.rate_date::text, ' = ', new.rate::text),
      auth.uid(),
      now(),
      jsonb_build_object(
        'table', 'fx_rates',
        'id', new.id,
        'currency_code', new.currency_code,
        'rate_type', new.rate_type,
        'rate_date', new.rate_date,
        'old_rate', old.rate,
        'new_rate', new.rate
      )
    );
    return new;
  elsif tg_op = 'DELETE' then
    insert into public.system_audit_logs(action, module, details, performed_by, performed_at, metadata)
    values (
      'delete',
      'fx_rates',
      concat('Deleted FX rate ', old.currency_code, ' ', old.rate_type, ' ', old.rate_date::text),
      auth.uid(),
      now(),
      jsonb_build_object(
        'table', 'fx_rates',
        'id', old.id,
        'currency_code', old.currency_code,
        'rate_type', old.rate_type,
        'rate_date', old.rate_date,
        'rate', old.rate
      )
    );
    return old;
  end if;
  return coalesce(new, old);
end;
$$;


ALTER FUNCTION "public"."log_fx_rates_changes"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."log_menu_item_changes"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_old_price numeric;
  v_new_price numeric;
  v_old_cost numeric;
  v_new_cost numeric;
  v_item_name_ar text;
begin
  if tg_op = 'UPDATE' then
    v_old_price := coalesce(nullif(old.data->>'price', '')::numeric, 0);
    v_new_price := coalesce(nullif(new.data->>'price', '')::numeric, 0);
    v_old_cost := coalesce(nullif(old.data->>'costPrice', '')::numeric, 0);
    v_new_cost := coalesce(nullif(new.data->>'costPrice', '')::numeric, 0);
    v_item_name_ar := coalesce(new.data->'name'->>'ar', new.data->'name'->>'en', new.id);

    if v_old_price is distinct from v_new_price then
      insert into public.system_audit_logs(action, module, details, performed_by, performed_at, metadata)
      values (
        'price_change',
        'menu_items',
        concat('Price changed for item "', v_item_name_ar, '" (', new.id, ') from ', coalesce(v_old_price::text, 'NULL'), ' to ', coalesce(v_new_price::text, 'NULL')),
        auth.uid(),
        now(),
        jsonb_build_object(
          'item_id', new.id,
          'item_name', new.data->'name',
          'old_price', v_old_price,
          'new_price', v_new_price,
          'change_amount', coalesce(v_new_price, 0) - coalesce(v_old_price, 0)
        )
      );
    end if;

    if v_old_cost is distinct from v_new_cost then
      insert into public.system_audit_logs(action, module, details, performed_by, performed_at, metadata)
      values (
        'cost_change',
        'menu_items',
        concat('Cost price changed for item "', v_item_name_ar, '" (', new.id, ') from ', coalesce(v_old_cost::text, 'NULL'), ' to ', coalesce(v_new_cost::text, 'NULL')),
        auth.uid(),
        now(),
        jsonb_build_object(
          'item_id', new.id,
          'item_name', new.data->'name',
          'old_cost', v_old_cost,
          'new_cost', v_new_cost
        )
      );
    end if;

    if (old.data->>'status') is distinct from (new.data->>'status') then
      insert into public.system_audit_logs(action, module, details, performed_by, performed_at, metadata)
      values (
        'status_change',
        'menu_items',
        concat('Status changed for item "', v_item_name_ar, '" (', new.id, ') from ', old.data->>'status', ' to ', new.data->>'status'),
        auth.uid(),
        now(),
        jsonb_build_object(
          'item_id', new.id,
          'item_name', new.data->'name',
          'old_status', old.data->>'status',
          'new_status', new.data->>'status'
        )
      );
    end if;
  elsif tg_op = 'DELETE' then
    v_item_name_ar := coalesce(old.data->'name'->>'ar', old.data->'name'->>'en', old.id);
    insert into public.system_audit_logs(action, module, details, performed_by, performed_at, metadata)
    values (
      'delete',
      'menu_items',
      concat('Deleted item "', v_item_name_ar, '" (', old.id, ')'),
      auth.uid(),
      now(),
      jsonb_build_object(
        'item_id', old.id,
        'item_name', old.data->'name',
        'item_data', old.data
      )
    );
  end if;

  return coalesce(new, old);
end;
$$;


ALTER FUNCTION "public"."log_menu_item_changes"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."log_menu_item_changes"() IS 'Audit trigger: Logs all price, cost, and status changes for menu items';



CREATE OR REPLACE FUNCTION "public"."log_settings_changes"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_changed_keys text[];
  v_key text;
  v_changes jsonb := '{}'::jsonb;
BEGIN
  -- Find all changed keys in the data JSONB
  SELECT ARRAY_AGG(DISTINCT key)
  INTO v_changed_keys
  FROM (
    SELECT key FROM jsonb_each(NEW.data)
    EXCEPT
    SELECT key FROM jsonb_each(OLD.data)
    UNION
    SELECT key FROM jsonb_each(OLD.data)
    EXCEPT
    SELECT key FROM jsonb_each(NEW.data)
    UNION
    SELECT key FROM jsonb_each(NEW.data)
    WHERE NEW.data->key IS DISTINCT FROM OLD.data->key
  ) changed;
  
  -- Build changes object
  IF v_changed_keys IS NOT NULL THEN
    FOREACH v_key IN ARRAY v_changed_keys
    LOOP
      v_changes := v_changes || jsonb_build_object(
        v_key,
        jsonb_build_object(
          'old', OLD.data->v_key,
          'new', NEW.data->v_key
        )
      );
    END LOOP;
    
    INSERT INTO public.system_audit_logs(action, module, details, performed_by, performed_at, metadata)
    VALUES (
      'update',
      'settings',
      concat('Application settings updated (', array_length(v_changed_keys, 1), ' settings changed)'),
      auth.uid(),
      now(),
      jsonb_build_object(
        'changed_settings', v_changed_keys,
        'changes', v_changes
      )
    );
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."log_settings_changes"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."log_settings_changes"() IS 'Audit trigger: Logs all application settings changes';



CREATE OR REPLACE FUNCTION "public"."manage_menu_item_stock"("p_item_id" "uuid", "p_quantity" numeric, "p_unit" "text", "p_reason" "text", "p_user_id" "uuid" DEFAULT "auth"."uid"(), "p_low_stock_threshold" numeric DEFAULT 5, "p_is_wastage" boolean DEFAULT false, "p_batch_id" "uuid" DEFAULT NULL::"uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_wh uuid;
  v_current record;
  v_old_qty numeric;
  v_old_avg numeric;
  v_diff numeric;
  v_batch record;
  v_reserved_other numeric;
  v_available numeric;
  v_needed numeric;
  v_alloc numeric;
  v_unit_cost numeric;
  v_total_cost numeric;
  v_movement_id uuid;
  v_history_id uuid;
  v_movement_type text;
  v_new_batch_id uuid;
begin
  if p_reason is null or btrim(p_reason) = '' then
    raise exception 'reason is required';
  end if;
  if auth.uid() is null then
    raise exception 'not authenticated';
  end if;
  if not public.has_admin_permission('stock.manage') then
    raise exception 'not allowed';
  end if;

  if p_item_id is null then
    raise exception 'item_id is required';
  end if;
  if p_quantity is null or p_quantity < 0 then
    raise exception 'invalid quantity';
  end if;

  v_wh := public._resolve_default_warehouse_id();
  if v_wh is null then
    raise exception 'warehouse_id is required';
  end if;

  insert into public.stock_management(item_id, warehouse_id, available_quantity, reserved_quantity, unit, low_stock_threshold, avg_cost, last_updated, updated_at, data)
  select p_item_id::text, v_wh, 0, 0, coalesce(p_unit, 'piece'), coalesce(p_low_stock_threshold, 5), 0, now(), now(), '{}'::jsonb
  on conflict (item_id, warehouse_id) do nothing;

  select coalesce(sm.available_quantity, 0), coalesce(sm.avg_cost, 0)
  into v_old_qty, v_old_avg
  from public.stock_management sm
  where sm.item_id::text = p_item_id::text
    and sm.warehouse_id = v_wh
  for update;

  v_diff := p_quantity - v_old_qty;

  if v_diff = 0 then
    update public.stock_management
    set unit = coalesce(p_unit, unit),
        low_stock_threshold = coalesce(p_low_stock_threshold, low_stock_threshold),
        updated_at = now(),
        last_updated = now()
    where item_id::text = p_item_id::text
      and warehouse_id = v_wh;
    return;
  end if;

  if v_diff > 0 then
    v_movement_type := 'adjust_in';
    v_new_batch_id := coalesce(p_batch_id, gen_random_uuid());

    insert into public.batch_balances(item_id, batch_id, warehouse_id, quantity, expiry_date)
    values (p_item_id::text, v_new_batch_id, v_wh, v_diff, null)
    on conflict (item_id, batch_id, warehouse_id)
    do update set
      quantity = public.batch_balances.quantity + excluded.quantity,
      updated_at = now();

    v_unit_cost := v_old_avg;
    v_total_cost := v_diff * v_unit_cost;

    insert into public.inventory_movements(
      item_id, movement_type, quantity, unit_cost, total_cost,
      reference_table, reference_id, occurred_at, created_by, data, batch_id, warehouse_id
    )
    values (
      p_item_id::text, v_movement_type, v_diff, v_unit_cost, v_total_cost,
      'stock_history', null, now(), p_user_id,
      jsonb_build_object('reason', p_reason, 'warehouseId', v_wh, 'batchId', v_new_batch_id),
      v_new_batch_id, v_wh
    )
    returning id into v_movement_id;
    perform public.post_inventory_movement(v_movement_id);
  else
    v_movement_type := case when p_is_wastage then 'wastage_out' else 'adjust_out' end;
    v_needed := abs(v_diff);

    for v_batch in
      select bb.batch_id, bb.quantity, bb.expiry_date
      from public.batch_balances bb
      where bb.item_id = p_item_id::text
        and bb.warehouse_id = v_wh
        and bb.quantity > 0
        and (p_batch_id is null or bb.batch_id = p_batch_id)
      order by bb.expiry_date asc nulls last, bb.batch_id asc
    loop
      exit when v_needed <= 0;

      select coalesce(sum(br.quantity), 0)
      into v_reserved_other
      from public.batch_reservations br
      where br.item_id = p_item_id::text
        and br.warehouse_id = v_wh
        and br.batch_id = v_batch.batch_id;

      v_available := greatest(coalesce(v_batch.quantity, 0) - coalesce(v_reserved_other, 0), 0);
      if v_available <= 0 then
        continue;
      end if;

      v_alloc := least(v_needed, v_available);
      if v_alloc <= 0 then
        continue;
      end if;

      update public.batch_balances
      set quantity = quantity - v_alloc,
          updated_at = now()
      where item_id = p_item_id::text
        and batch_id = v_batch.batch_id
        and warehouse_id = v_wh;

      select im.unit_cost
      into v_unit_cost
      from public.inventory_movements im
      where im.batch_id = v_batch.batch_id
        and im.item_id::text = p_item_id::text
        and im.movement_type = 'purchase_in'
      order by im.occurred_at asc
      limit 1;
      v_unit_cost := coalesce(v_unit_cost, v_old_avg);
      v_total_cost := v_alloc * v_unit_cost;

      insert into public.inventory_movements(
        item_id, movement_type, quantity, unit_cost, total_cost,
        reference_table, reference_id, occurred_at, created_by, data, batch_id, warehouse_id
      )
      values (
        p_item_id::text, v_movement_type, v_alloc, v_unit_cost, v_total_cost,
        'stock_history', null, now(), p_user_id,
        jsonb_build_object('reason', p_reason, 'warehouseId', v_wh, 'batchId', v_batch.batch_id, 'expiryDate', v_batch.expiry_date),
        v_batch.batch_id, v_wh
      )
      returning id into v_movement_id;

      perform public.post_inventory_movement(v_movement_id);

      v_needed := v_needed - v_alloc;
    end loop;

    if v_needed > 0 then
      raise exception 'insufficient unreserved stock for adjustment';
    end if;
  end if;

  v_history_id := gen_random_uuid();
  insert into public.stock_history(id, item_id, date, data)
  values (v_history_id, p_item_id::text, now()::date, jsonb_build_object('reason', p_reason, 'changedBy', p_user_id, 'fromQuantity', v_old_qty, 'toQuantity', p_quantity));

  update public.stock_management
  set available_quantity = coalesce((
        select sum(bb.quantity)
        from public.batch_balances bb
        where bb.item_id = p_item_id::text
          and bb.warehouse_id = v_wh
      ), 0),
      reserved_quantity = coalesce((
        select sum(br.quantity)
        from public.batch_reservations br
        where br.item_id = p_item_id::text
          and br.warehouse_id = v_wh
      ), 0),
      unit = coalesce(p_unit, unit),
      low_stock_threshold = coalesce(p_low_stock_threshold, low_stock_threshold),
      avg_cost = v_old_avg,
      last_updated = now(),
      updated_at = now()
  where item_id::text = p_item_id::text
    and warehouse_id = v_wh;

  update public.menu_items
  set data = jsonb_set(data, '{availableStock}', to_jsonb(p_quantity), true),
      updated_at = now()
  where id = p_item_id::text;

  insert into public.system_audit_logs(action, module, details, performed_by, performed_at, metadata)
  values (
    case when p_is_wastage then 'wastage_recorded' else 'stock_update' end,
    'stock',
    p_reason,
    p_user_id,
    now(),
    jsonb_build_object('itemId', p_item_id::text, 'warehouseId', v_wh, 'fromQuantity', v_old_qty, 'toQuantity', p_quantity, 'delta', v_diff)
  );
end;
$$;


ALTER FUNCTION "public"."manage_menu_item_stock"("p_item_id" "uuid", "p_quantity" numeric, "p_unit" "text", "p_reason" "text", "p_user_id" "uuid", "p_low_stock_threshold" numeric, "p_is_wastage" boolean, "p_batch_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notify_delivery_assignment_change"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_old text;
  v_new text;
  v_link text;
BEGIN
  v_old := COALESCE(NULLIF(OLD.data->>'assignedDeliveryUserId',''), NULL);
  v_new := COALESCE(NULLIF(NEW.data->>'assignedDeliveryUserId',''), NULL);
  v_link := '/admin/orders';
  
  IF v_old IS DISTINCT FROM v_new THEN
    IF v_new IS NOT NULL THEN
      INSERT INTO public.notifications (user_id, title, message, type, link)
      VALUES (v_new::uuid, '    ', ' #' || substring(NEW.id::text, 1, 6), 'order_update', v_link);
    END IF;
    IF v_old IS NOT NULL AND v_new IS NULL THEN
      INSERT INTO public.notifications (user_id, title, message, type, link)
      VALUES (v_old::uuid, '   ', ' #' || substring(NEW.id::text, 1, 6), 'order_update', v_link);
    END IF;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."notify_delivery_assignment_change"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notify_order_created"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_title text;
  v_message text;
  v_link text;
  r_admin record;
BEGIN
  v_link := '/order/' || NEW.id::text;
  
  IF NEW.customer_auth_user_id IS NOT NULL THEN
    v_title := '   ';
    v_message := '    #' || substring(NEW.id::text, 1, 6);
    INSERT INTO public.notifications (user_id, title, message, type, link)
    VALUES (NEW.customer_auth_user_id, v_title, v_message, 'order_update', v_link);
  END IF;
  
  FOR r_admin IN
    SELECT au.auth_user_id
    FROM public.admin_users au
    WHERE au.is_active = true
      AND au.role IN ('owner','manager')
  LOOP
    INSERT INTO public.notifications (user_id, title, message, type, link)
    VALUES (r_admin.auth_user_id, '   ', '  #' || substring(NEW.id::text, 1, 6), 'order_update', v_link);
  END LOOP;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."notify_order_created"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notify_order_status_change"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_title text;
  v_message text;
  v_link text;
BEGIN
  IF OLD.status IS DISTINCT FROM NEW.status THEN
    v_link := '/order/' || NEW.id::text;
    CASE NEW.status
      WHEN 'preparing' THEN
        v_title := '   ';
        v_message := '     #' || substring(NEW.id::text, 1, 6);
      WHEN 'out_for_delivery' THEN
        v_title := '   ';
        v_message := '     #' || substring(NEW.id::text, 1, 6);
      WHEN 'delivered' THEN
        v_title := '  ';
        v_message := '   !    #' || substring(NEW.id::text, 1, 6);
      WHEN 'cancelled' THEN
        v_title := '   ';
        v_message := '     #' || substring(NEW.id::text, 1, 6);
      WHEN 'scheduled' THEN
        v_title := '   ';
        v_message := '     #' || substring(NEW.id::text, 1, 6);
      ELSE
        RETURN NEW;
    END CASE;
    IF NEW.customer_auth_user_id IS NOT NULL THEN
      BEGIN
        INSERT INTO public.notifications (user_id, title, message, type, link)
        VALUES (NEW.customer_auth_user_id, v_title, v_message, 'order_update', v_link);
      EXCEPTION WHEN others THEN
        PERFORM NULL;
      END;
    END IF;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."notify_order_status_change"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."open_cash_shift_for_cashier"("p_cashier_id" "uuid", "p_start_amount" numeric) RETURNS "public"."cash_shifts"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_actor_role text;
  v_exists int;
  v_shift public.cash_shifts%rowtype;
begin
  if auth.uid() is null then
    raise exception 'not allowed';
  end if;

  select au.role
  into v_actor_role
  from public.admin_users au
  where au.auth_user_id = auth.uid()
    and au.is_active = true;

  if v_actor_role is null or v_actor_role not in ('owner','manager') then
    raise exception 'not allowed';
  end if;

  if p_cashier_id is null then
    raise exception 'p_cashier_id is required';
  end if;

  if coalesce(p_start_amount, 0) < 0 then
    raise exception 'invalid start amount';
  end if;

  select count(1)
  into v_exists
  from public.cash_shifts s
  where s.cashier_id = p_cashier_id
    and coalesce(s.status, 'open') = 'open';

  if v_exists > 0 then
    raise exception 'cashier already has an open shift';
  end if;

  insert into public.cash_shifts(cashier_id, opened_at, start_amount, status)
  values (p_cashier_id, now(), coalesce(p_start_amount, 0), 'open')
  returning * into v_shift;

  return v_shift;
end;
$$;


ALTER FUNCTION "public"."open_cash_shift_for_cashier"("p_cashier_id" "uuid", "p_start_amount" numeric) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."order_delivered_at"("p_order_id" "uuid") RETURNS timestamp with time zone
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select coalesce(
    (
      select min(oe.created_at)
      from public.order_events oe
      where oe.order_id = p_order_id
        and oe.to_status = 'delivered'
    ),
    (
      select case when o.status = 'delivered' then o.updated_at else null end
      from public.orders o
      where o.id = p_order_id
      limit 1
    )
  );
$$;


ALTER FUNCTION "public"."order_delivered_at"("p_order_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."orders_validate_delivery_zone_radius"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
declare
  v_source text;
  v_zone_id uuid;
  v_lat double precision;
  v_lng double precision;
  v_zone_lat double precision;
  v_zone_lng double precision;
  v_radius double precision;
  v_is_active boolean;
  v_dist double precision;
begin
  v_source := coalesce(nullif(new.data->>'orderSource',''), '');
  if v_source = 'in_store' then
    return new;
  end if;

  v_zone_id := new.delivery_zone_id;
  if v_zone_id is null
     and nullif(new.data->>'deliveryZoneId','') is not null
     and (new.data->>'deliveryZoneId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
  then
    v_zone_id := (new.data->>'deliveryZoneId')::uuid;
  end if;

  if v_zone_id is null then
    raise exception '    .' using errcode = 'P0001';
  end if;

  if jsonb_typeof(new.data->'location') <> 'object' then
    raise exception '         .' using errcode = 'P0001';
  end if;

  v_lat := nullif(new.data->'location'->>'lat','')::double precision;
  v_lng := nullif(new.data->'location'->>'lng','')::double precision;
  if v_lat is null or v_lng is null then
    raise exception '    .' using errcode = 'P0001';
  end if;

  select
    nullif(dz.data->'coordinates'->>'lat','')::double precision,
    nullif(dz.data->'coordinates'->>'lng','')::double precision,
    nullif(dz.data->'coordinates'->>'radius','')::double precision,
    dz.is_active
  into v_zone_lat, v_zone_lng, v_radius, v_is_active
  from public.delivery_zones dz
  where dz.id = v_zone_id;

  if not found then
    raise exception '   .' using errcode = 'P0001';
  end if;

  if not coalesce(v_is_active, false) then
    raise exception '   .' using errcode = 'P0001';
  end if;

  if v_zone_lat is null or v_zone_lng is null or v_radius is null or v_radius <= 0 then
    raise exception '     .    .' using errcode = 'P0001';
  end if;

  v_dist := public.haversine_distance_meters(v_lat, v_lng, v_zone_lat, v_zone_lng);
  if v_dist > v_radius then
    raise exception '     .' using errcode = 'P0001';
  end if;

  new.delivery_zone_id := v_zone_id;
  new.data := jsonb_set(new.data, '{deliveryZoneId}', to_jsonb(v_zone_id::text), true);
  return new;
end;
$_$;


ALTER FUNCTION "public"."orders_validate_delivery_zone_radius"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."owner_finalize_approval_request"("p_request_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_req record;
begin
  if not public.is_owner() then
    raise exception 'not authorized';
  end if;
  select *
  into v_req
  from public.approval_requests
  where id = p_request_id
  for update;
  if not found then
    raise exception 'approval request not found';
  end if;
  if v_req.status <> 'pending' then
    return;
  end if;
  update public.approval_steps
  set status = 'approved',
      action_by = auth.uid(),
      action_at = now()
  where request_id = p_request_id
    and status = 'pending';
  update public.approval_requests
  set status = 'approved',
      approved_by = auth.uid(),
      approved_at = now()
  where id = p_request_id
    and status = 'pending';
end;
$$;


ALTER FUNCTION "public"."owner_finalize_approval_request"("p_request_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."pgrst_ddl_watch"() RETURNS "event_trigger"
    LANGUAGE "plpgsql"
    AS $$
declare
  cmd record;
begin
  for cmd in select * from pg_event_trigger_ddl_commands()
  loop
    if cmd.command_tag in (
      'CREATE FUNCTION','ALTER FUNCTION','DROP FUNCTION',
      'CREATE TABLE','ALTER TABLE','DROP TABLE',
      'CREATE VIEW','ALTER VIEW','DROP VIEW',
      'COMMENT'
    ) and cmd.schema_name is distinct from 'pg_temp' then
      perform pg_notify('pgrst','reload schema');
    end if;
  end loop;
end; $$;


ALTER FUNCTION "public"."pgrst_ddl_watch"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."pgrst_drop_watch"() RETURNS "event_trigger"
    LANGUAGE "plpgsql"
    AS $$
declare
  obj record;
begin
  for obj in select * from pg_event_trigger_dropped_objects()
  loop
    if obj.object_type in ('function','table','view','type','trigger','schema','rule')
       and obj.is_temporary is false then
      perform pg_notify('pgrst','reload schema');
    end if;
  end loop;
end; $$;


ALTER FUNCTION "public"."pgrst_drop_watch"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."post_cash_shift_close"("p_shift_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_shift record;
  v_entry_id uuid;
  v_cash uuid;
  v_over_short uuid;
  v_diff numeric;
begin
  if p_shift_id is null then
    raise exception 'p_shift_id is required';
  end if;
  select *
  into v_shift
  from public.cash_shifts s
  where s.id = p_shift_id;
  if not found then
    raise exception 'cash shift not found';
  end if;
  if coalesce(v_shift.status, 'open') <> 'closed' then
    return;
  end if;
  v_cash := public.get_account_id_by_code('1010');
  v_over_short := public.get_account_id_by_code('6110');
  v_diff := coalesce(v_shift.difference, coalesce(v_shift.end_amount, 0) - coalesce(v_shift.expected_amount, 0));
  if abs(v_diff) <= 1e-9 then
    return;
  end if;
  insert into public.journal_entries(entry_date, memo, source_table, source_id, source_event, created_by)
  values (
    coalesce(v_shift.closed_at, now()),
    concat('Cash shift close ', v_shift.id::text),
    'cash_shifts',
    v_shift.id::text,
    'closed',
    auth.uid()
  )
  on conflict (source_table, source_id, source_event)
  do update set entry_date = excluded.entry_date, memo = excluded.memo
  returning id into v_entry_id;
  delete from public.journal_lines jl where jl.journal_entry_id = v_entry_id;
  if v_diff < 0 then
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values
      (v_entry_id, v_over_short, abs(v_diff), 0, 'Cash shortage'),
      (v_entry_id, v_cash, 0, abs(v_diff), 'Adjust cash to counted');
  else
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values
      (v_entry_id, v_cash, v_diff, 0, 'Adjust cash to counted'),
      (v_entry_id, v_over_short, 0, v_diff, 'Cash overage');
  end if;
end;
$$;


ALTER FUNCTION "public"."post_cash_shift_close"("p_shift_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."post_import_expense"("p_import_expense_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_ie record;
  v_amount numeric;
  v_settings jsonb;
  v_accounts jsonb;
  v_entry_id uuid;
  v_ap uuid;
  v_cash uuid;
  v_bank uuid;
  v_clearing uuid;
  v_credit_account uuid;
  v_event text;
  v_occurred_at timestamptz;
begin
  if p_import_expense_id is null then
    raise exception 'p_import_expense_id is required';
  end if;

  select *
  into v_ie
  from public.import_expenses
  where id = p_import_expense_id;

  if not found then
    raise exception 'import expense not found';
  end if;

  v_amount := coalesce(v_ie.amount, 0) * coalesce(v_ie.exchange_rate, 1);
  if v_amount <= 0 then
    return;
  end if;

  v_occurred_at := coalesce(v_ie.paid_at::timestamptz, v_ie.created_at, now());

  v_ap := public.get_account_id_by_code('2010');
  v_cash := public.get_account_id_by_code('1010');
  v_bank := public.get_account_id_by_code('1020');
  v_clearing := public.get_account_id_by_code('2060');

  if to_regclass('public.app_settings') is not null then
    select s.data
    into v_settings
    from public.app_settings s
    where s.id in ('singleton','app')
    order by (s.id = 'singleton') desc
    limit 1;

    v_accounts := coalesce(v_settings->'settings'->'accounting_accounts', v_settings->'accounting_accounts', '{}'::jsonb);
    begin
      v_clearing := coalesce(nullif(v_accounts->>'landed_cost_clearing', '')::uuid, v_clearing);
    exception when others then
      null;
    end;
  end if;

  if v_clearing is null then
    raise exception 'landed cost clearing account not found';
  end if;

  if v_ie.paid_at is not null then
    v_event := 'paid';
    v_credit_account := case when coalesce(v_ie.payment_method, 'cash') = 'bank' then v_bank else v_cash end;
  else
    v_event := 'accrual';
    v_credit_account := v_ap;
  end if;

  if v_event = 'paid' then
    delete from public.journal_lines jl
    using public.journal_entries je
    where jl.journal_entry_id = je.id
      and je.source_table = 'import_expenses'
      and je.source_id = p_import_expense_id::text
      and je.source_event = 'accrual';
    delete from public.journal_entries je
    where je.source_table = 'import_expenses'
      and je.source_id = p_import_expense_id::text
      and je.source_event = 'accrual';
  else
    delete from public.journal_lines jl
    using public.journal_entries je
    where jl.journal_entry_id = je.id
      and je.source_table = 'import_expenses'
      and je.source_id = p_import_expense_id::text
      and je.source_event = 'paid';
    delete from public.journal_entries je
    where je.source_table = 'import_expenses'
      and je.source_id = p_import_expense_id::text
      and je.source_event = 'paid';
  end if;

  insert into public.journal_entries(entry_date, memo, source_table, source_id, source_event, created_by)
  values (
    v_occurred_at,
    concat('Import expense ', coalesce(v_ie.invoice_number, v_ie.id::text)),
    'import_expenses',
    p_import_expense_id::text,
    v_event,
    coalesce(v_ie.created_by, auth.uid())
  )
  on conflict (source_table, source_id, source_event)
  do update set entry_date = excluded.entry_date, memo = excluded.memo
  returning id into v_entry_id;

  delete from public.journal_lines jl where jl.journal_entry_id = v_entry_id;

  insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
  values
    (v_entry_id, v_clearing, v_amount, 0, 'Landed cost service'),
    (v_entry_id, v_credit_account, 0, v_amount, case when v_event = 'paid' then 'Cash/Bank paid' else 'Accounts payable' end);

  perform public.check_journal_entry_balance(v_entry_id);
end;
$$;


ALTER FUNCTION "public"."post_import_expense"("p_import_expense_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."post_inventory_movement"("p_movement_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_mv record;
  v_entry_id uuid;
  v_inventory uuid;
  v_cogs uuid;
  v_ap uuid;
  v_shrinkage uuid;
  v_gain uuid;
  v_vat_input uuid;
  v_supplier_tax_total numeric;
begin
  perform public._require_staff('accounting.post');
  if p_movement_id is null then
    raise exception 'p_movement_id is required';
  end if;

  select *
  into v_mv
  from public.inventory_movements im
  where im.id = p_movement_id;
  if not found then
    raise exception 'inventory movement not found';
  end if;

  if v_mv.reference_table = 'production_orders' then
    return;
  end if;

  if v_mv.movement_type in ('transfer_out', 'transfer_in') then
    return;
  end if;

  if exists (
    select 1 from public.journal_entries je
    where je.source_table = 'inventory_movements'
      and je.source_id = v_mv.id::text
      and je.source_event = v_mv.movement_type
  ) then
    insert into public.system_audit_logs(action, module, details, performed_by, performed_at, metadata)
    values (
      'skip',
      'accounting',
      concat('Skipped posting; already exists for inventory movement ', v_mv.id::text, ' event ', v_mv.movement_type),
      auth.uid(),
      now(),
      jsonb_build_object(
        'source_table', 'inventory_movements',
        'source_id', v_mv.id::text,
        'source_event', v_mv.movement_type,
        'movement_id', v_mv.id,
        'movement_type', v_mv.movement_type
      )
    );
    return;
  end if;

  v_inventory := public.get_account_id_by_code('1410');
  v_cogs := public.get_account_id_by_code('5010');
  v_ap := public.get_account_id_by_code('2010');
  v_shrinkage := public.get_account_id_by_code('5020');
  v_gain := public.get_account_id_by_code('4021');
  v_vat_input := public.get_account_id_by_code('1420');
  v_supplier_tax_total := coalesce(nullif((v_mv.data->>'supplier_tax_total')::numeric, null), 0);

  insert into public.journal_entries(entry_date, memo, source_table, source_id, source_event, created_by)
  values (
    v_mv.occurred_at,
    concat('Inventory movement ', v_mv.movement_type, ' ', v_mv.item_id),
    'inventory_movements',
    v_mv.id::text,
    v_mv.movement_type,
    v_mv.created_by
  )
  returning id into v_entry_id;

  if v_mv.movement_type = 'purchase_in' then
    if v_supplier_tax_total > 0 and v_vat_input is not null then
      insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
      values
        (v_entry_id, v_inventory, v_mv.total_cost - v_supplier_tax_total, 0, 'Inventory increase (net)'),
        (v_entry_id, v_vat_input, v_supplier_tax_total, 0, 'VAT input'),
        (v_entry_id, v_ap, 0, v_mv.total_cost, 'Supplier payable');
    else
      insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
      values
        (v_entry_id, v_inventory, v_mv.total_cost, 0, 'Inventory increase'),
        (v_entry_id, v_ap, 0, v_mv.total_cost, 'Supplier payable');
    end if;
  elsif v_mv.movement_type in ('sale_out','expired_out','wastage_out') then
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values
      (v_entry_id, v_cogs, v_mv.total_cost, 0, case when v_mv.movement_type = 'sale_out' then 'COGS' else concat(v_mv.movement_type, ' (COGS)') end),
      (v_entry_id, v_inventory, 0, v_mv.total_cost, 'Inventory decrease');
  elsif v_mv.movement_type = 'adjust_out' then
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values
      (v_entry_id, v_shrinkage, v_mv.total_cost, 0, 'Adjustment out'),
      (v_entry_id, v_inventory, 0, v_mv.total_cost, 'Inventory decrease');
  elsif v_mv.movement_type = 'adjust_in' then
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values
      (v_entry_id, v_inventory, v_mv.total_cost, 0, 'Adjustment in'),
      (v_entry_id, v_gain, 0, v_mv.total_cost, 'Inventory gain');
  elsif v_mv.movement_type = 'return_out' then
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values
      (v_entry_id, v_ap, v_mv.total_cost, 0, 'Vendor credit'),
      (v_entry_id, v_inventory, 0, v_mv.total_cost, 'Inventory decrease');
  elsif v_mv.movement_type = 'return_in' then
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values
      (v_entry_id, v_inventory, v_mv.total_cost, 0, 'Inventory restore (return)'),
      (v_entry_id, v_cogs, 0, v_mv.total_cost, 'Reverse COGS');
  end if;

  perform public.check_journal_entry_balance(v_entry_id);
end;
$$;


ALTER FUNCTION "public"."post_inventory_movement"("p_movement_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."post_invoice_issued"("p_order_id" "uuid", "p_issued_at" timestamp with time zone) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_order record;
  v_data jsonb;
  v_is_cod boolean := false;
  v_entry_id uuid;
  v_total numeric := 0;
  v_subtotal numeric := 0;
  v_discount_amount numeric := 0;
  v_delivery_fee numeric := 0;
  v_tax_amount numeric := 0;
  v_deposits_paid numeric := 0;
  v_ar_amount numeric := 0;
  v_accounts jsonb;
  v_ar uuid;
  v_deposits uuid;
  v_sales uuid;
  v_delivery_income uuid;
  v_vat_payable uuid;
begin
  if not (auth.role() = 'service_role' or public.has_admin_permission('accounting.manage')) then
    raise exception 'not authorized to post accounting entries';
  end if;
  if p_order_id is null then
    raise exception 'p_order_id is required';
  end if;
  select *
  into v_order
  from public.orders o
  where o.id = p_order_id
  for update;
  if not found then
    raise exception 'order not found';
  end if;
  v_data := coalesce(v_order.data, '{}'::jsonb);
  v_is_cod := public._is_cod_delivery_order(v_data, v_order.delivery_zone_id);
  if v_is_cod then
    return;
  end if;
  select s.data->'accounting_accounts' into v_accounts from public.app_settings s where s.id = 'singleton';
  v_ar := public.get_account_id_by_code(coalesce(v_accounts->>'ar','1200'));
  v_deposits := public.get_account_id_by_code(coalesce(v_accounts->>'deposits','2050'));
  v_sales := public.get_account_id_by_code(coalesce(v_accounts->>'sales','4010'));
  v_delivery_income := public.get_account_id_by_code(coalesce(v_accounts->>'delivery_income','4020'));
  v_vat_payable := public.get_account_id_by_code(coalesce(v_accounts->>'vat_payable','2020'));
  v_total := coalesce(nullif((v_data->'invoiceSnapshot'->>'total')::numeric, null), coalesce(nullif((v_data->>'total')::numeric, null), 0));
  if v_total <= 0 then
    return;
  end if;
  v_subtotal := coalesce(nullif((v_data->'invoiceSnapshot'->>'subtotal')::numeric, null), coalesce(nullif((v_data->>'subtotal')::numeric, null), 0));
  v_discount_amount := coalesce(nullif((v_data->'invoiceSnapshot'->>'discountAmount')::numeric, null), coalesce(nullif((v_data->>'discountAmount')::numeric, null), 0));
  v_delivery_fee := coalesce(nullif((v_data->'invoiceSnapshot'->>'deliveryFee')::numeric, null), coalesce(nullif((v_data->>'deliveryFee')::numeric, null), 0));
  v_tax_amount := coalesce(nullif((v_data->'invoiceSnapshot'->>'taxAmount')::numeric, null), coalesce(nullif((v_data->>'taxAmount')::numeric, null), 0));
  v_tax_amount := least(greatest(0, v_tax_amount), v_total);
  v_delivery_fee := least(greatest(0, v_delivery_fee), v_total - v_tax_amount);
  select coalesce(sum(p.amount), 0)
  into v_deposits_paid
  from public.payments p
  where p.reference_table = 'orders'
    and p.reference_id = p_order_id::text
    and p.direction = 'in'
    and p.occurred_at < coalesce(p_issued_at, now());
  v_deposits_paid := least(v_total, greatest(0, coalesce(v_deposits_paid, 0)));
  v_ar_amount := greatest(0, v_total - v_deposits_paid);
  begin
    insert into public.journal_entries(entry_date, memo, source_table, source_id, source_event, created_by)
    values (
      coalesce(p_issued_at, now()),
      concat('Order invoiced ', p_order_id::text),
      'orders',
      p_order_id::text,
      'invoiced',
      auth.uid()
    )
    returning id into v_entry_id;
  exception
    when unique_violation then
      raise exception 'posting already exists for this source; create a reversal instead';
  end;
  if v_deposits_paid > 0 and v_deposits is not null then
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values (v_entry_id, v_deposits, v_deposits_paid, 0, 'Apply customer deposit');
  end if;
  if v_ar_amount > 0 and v_ar is not null then
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values (v_entry_id, v_ar, v_ar_amount, 0, 'Accounts receivable');
  end if;
  if (v_total - v_delivery_fee - v_tax_amount) > 0 and v_sales is not null then
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values (v_entry_id, v_sales, 0, (v_total - v_delivery_fee - v_tax_amount), 'Sales revenue');
  end if;
  if v_delivery_fee > 0 and v_delivery_income is not null then
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values (v_entry_id, v_delivery_income, 0, v_delivery_fee, 'Delivery income');
  end if;
  if v_tax_amount > 0 and v_vat_payable is not null then
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values (v_entry_id, v_vat_payable, 0, v_tax_amount, 'VAT payable');
  end if;
  perform public.check_journal_entry_balance(v_entry_id);
  perform public.sync_ar_on_invoice(p_order_id);
end;
$$;


ALTER FUNCTION "public"."post_invoice_issued"("p_order_id" "uuid", "p_issued_at" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."post_order_delivery"("p_order_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_order record;
  v_entry_id uuid;
  v_total numeric;
  v_ar uuid;
  v_deposits uuid;
  v_sales uuid;
  v_delivery_income uuid;
  v_vat_payable uuid;
  v_promo_expense_account uuid;
  v_delivered_at timestamptz;
  v_deposits_paid numeric;
  v_ar_amount numeric;
  v_discount_amount numeric;
  v_delivery_fee numeric;
  v_tax_amount numeric;
  v_items_revenue numeric;
  v_sales_amount numeric;
  v_promo_expense_total numeric := 0;
begin
  if not (auth.role() = 'service_role' or public.has_admin_permission('accounting.manage')) then
    raise exception 'not authorized to post accounting entries';
  end if;
  if p_order_id is null then
    raise exception 'p_order_id is required';
  end if;

  select o.*
  into v_order
  from public.orders o
  where o.id = p_order_id;

  if not found then
    raise exception 'order not found';
  end if;

  v_total := coalesce(nullif((v_order.data->>'total')::numeric, null), 0);
  if v_total <= 0 then
    return;
  end if;

  v_ar := public.get_account_id_by_code('1200');
  v_deposits := public.get_account_id_by_code('2050');
  v_sales := public.get_account_id_by_code('4010');
  v_delivery_income := public.get_account_id_by_code('4020');
  v_vat_payable := public.get_account_id_by_code('2020');
  v_promo_expense_account := coalesce(public.get_account_id_by_code('6150'), public.get_account_id_by_code('6100'));

  v_discount_amount := coalesce(nullif((v_order.data->>'discountAmount')::numeric, null), 0);
  v_delivery_fee := coalesce(nullif((v_order.data->>'deliveryFee')::numeric, null), 0);
  v_tax_amount := coalesce(nullif((v_order.data->>'taxAmount')::numeric, null), 0);

  v_tax_amount := least(greatest(0, v_tax_amount), v_total);
  v_delivery_fee := least(greatest(0, v_delivery_fee), v_total - v_tax_amount);
  v_items_revenue := greatest(0, v_total - v_delivery_fee - v_tax_amount);

  select coalesce(sum(coalesce(nullif((pl->>'promotionExpense')::numeric, null), 0)), 0)
  into v_promo_expense_total
  from jsonb_array_elements(coalesce(v_order.data->'promotionLines', '[]'::jsonb)) as pl;

  v_promo_expense_total := public._money_round(coalesce(v_promo_expense_total, 0));
  v_sales_amount := public._money_round(v_items_revenue + v_promo_expense_total);

  v_delivered_at := public.order_delivered_at(p_order_id);
  if v_delivered_at is null then
    v_delivered_at := coalesce(v_order.updated_at, now());
  end if;

  select coalesce(sum(p.amount), 0)
  into v_deposits_paid
  from public.payments p
  where p.reference_table = 'orders'
    and p.reference_id = p_order_id::text
    and p.direction = 'in'
    and p.occurred_at < v_delivered_at;

  v_deposits_paid := least(v_total, greatest(0, coalesce(v_deposits_paid, 0)));
  v_ar_amount := greatest(0, v_total - v_deposits_paid);

  insert into public.journal_entries(entry_date, memo, source_table, source_id, source_event, created_by)
  values (
    coalesce(v_order.updated_at, now()),
    concat('Order delivered ', v_order.id::text),
    'orders',
    v_order.id::text,
    'delivered',
    auth.uid()
  )
  on conflict (source_table, source_id, source_event)
  do update set entry_date = excluded.entry_date, memo = excluded.memo
  returning id into v_entry_id;

  delete from public.journal_lines jl where jl.journal_entry_id = v_entry_id;

  if v_deposits_paid > 0 then
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values (v_entry_id, v_deposits, public._money_round(v_deposits_paid), 0, 'Apply customer deposit');
  end if;

  if v_ar_amount > 0 then
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values (v_entry_id, v_ar, public._money_round(v_ar_amount), 0, 'Accounts receivable');
  end if;

  if v_sales_amount > 0 then
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values (v_entry_id, v_sales, 0, public._money_round(v_sales_amount), 'Sales revenue');
  end if;

  if v_promo_expense_total > 0 and v_promo_expense_account is not null then
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values (v_entry_id, v_promo_expense_account, public._money_round(v_promo_expense_total), 0, 'Promotion expense');
  end if;

  if v_delivery_fee > 0 and v_delivery_income is not null then
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values (v_entry_id, v_delivery_income, 0, public._money_round(v_delivery_fee), 'Delivery income');
  end if;

  if v_tax_amount > 0 and v_vat_payable is not null then
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values (v_entry_id, v_vat_payable, 0, public._money_round(v_tax_amount), 'VAT payable');
  end if;
end;
$$;


ALTER FUNCTION "public"."post_order_delivery"("p_order_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."post_payment"("p_payment_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_pay record;
  v_entry_id uuid;
  v_cash uuid;
  v_bank uuid;
  v_ar uuid;
  v_ap uuid;
  v_expenses uuid;
  v_gain_real uuid;
  v_loss_real uuid;
  v_debit_account uuid;
  v_credit_account uuid;
  v_amount_base numeric;
  v_order_id uuid;
  v_open_ar numeric;
  v_settle_ar numeric;
  v_po_id uuid;
  v_po_base_total numeric;
  v_po_paid_base numeric;
  v_settle_ap numeric;
begin
  if p_payment_id is null then
    raise exception 'p_payment_id is required';
  end if;

  select * into v_pay
  from public.payments p
  where p.id = p_payment_id;

  if not found then
    raise exception 'payment not found';
  end if;

  select je.id into v_entry_id
  from public.journal_entries je
  where je.source_table = 'payments'
    and je.source_id = v_pay.id::text
  limit 1;

  if v_entry_id is not null then
    return;
  end if;

  v_amount_base := coalesce(v_pay.base_amount, v_pay.amount, 0);
  v_cash := public.get_account_id_by_code('1010');
  v_bank := public.get_account_id_by_code('1020');
  v_ar := public.get_account_id_by_code('1200');
  v_ap := public.get_account_id_by_code('2010');
  v_expenses := public.get_account_id_by_code('6100');
  v_gain_real := public.get_account_id_by_code('6200');
  v_loss_real := public.get_account_id_by_code('6201');

  if v_pay.method = 'cash' then
    v_debit_account := v_cash;
    v_credit_account := v_cash;
  else
    v_debit_account := v_bank;
    v_credit_account := v_bank;
  end if;

  if v_pay.direction = 'in' and v_pay.reference_table = 'orders' then
    v_order_id := nullif(v_pay.reference_id, '')::uuid;
    if v_order_id is null then
      raise exception 'invalid order reference_id';
    end if;

    insert into public.journal_entries(entry_date, memo, source_table, source_id, source_event, created_by)
    values (
      v_pay.occurred_at,
      concat('Order payment ', coalesce(v_pay.reference_id, v_pay.id::text)),
      'payments',
      v_pay.id::text,
      concat('in:orders:', coalesce(v_pay.reference_id, '')),
      v_pay.created_by
    )
    returning id into v_entry_id;

    select coalesce(open_balance, 0) into v_open_ar
    from public.ar_open_items
    where invoice_id = v_order_id and status = 'open'
    limit 1;

    if v_open_ar is null then
      select coalesce(o.base_total, 0) - coalesce((
        select sum(coalesce(p.base_amount, p.amount))
        from public.payments p
        where p.reference_table = 'orders'
          and p.direction = 'in'
          and p.reference_id = v_order_id::text
          and p.id <> v_pay.id
      ), 0)
      into v_open_ar
      from public.orders o
      where o.id = v_order_id;
    end if;

    v_settle_ar := greatest(0, v_open_ar);

    if v_amount_base >= v_settle_ar then
      insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
      values
        (v_entry_id, v_debit_account, v_amount_base, 0, 'Cash/Bank received'),
        (v_entry_id, v_ar, 0, v_settle_ar, 'Settle receivable');
      if (v_amount_base - v_settle_ar) > 0.0000001 then
        insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
        values (v_entry_id, v_gain_real, 0, v_amount_base - v_settle_ar, 'FX Gain realized');
      end if;
    else
      insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
      values
        (v_entry_id, v_debit_account, v_amount_base, 0, 'Cash/Bank received'),
        (v_entry_id, v_ar, 0, v_settle_ar, 'Settle receivable'),
        (v_entry_id, v_loss_real, v_settle_ar - v_amount_base, 0, 'FX Loss realized');
    end if;

    update public.ar_open_items
    set status = 'closed',
        open_balance = 0,
        closed_at = v_pay.occurred_at
    where invoice_id = v_order_id and status = 'open';
    return;
  end if;

  if v_pay.direction = 'out' and v_pay.reference_table = 'purchase_orders' then
    v_po_id := nullif(v_pay.reference_id, '')::uuid;
    if v_po_id is null then
      raise exception 'invalid purchase order reference_id';
    end if;

    select coalesce(base_total, 0) into v_po_base_total
    from public.purchase_orders
    where id = v_po_id;

    select coalesce(sum(coalesce(p.base_amount, p.amount)), 0)
    into v_po_paid_base
    from public.payments p
    where p.reference_table = 'purchase_orders'
      and p.direction = 'out'
      and p.reference_id = v_po_id::text
      and p.id <> v_pay.id;

    v_settle_ap := greatest(0, v_po_base_total - coalesce(v_po_paid_base, 0));

    insert into public.journal_entries(entry_date, memo, source_table, source_id, source_event, created_by)
    values (
      v_pay.occurred_at,
      concat('Supplier payment ', coalesce(v_pay.reference_id, v_pay.id::text)),
      'payments',
      v_pay.id::text,
      concat('out:purchase_orders:', coalesce(v_pay.reference_id, '')),
      v_pay.created_by
    )
    returning id into v_entry_id;

    if v_amount_base >= v_settle_ap then
      insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
      values
        (v_entry_id, v_ap, v_settle_ap, 0, 'Settle payable'),
        (v_entry_id, v_credit_account, 0, v_amount_base, 'Cash/Bank paid');
      if (v_amount_base - v_settle_ap) > 0.0000001 then
        insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
        values (v_entry_id, v_loss_real, v_amount_base - v_settle_ap, 0, 'FX Loss realized');
      end if;
    else
      insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
      values
        (v_entry_id, v_ap, v_settle_ap, 0, 'Settle payable'),
        (v_entry_id, v_credit_account, 0, v_amount_base, 'Cash/Bank paid'),
        (v_entry_id, v_gain_real, 0, v_settle_ap - v_amount_base, 'FX Gain realized');
    end if;
    return;
  end if;

  if v_pay.direction = 'out' and v_pay.reference_table = 'expenses' then
    insert into public.journal_entries(entry_date, memo, source_table, source_id, source_event, created_by)
    values (
      v_pay.occurred_at,
      concat('Expense payment ', coalesce(v_pay.reference_id, v_pay.id::text)),
      'payments',
      v_pay.id::text,
      concat('out:expenses:', coalesce(v_pay.reference_id, '')),
      v_pay.created_by
    )
    returning id into v_entry_id;

    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values
      (v_entry_id, v_expenses, v_amount_base, 0, 'Operating expense'),
      (v_entry_id, v_credit_account, 0, v_amount_base, 'Cash/Bank paid');
    return;
  end if;
end;
$$;


ALTER FUNCTION "public"."post_payment"("p_payment_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."post_production_order"("p_order_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_entry_id uuid;
  v_inventory uuid;
  v_shrinkage uuid;
  v_gain uuid;
  v_inputs_total numeric;
  v_outputs_total numeric;
begin
  if p_order_id is null then
    raise exception 'p_order_id is required';
  end if;
  v_inventory := public.get_account_id_by_code('1410');
  v_shrinkage := public.get_account_id_by_code('5020');
  v_gain := public.get_account_id_by_code('4021');

  select coalesce(sum(total_cost), 0) into v_inputs_total
  from public.production_order_inputs where order_id = p_order_id;
  select coalesce(sum(total_cost), 0) into v_outputs_total
  from public.production_order_outputs where order_id = p_order_id;

  insert into public.journal_entries(entry_date, memo, source_table, source_id, source_event, created_by)
  values (
    coalesce((select occurred_at from public.production_orders where id = p_order_id), now()),
    concat('Production order ', p_order_id::text),
    'production_orders',
    p_order_id::text,
    'posted',
    auth.uid()
  )
  on conflict (source_table, source_id, source_event)
  do update set entry_date = excluded.entry_date, memo = excluded.memo
  returning id into v_entry_id;

  delete from public.journal_lines jl where jl.journal_entry_id = v_entry_id;

  if v_outputs_total > 0 then
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values (v_entry_id, v_inventory, v_outputs_total, 0, 'Production outputs to inventory');
  end if;
  if v_inputs_total > 0 then
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values (v_entry_id, v_inventory, 0, v_inputs_total, 'Production inputs from inventory');
  end if;

  if abs(v_outputs_total - v_inputs_total) > 1e-6 then
    if v_outputs_total > v_inputs_total then
      insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
      values (v_entry_id, v_gain, 0, v_outputs_total - v_inputs_total, 'Production variance (gain)');
    else
      insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
      values (v_entry_id, v_shrinkage, v_inputs_total - v_outputs_total, 0, 'Production variance (loss)');
    end if;
  end if;
end;
$$;


ALTER FUNCTION "public"."post_production_order"("p_order_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."post_supplier_invoice_variance"("p_invoice_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_inv record;
  v_variance numeric;
  v_entry_id uuid;
  v_ap uuid;
  v_ppv uuid;
begin
  select * into v_inv from public.supplier_invoices where id = p_invoice_id;
  if not found then
    raise exception 'supplier invoice not found';
  end if;
  if v_inv.status <> 'matched' then
    raise exception 'invoice is not matched';
  end if;

  select coalesce(sum(line_total), 0) into v_variance
  from public.supplier_invoice_lines
  where invoice_id = p_invoice_id;

  v_variance := v_variance - coalesce(v_inv.total_amount, 0);
  if abs(v_variance) < 0.0001 then
    update public.supplier_invoices set status = 'posted' where id = p_invoice_id;
    return;
  end if;

  v_ap := public.get_account_id_by_code('2010');
  v_ppv := public.get_account_id_by_code('5030');

  insert into public.journal_entries(entry_date, memo, source_table, source_id, source_event, created_by)
  values (
    now(),
    concat('Supplier invoice variance ', v_inv.invoice_number),
    'supplier_invoices',
    v_inv.id::text,
    'variance',
    auth.uid()
  )
  returning id into v_entry_id;

  if v_variance > 0 then
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values
      (v_entry_id, v_ppv, v_variance, 0, 'Price variance'),
      (v_entry_id, v_ap, 0, v_variance, 'Increase payable');
  else
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values
      (v_entry_id, v_ap, abs(v_variance), 0, 'Decrease payable'),
      (v_entry_id, v_ppv, 0, abs(v_variance), 'Price variance');
  end if;

  perform public.check_journal_entry_balance(v_entry_id);
  update public.supplier_invoices set status = 'posted' where id = p_invoice_id;
end;
$$;


ALTER FUNCTION "public"."post_supplier_invoice_variance"("p_invoice_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."prevent_audit_log_modification"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  IF (TG_OP = 'UPDATE' OR TG_OP = 'DELETE') THEN
    RAISE EXCEPTION 'Modification of audit logs is strictly prohibited.';
  END IF;
  RETURN NULL;
END;
$$;


ALTER FUNCTION "public"."prevent_audit_log_modification"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."prevent_multiple_owners"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if new.role = 'owner' then
    if exists (
      select 1
      from public.admin_users au
      where au.auth_user_id <> coalesce(new.auth_user_id, old.auth_user_id)
        and au.role = 'owner'
    ) then
      raise exception 'only_one_owner';
    end if;
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."prevent_multiple_owners"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."process_expired_items"() RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  processed_count integer := 0;
  v_wh_id uuid;
  v_has_warehouse boolean := false;
  v_batch record;
  v_stock record;
  v_wastage_qty numeric;
  v_effective_wastage_qty numeric;
  v_wastage_id uuid;
  v_reserved_batches jsonb;
  v_reserved_entry jsonb;
  v_reserved_list jsonb;
  v_order_id uuid;
  v_order_id_text text;
  v_unit_cost numeric;
  v_movement_id uuid;
  v_new_available numeric;
  v_new_reserved numeric;
  v_expired_batch_key text;
  v_reserved_cancel_total numeric;
  v_order_reserved_qty numeric;
  v_need numeric;
  v_candidate record;
  v_candidate_key text;
  v_candidate_entry jsonb;
  v_candidate_list jsonb;
  v_candidate_reserved numeric;
  v_free numeric;
  v_alloc numeric;
  v_list_new jsonb;
  v_key text;
  v_tmp_list jsonb;
  v_tmp_list_new jsonb;
  v_total_available numeric;
  v_qr numeric;
  v_qc numeric;
  v_batch_expiry date;
begin
  if not public.is_admin() then
    raise exception 'not allowed';
  end if;

  v_has_warehouse := (to_regclass('public.warehouses') is not null);

  for v_batch in
    select *
    from public.v_food_batch_balances v
    where v.expiry_date is not null
      and v.expiry_date < current_date
      and greatest(coalesce(v.remaining_qty, 0), 0) > 0
    order by v.expiry_date asc, v.batch_id asc
  loop
    processed_count := processed_count + 1;
    v_wh_id := v_batch.warehouse_id;

    if v_has_warehouse then
      if v_wh_id is null then
        select w.id
        into v_wh_id
        from public.warehouses w
        order by w.code asc
        limit 1;
      end if;
      if v_wh_id is null then
        raise exception 'No warehouse found for expiry processing';
      end if;
    end if;

    v_wastage_qty := greatest(coalesce(v_batch.remaining_qty, 0), 0);
    if v_wastage_qty <= 0 then
      continue;
    end if;

    if v_has_warehouse and v_wh_id is not null then
      select *
      into v_stock
      from public.stock_management sm
      where sm.item_id::text = v_batch.item_id
        and sm.warehouse_id = v_wh_id
      for update;
    else
      select *
      into v_stock
      from public.stock_management sm
      where sm.item_id::text = v_batch.item_id
      for update;
    end if;

    if not found then
      continue;
    end if;

    v_effective_wastage_qty := v_wastage_qty;

    select
      b.quantity_received,
      b.quantity_consumed,
      b.unit_cost,
      b.expiry_date
    into v_qr, v_qc, v_unit_cost, v_batch_expiry
    from public.batches b
    where b.id = v_batch.batch_id
      and b.item_id::text = v_batch.item_id::text
      and (not v_has_warehouse or b.warehouse_id is not distinct from v_wh_id)
    for update;

    if not found then
      continue;
    end if;

    v_unit_cost := coalesce(v_unit_cost, v_stock.avg_cost, 0);

    v_reserved_batches := coalesce(v_stock.data->'reservedBatches', '{}'::jsonb);
    v_expired_batch_key := v_batch.batch_id::text;

    v_reserved_entry := v_reserved_batches->v_expired_batch_key;
    v_reserved_list :=
      case
        when v_reserved_entry is null then '[]'::jsonb
        when jsonb_typeof(v_reserved_entry) = 'array' then v_reserved_entry
        when jsonb_typeof(v_reserved_entry) = 'object' then jsonb_build_array(v_reserved_entry)
        else '[]'::jsonb
      end;

    v_reserved_cancel_total := 0;

    for v_order_id_text, v_order_reserved_qty in
      select
        (e->>'orderId') as order_id_text,
        coalesce(nullif(e->>'qty','')::numeric, 0) as qty
      from jsonb_array_elements(v_reserved_list) e
    loop
      if v_order_id_text is null or v_order_id_text = '' then
        continue;
      end if;
      begin
        v_order_id := v_order_id_text::uuid;
      exception when others then
        v_order_id := null;
      end;
      if v_order_id is null then
        continue;
      end if;

      v_need := greatest(coalesce(v_order_reserved_qty, 0), 0);
      if v_need <= 0 then
        continue;
      end if;

      v_reserved_cancel_total := v_reserved_cancel_total + v_need;

      for v_candidate in
        select
          b2.batch_id,
          b2.expiry_date,
          b2.remaining_qty
        from public.v_food_batch_balances b2
        where b2.item_id = v_batch.item_id
          and b2.warehouse_id is not distinct from v_wh_id
          and b2.batch_id <> v_batch.batch_id
          and (b2.expiry_date is null or b2.expiry_date >= current_date)
          and greatest(coalesce(b2.remaining_qty, 0), 0) > 0
        order by b2.expiry_date asc nulls last, b2.batch_id asc
      loop
        exit when v_need <= 0;

        v_candidate_key := v_candidate.batch_id::text;
        v_candidate_entry := v_reserved_batches->v_candidate_key;
        v_candidate_list :=
          case
            when v_candidate_entry is null then '[]'::jsonb
            when jsonb_typeof(v_candidate_entry) = 'array' then v_candidate_entry
            when jsonb_typeof(v_candidate_entry) = 'object' then jsonb_build_array(v_candidate_entry)
            else '[]'::jsonb
          end;

        select coalesce(sum(coalesce(nullif(x->>'qty','')::numeric, 0)), 0)
        into v_candidate_reserved
        from jsonb_array_elements(v_candidate_list) as x;

        v_free := greatest(coalesce(v_candidate.remaining_qty, 0) - coalesce(v_candidate_reserved, 0), 0);
        if v_free <= 0 then
          continue;
        end if;

        v_alloc := least(v_need, v_free);
        if v_alloc <= 0 then
          continue;
        end if;

        with elems as (
          select value, ordinality
          from jsonb_array_elements(v_candidate_list) with ordinality
        )
        select
          case
            when exists (select 1 from elems where (value->>'orderId') = v_order_id::text) then (
              select coalesce(
                jsonb_agg(
                  case
                    when (value->>'orderId') = v_order_id::text then
                      jsonb_set(
                        value,
                        '{qty}',
                        to_jsonb(coalesce(nullif(value->>'qty','')::numeric, 0) + v_alloc),
                        true
                      )
                    else value
                  end
                  order by ordinality
                ),
                '[]'::jsonb
              )
            )
            else (
              (select coalesce(jsonb_agg(value order by ordinality), '[]'::jsonb) from elems)
              || jsonb_build_array(jsonb_build_object('orderId', v_order_id, 'batchId', v_candidate_key, 'qty', v_alloc))
            )
          end
        into v_list_new;

        v_reserved_batches := jsonb_set(v_reserved_batches, array[v_candidate_key], v_list_new, true);

        v_need := v_need - v_alloc;
      end loop;
    end loop;

    v_tmp_list := '[]'::jsonb;
    for v_key in
      select key
      from jsonb_each(v_reserved_batches)
    loop
      if v_key <> v_expired_batch_key then
        continue;
      end if;
      v_tmp_list := coalesce(v_reserved_batches->v_key, '[]'::jsonb);
    end loop;

    v_reserved_batches := v_reserved_batches - v_expired_batch_key;

    v_new_available := greatest(0, coalesce(v_stock.available_quantity, 0) - v_effective_wastage_qty);
    v_new_reserved := greatest(0, coalesce(v_stock.reserved_quantity, 0) - least(greatest(coalesce(v_reserved_cancel_total, 0), 0), greatest(coalesce(v_stock.reserved_quantity, 0), 0)));

    update public.batches
    set quantity_consumed = quantity_consumed + v_effective_wastage_qty
    where id = v_batch.batch_id
    returning quantity_received, quantity_consumed into v_qr, v_qc;

    if coalesce(v_qc, 0) > coalesce(v_qr, 0) then
      raise exception 'Over-consumption detected for expired batch %', v_batch.batch_id;
    end if;

    update public.stock_management
    set available_quantity = v_new_available,
        reserved_quantity = v_new_reserved,
        last_updated = now(),
        updated_at = now(),
        data = jsonb_set(
          jsonb_set(
            jsonb_set(coalesce(data, '{}'::jsonb), '{availableQuantity}', to_jsonb(v_new_available), true),
            '{reservedQuantity}',
            to_jsonb(v_new_reserved),
            true
          ),
          '{reservedBatches}',
          v_reserved_batches,
          true
        )
    where item_id::text = v_batch.item_id
      and (not v_has_warehouse or warehouse_id = v_wh_id);

    insert into public.stock_wastage (
      item_id,
      quantity,
      unit_type,
      cost_at_time,
      reason,
      notes,
      reported_by,
      created_at,
      batch_id,
      warehouse_id
    )
    select
      mi.id,
      v_effective_wastage_qty,
      mi.unit_type,
      v_unit_cost,
      'auto_expired',
      'Auto-processed batch expiry detection',
      auth.uid(),
      now(),
      v_batch.batch_id,
      v_wh_id
    from public.menu_items mi
    where mi.id = v_batch.item_id
    returning id into v_wastage_id;

    insert into public.inventory_movements(
      item_id, movement_type, quantity, unit_cost, total_cost,
      reference_table, reference_id, occurred_at, created_by, data, batch_id, warehouse_id
    )
    values (
      v_batch.item_id,
      'expired_out',
      v_effective_wastage_qty,
      v_unit_cost,
      v_effective_wastage_qty * v_unit_cost,
      'batches',
      v_batch.batch_id::text,
      now(),
      auth.uid(),
      jsonb_build_object(
        'reason', 'expiry',
        'expiryDate', coalesce(v_batch_expiry, v_batch.expiry_date),
        'warehouseId', v_wh_id,
        'batchId', v_batch.batch_id
      ),
      v_batch.batch_id,
      v_wh_id
    )
    returning id into v_movement_id;

    perform public.post_inventory_movement(v_movement_id);
  end loop;

  return json_build_object('success', true, 'processed_count', processed_count);
end;
$$;


ALTER FUNCTION "public"."process_expired_items"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."process_expiry_light"("p_warehouse_id" "uuid" DEFAULT NULL::"uuid", "p_now" timestamp with time zone DEFAULT "now"()) RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_actor uuid;
  v_wh uuid;
  v_processed integer := 0;
  v_row record;
  v_reserved numeric;
  v_unit_cost numeric;
  v_movement_id uuid;
  v_total_cost numeric;
begin
  perform public._require_stock_manager('process_expiry_light');

  v_actor := auth.uid();
  v_wh := coalesce(p_warehouse_id, public._resolve_default_warehouse_id());
  if v_wh is null then
    raise exception 'warehouse_id is required';
  end if;

  for v_row in
    select bb.item_id, bb.batch_id, bb.quantity, bb.expiry_date
    from public.batch_balances bb
    where bb.warehouse_id = v_wh
      and bb.quantity > 0
      and bb.expiry_date is not null
      and bb.expiry_date < current_date
    order by bb.expiry_date asc, bb.batch_id asc
  loop
    select coalesce(sum(br.quantity), 0)
    into v_reserved
    from public.batch_reservations br
    where br.item_id = v_row.item_id
      and br.batch_id = v_row.batch_id
      and br.warehouse_id = v_wh;

    if v_reserved > 0 then
      raise exception 'cannot process expiry for reserved batch %', v_row.batch_id;
    end if;

    select im.unit_cost
    into v_unit_cost
    from public.inventory_movements im
    where im.batch_id = v_row.batch_id
      and im.item_id::text = v_row.item_id
      and im.movement_type = 'purchase_in'
    order by im.occurred_at asc
    limit 1;
    v_unit_cost := coalesce(v_unit_cost, 0);
    v_total_cost := coalesce(v_row.quantity, 0) * v_unit_cost;

    update public.batch_balances
    set quantity = 0,
        updated_at = now()
    where item_id = v_row.item_id
      and batch_id = v_row.batch_id
      and warehouse_id = v_wh;

    insert into public.inventory_movements(
      item_id, movement_type, quantity, unit_cost, total_cost,
      reference_table, reference_id, occurred_at, created_by, data, batch_id, warehouse_id
    )
    values (
      v_row.item_id, 'wastage_out', v_row.quantity, v_unit_cost, v_total_cost,
      'accounting_light_entries', null, coalesce(p_now, now()), v_actor,
      jsonb_build_object('reason','expiry','warehouseId', v_wh, 'batchId', v_row.batch_id, 'expiredOn', v_row.expiry_date),
      v_row.batch_id, v_wh
    )
    returning id into v_movement_id;
    perform public.post_inventory_movement(v_movement_id);

    insert into public.accounting_light_entries(
      entry_type, item_id, warehouse_id, batch_id, quantity, unit, unit_cost, total_cost,
      occurred_at, debit_account, credit_account, created_by, notes, source_ref
    )
    values (
      'expiry', v_row.item_id, v_wh, v_row.batch_id, v_row.quantity, null,
      v_unit_cost, v_total_cost, coalesce(p_now, now()),
      'shrinkage', 'inventory', v_actor, 'expiry', v_movement_id::text
    );

    update public.stock_management sm
    set available_quantity = coalesce((
          select sum(bb.quantity)
          from public.batch_balances bb
          where bb.item_id = v_row.item_id
            and bb.warehouse_id = v_wh
        ), 0),
        reserved_quantity = coalesce((
          select sum(br.quantity)
          from public.batch_reservations br
          where br.item_id = v_row.item_id
            and br.warehouse_id = v_wh
        ), 0),
        updated_at = now(),
        last_updated = now()
    where sm.item_id::text = v_row.item_id
      and sm.warehouse_id = v_wh;

    insert into public.system_audit_logs(action, module, details, performed_by, performed_at, metadata)
    values (
      'expiry.processed',
      'stock',
      'batch expired',
      v_actor,
      now(),
      jsonb_build_object('itemId', v_row.item_id, 'warehouseId', v_wh, 'batchId', v_row.batch_id, 'quantity', v_row.quantity, 'unitCost', v_unit_cost)
    );

    v_processed := v_processed + 1;
  end loop;

  return v_processed;
end;
$$;


ALTER FUNCTION "public"."process_expiry_light"("p_warehouse_id" "uuid", "p_now" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."process_sales_return"("p_return_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_ret record;
  v_order record;
  v_entry_id uuid;
  v_cash uuid;
  v_bank uuid;
  v_ar uuid;
  v_deposits uuid;
  v_sales_returns uuid;
  v_vat_payable uuid;
  v_order_subtotal numeric;
  v_order_discount numeric;
  v_order_net_subtotal numeric;
  v_order_tax numeric;
  v_return_subtotal numeric;
  v_tax_refund numeric;
  v_total_refund numeric;
  v_refund_method text;
  v_shift_id uuid;
  v_item jsonb;
  v_item_id text;
  v_qty numeric;
  v_needed numeric;
  v_sale record;
  v_already numeric;
  v_free numeric;
  v_alloc numeric;
  v_ret_batch_id uuid;
  v_source_batch record;
  v_movement_id uuid;
  v_wh uuid;
  v_ar_reduction numeric := 0;
begin
  perform public._require_staff('process_sales_return');
  if not (auth.role() = 'service_role' or public.has_admin_permission('accounting.manage')) then
    raise exception 'not authorized';
  end if;

  if p_return_id is null then
    raise exception 'p_return_id is required';
  end if;

  select *
  into v_ret
  from public.sales_returns r
  where r.id = p_return_id
  for update;
  if not found then
    raise exception 'sales return not found';
  end if;
  if v_ret.status = 'completed' then
    return;
  end if;
  if v_ret.status = 'cancelled' then
    raise exception 'sales return is cancelled';
  end if;

  select *
  into v_order
  from public.orders o
  where o.id = v_ret.order_id;
  if not found then
    raise exception 'order not found';
  end if;
  if coalesce(v_order.status,'') <> 'delivered' then
    raise exception 'sales return requires delivered order';
  end if;

  v_cash := public.get_account_id_by_code('1010');
  v_bank := public.get_account_id_by_code('1020');
  v_ar := public.get_account_id_by_code('1200');
  v_deposits := public.get_account_id_by_code('2050');
  v_sales_returns := public.get_account_id_by_code('4026');
  v_vat_payable := public.get_account_id_by_code('2020');

  v_order_subtotal := coalesce(nullif((v_order.data->>'subtotal')::numeric, null), coalesce(v_order.subtotal, 0), 0);
  v_order_discount := coalesce(nullif((v_order.data->>'discountAmount')::numeric, null), coalesce(v_order.discount, 0), 0);
  v_order_net_subtotal := greatest(0, v_order_subtotal - v_order_discount);
  v_order_tax := coalesce(nullif((v_order.data->>'taxAmount')::numeric, null), coalesce(v_order.tax_amount, 0), 0);

  v_return_subtotal := coalesce(nullif(v_ret.total_refund_amount, null), 0);
  if v_return_subtotal <= 0 then
    raise exception 'invalid return amount';
  end if;

  v_tax_refund := 0;
  if v_order_net_subtotal > 0 and v_order_tax > 0 then
    v_tax_refund := least(v_order_tax, (v_return_subtotal / v_order_net_subtotal) * v_order_tax);
  end if;
  v_total_refund := public._money_round(v_return_subtotal + v_tax_refund);

  insert into public.journal_entries(entry_date, memo, source_table, source_id, source_event, created_by, status)
  values (
    coalesce(v_ret.return_date, now()),
    concat('Sales return ', v_ret.id::text),
    'sales_returns',
    v_ret.id::text,
    'processed',
    auth.uid(),
    'posted'
  )
  on conflict (source_table, source_id, source_event)
  do update set entry_date = excluded.entry_date, memo = excluded.memo
  returning id into v_entry_id;

  delete from public.journal_lines jl where jl.journal_entry_id = v_entry_id;

  insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
  values (v_entry_id, v_sales_returns, public._money_round(v_return_subtotal), 0, 'Sales return');

  if v_tax_refund > 0 then
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values (v_entry_id, v_vat_payable, public._money_round(v_tax_refund), 0, 'Reverse VAT payable');
  end if;

  v_refund_method := coalesce(nullif(trim(coalesce(v_ret.refund_method, '')), ''), 'cash');
  if v_refund_method in ('bank', 'bank_transfer') then
    v_refund_method := 'kuraimi';
  elsif v_refund_method in ('card', 'online') then
    v_refund_method := 'network';
  end if;

  if v_refund_method = 'cash' then
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values (v_entry_id, v_cash, 0, v_total_refund, 'Cash refund');
  elsif v_refund_method in ('network','kuraimi') then
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values (v_entry_id, v_bank, 0, v_total_refund, 'Bank refund');
  elsif v_refund_method = 'ar' then
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values (v_entry_id, v_ar, 0, v_total_refund, 'Reduce accounts receivable');
    v_ar_reduction := v_total_refund;
  elsif v_refund_method = 'store_credit' then
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values (v_entry_id, v_deposits, 0, v_total_refund, 'Increase customer deposit');
  else
    v_refund_method := 'cash';
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values (v_entry_id, v_cash, 0, v_total_refund, 'Cash refund');
  end if;

  for v_item in select value from jsonb_array_elements(coalesce(v_ret.items, '[]'::jsonb))
  loop
    v_item_id := nullif(trim(coalesce(v_item->>'itemId', '')), '');
    v_qty := coalesce(nullif(v_item->>'quantity','')::numeric, 0);
    if v_item_id is null or v_qty <= 0 then
      continue;
    end if;

    v_needed := v_qty;

    for v_sale in
      select im.id, im.item_id, im.quantity, im.unit_cost, im.total_cost, im.batch_id, im.warehouse_id, im.occurred_at
      from public.inventory_movements im
      where im.reference_table = 'orders'
        and im.reference_id = v_ret.order_id::text
        and im.movement_type = 'sale_out'
        and im.item_id::text = v_item_id::text
      order by im.occurred_at asc, im.id asc
    loop
      exit when v_needed <= 0;

      select coalesce(sum(imr.quantity), 0)
      into v_already
      from public.inventory_movements imr
      where imr.reference_table = 'sales_returns'
        and imr.movement_type = 'return_in'
        and (imr.data->>'orderId') = v_ret.order_id::text
        and (imr.data->>'sourceMovementId') = v_sale.id::text;

      v_free := greatest(coalesce(v_sale.quantity, 0) - coalesce(v_already, 0), 0);
      if v_free <= 0 then
        continue;
      end if;

      v_alloc := least(v_needed, v_free);
      if v_alloc <= 0 then
        continue;
      end if;

      select b.expiry_date, b.production_date, b.unit_cost
      into v_source_batch
      from public.batches b
      where b.id = v_sale.batch_id;

      v_wh := v_sale.warehouse_id;
      if v_wh is null then
        v_wh := coalesce(v_order.warehouse_id, public._resolve_default_admin_warehouse_id());
      end if;
      if v_wh is null then
        raise exception 'warehouse_id is required';
      end if;

      v_ret_batch_id := gen_random_uuid();
      insert into public.batches(
        id,
        item_id,
        receipt_item_id,
        receipt_id,
        warehouse_id,
        batch_code,
        production_date,
        expiry_date,
        quantity_received,
        quantity_consumed,
        unit_cost,
        qc_status,
        data
      )
      values (
        v_ret_batch_id,
        v_item_id::text,
        null,
        null,
        v_wh,
        null,
        v_source_batch.production_date,
        v_source_batch.expiry_date,
        v_alloc,
        0,
        coalesce(v_sale.unit_cost, v_source_batch.unit_cost, 0),
        'pending',
        jsonb_build_object(
          'source', 'sales_returns',
          'salesReturnId', v_ret.id::text,
          'orderId', v_ret.order_id::text,
          'sourceBatchId', v_sale.batch_id::text,
          'sourceMovementId', v_sale.id::text
        )
      );

      insert into public.inventory_movements(
        item_id, movement_type, quantity, unit_cost, total_cost,
        reference_table, reference_id, occurred_at, created_by, data, batch_id, warehouse_id
      )
      values (
        v_item_id::text,
        'return_in',
        v_alloc,
        coalesce(v_sale.unit_cost, v_source_batch.unit_cost, 0),
        v_alloc * coalesce(v_sale.unit_cost, v_source_batch.unit_cost, 0),
        'sales_returns',
        v_ret.id::text,
        coalesce(v_ret.return_date, now()),
        auth.uid(),
        jsonb_build_object(
          'orderId', v_ret.order_id::text,
          'warehouseId', v_wh::text,
          'salesReturnId', v_ret.id::text,
          'sourceBatchId', v_sale.batch_id::text,
          'sourceMovementId', v_sale.id::text
        ),
        v_ret_batch_id,
        v_wh
      )
      returning id into v_movement_id;

      perform public.post_inventory_movement(v_movement_id);
      perform public.recompute_stock_for_item(v_item_id::text, v_wh);

      v_needed := v_needed - v_alloc;
    end loop;

    if v_needed > 1e-9 then
      raise exception 'return exceeds sold quantity for item %', v_item_id;
    end if;
  end loop;

  update public.sales_returns
  set status = 'completed',
      updated_at = now()
  where id = p_return_id;

  v_shift_id := public._resolve_open_shift_for_cash(auth.uid());
  if v_refund_method = 'cash' and v_shift_id is null then
    raise exception 'cash refund requires an open cash shift';
  end if;

  if v_refund_method in ('cash','network','kuraimi') then
    insert into public.payments(direction, method, amount, currency, reference_table, reference_id, occurred_at, created_by, data, shift_id)
    values (
      'out',
      v_refund_method,
      v_total_refund,
      coalesce(v_order.data->>'currency', v_order.currency, 'YER'),
      'sales_returns',
      v_ret.id::text,
      coalesce(v_ret.return_date, now()),
      auth.uid(),
      jsonb_build_object('orderId', v_ret.order_id::text),
      v_shift_id
    );
  end if;

  perform public._apply_ar_open_item_credit(v_ret.order_id, v_ar_reduction);
end;
$$;


ALTER FUNCTION "public"."process_sales_return"("p_return_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."profit_and_loss_by_period"("p_period_id" "uuid") RETURNS TABLE("statement_section" "text", "account_code" "text", "account_name" "text", "amount" numeric)
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select *
  from public.profit_and_loss_by_range(
    (select ap.start_date from public.accounting_periods ap where ap.id = p_period_id),
    (select ap.end_date from public.accounting_periods ap where ap.id = p_period_id)
  );
$$;


ALTER FUNCTION "public"."profit_and_loss_by_period"("p_period_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."profit_and_loss_by_period"("p_period_id" "uuid") IS 'Purpose: P&L by accounting_periods.id. Source of truth: profit_and_loss_by_range using period start_date/end_date.';



CREATE OR REPLACE FUNCTION "public"."profit_and_loss_by_range"("p_start" "date", "p_end" "date") RETURNS TABLE("statement_section" "text", "account_code" "text", "account_name" "text", "amount" numeric)
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if not (auth.role() = 'service_role' or public.has_admin_permission('accounting.view')) then
    raise exception 'not allowed';
  end if;

  return query
  with lines as (
    select
      coa.code,
      coa.name,
      coa.account_type,
      coa.normal_balance,
      coalesce(sum(jl.debit), 0) as debit,
      coalesce(sum(jl.credit), 0) as credit
    from public.chart_of_accounts coa
    left join public.journal_lines jl on jl.account_id = coa.id
    left join public.journal_entries je
      on je.id = jl.journal_entry_id
     and (p_start is null or je.entry_date::date >= p_start)
     and (p_end is null or je.entry_date::date <= p_end)
    where coa.account_type in ('income','expense')
      and coa.is_active = true
    group by coa.code, coa.name, coa.account_type, coa.normal_balance
  ),
  amounts as (
    select
      case
        when l.account_type = 'income' then 'Revenue'
        when l.code = '5010' then 'COGS'
        else 'Operating Expenses'
      end as statement_section,
      l.code as account_code,
      l.name as account_name,
      case
        when l.normal_balance = 'debit' then (l.debit - l.credit)
        else (l.credit - l.debit)
      end as amount
    from lines l
  )
  select a.statement_section, a.account_code, a.account_name, a.amount
  from amounts a
  where abs(a.amount) > 1e-9
  order by
    case a.statement_section when 'Revenue' then 1 when 'COGS' then 2 else 3 end,
    a.account_code;
end;
$$;


ALTER FUNCTION "public"."profit_and_loss_by_range"("p_start" "date", "p_end" "date") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."profit_and_loss_by_range"("p_start" "date", "p_end" "date") IS 'Purpose: compute P&L over a date range from journal_entries/journal_lines grouped by chart_of_accounts. Source of truth: journal_entries/journal_lines; period lock enforced by Phase 10.';



CREATE OR REPLACE FUNCTION "public"."purchase_items_after_change"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
begin
  if tg_op = 'DELETE' then
    perform public.recalc_purchase_order_totals(old.purchase_order_id);
    return old;
  end if;

  if tg_op = 'UPDATE' and (new.purchase_order_id is distinct from old.purchase_order_id) then
    perform public.recalc_purchase_order_totals(old.purchase_order_id);
    perform public.recalc_purchase_order_totals(new.purchase_order_id);
    return new;
  end if;

  perform public.recalc_purchase_order_totals(new.purchase_order_id);
  return new;
end;
$$;


ALTER FUNCTION "public"."purchase_items_after_change"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."purchase_items_set_total_cost"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
begin
  new.total_cost := coalesce(new.quantity, 0) * coalesce(new.unit_cost, 0);
  return new;
end;
$$;


ALTER FUNCTION "public"."purchase_items_set_total_cost"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."purchase_orders_recalc_after_insert"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
begin
  perform public.recalc_purchase_order_totals(new.id);
  return new;
end;
$$;


ALTER FUNCTION "public"."purchase_orders_recalc_after_insert"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."purchase_receipt_items_set_total_cost"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
begin
  new.total_cost := coalesce(new.quantity, 0) * coalesce(new.unit_cost, 0);
  return new;
end;
$$;


ALTER FUNCTION "public"."purchase_receipt_items_set_total_cost"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."purchase_return_items_after_change"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
declare
  v_old_order_id uuid;
  v_new_order_id uuid;
begin
  if tg_op = 'DELETE' then
    select pr.purchase_order_id into v_old_order_id
    from public.purchase_returns pr
    where pr.id = old.return_id;
    perform public.recalc_purchase_order_totals(v_old_order_id);
    return old;
  end if;

  if tg_op = 'UPDATE' then
    select pr.purchase_order_id into v_old_order_id
    from public.purchase_returns pr
    where pr.id = old.return_id;
    select pr.purchase_order_id into v_new_order_id
    from public.purchase_returns pr
    where pr.id = new.return_id;
    if v_old_order_id is distinct from v_new_order_id then
      perform public.recalc_purchase_order_totals(v_old_order_id);
    end if;
    perform public.recalc_purchase_order_totals(v_new_order_id);
    return new;
  end if;

  select pr.purchase_order_id into v_new_order_id
  from public.purchase_returns pr
  where pr.id = new.return_id;
  perform public.recalc_purchase_order_totals(v_new_order_id);
  return new;
end;
$$;


ALTER FUNCTION "public"."purchase_return_items_after_change"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."purchase_return_items_set_total_cost"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
begin
  new.total_cost := coalesce(new.quantity, 0) * coalesce(new.unit_cost, 0);
  return new;
end;
$$;


ALTER FUNCTION "public"."purchase_return_items_set_total_cost"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."purge_purchase_order"("p_order_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_is_owner boolean;
  v_has_receipts boolean;
  v_has_payments boolean;
  v_has_movements boolean;
begin
  if p_order_id is null then
    raise exception 'p_order_id is required';
  end if;

  -- Only Owner can purge
  select exists(
    select 1
    from public.admin_users au
    where au.auth_user_id = auth.uid()
      and au.is_active = true
      and au.role = 'owner'
  ) into v_is_owner;

  if not coalesce(v_is_owner, false) then
    raise exception 'not allowed';
  end if;

  -- Validation: Cannot purge if it has related records (receipts, payments, movements)
  select exists(select 1 from public.purchase_receipts pr where pr.purchase_order_id = p_order_id)
  into v_has_receipts;

  select exists(
    select 1
    from public.payments p
    where p.reference_table = 'purchase_orders'
    and p.reference_id::text = p_order_id::text
  ) into v_has_payments;

  select exists(
    select 1
    from public.inventory_movements im
    where (im.reference_table = 'purchase_orders' and im.reference_id::text = p_order_id::text)
       or (im.data ? 'purchaseOrderId' and im.data->>'purchaseOrderId' = p_order_id::text)
  ) into v_has_movements;

  if coalesce(v_has_receipts, false) or coalesce(v_has_payments, false) or coalesce(v_has_movements, false) then
    raise exception 'cannot purge posted purchase order - void it instead';
  end if;

  -- Audit Log
  insert into public.system_audit_logs(action, module, details, performed_by, performed_at, metadata)
  values (
    'soft_delete',
    'purchases',
    concat('Soft deleted (purged) purchase order ', p_order_id::text),
    auth.uid(),
    now(),
    jsonb_build_object('purchaseOrderId', p_order_id::text)
  );

  -- Perform Soft Delete
  update public.purchase_orders
  set deleted_at = now(),
      updated_at = now(),
      status = 'cancelled' -- Also mark as cancelled for visual clarity
  where id = p_order_id;
end;
$$;


ALTER FUNCTION "public"."purge_purchase_order"("p_order_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."qc_inspect_batch"("p_batch_id" "uuid", "p_result" "text", "p_notes" "text" DEFAULT NULL::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_batch record;
begin
  perform public._require_staff('qc_inspect_batch');
  if not public.has_admin_permission('qc.inspect') then
    raise exception '    QC';
  end if;
  if p_batch_id is null then
    raise exception 'batch_id is required';
  end if;
  if coalesce(p_result,'') not in ('pass','fail') then
    raise exception 'result must be pass or fail';
  end if;

  select b.id, b.item_id, b.warehouse_id, coalesce(b.qc_status,'') as qc_status
  into v_batch
  from public.batches b
  where b.id = p_batch_id
  for update;
  if not found then
    raise exception 'batch not found';
  end if;

  if v_batch.qc_status not in ('pending','quarantined') then
    raise exception 'batch qc_status must be pending';
  end if;

  insert into public.qc_checks(batch_id, check_type, result, checked_by, checked_at, notes)
  values (p_batch_id, 'inspection', p_result, auth.uid(), now(), nullif(p_notes,''));

  update public.batches
  set qc_status = 'inspected',
      updated_at = now()
  where id = p_batch_id;

  perform public.recompute_stock_for_item(v_batch.item_id, v_batch.warehouse_id);
end;
$$;


ALTER FUNCTION "public"."qc_inspect_batch"("p_batch_id" "uuid", "p_result" "text", "p_notes" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."qc_release_batch"("p_batch_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_batch record;
  v_last_result text;
begin
  perform public._require_staff('qc_release_batch');
  if not public.has_admin_permission('qc.release') then
    raise exception '    QC';
  end if;
  if p_batch_id is null then
    raise exception 'batch_id is required';
  end if;

  select b.id, b.item_id, b.warehouse_id, coalesce(b.qc_status,'') as qc_status
  into v_batch
  from public.batches b
  where b.id = p_batch_id
  for update;
  if not found then
    raise exception 'batch not found';
  end if;

  if v_batch.qc_status <> 'inspected' then
    raise exception 'batch qc_status must be inspected';
  end if;

  select qc.result
  into v_last_result
  from public.qc_checks qc
  where qc.batch_id = p_batch_id
    and qc.check_type = 'inspection'
  order by qc.checked_at desc
  limit 1;

  if coalesce(v_last_result,'') <> 'pass' then
    raise exception 'QC inspection must pass before release';
  end if;

  update public.batches
  set qc_status = 'released',
      updated_at = now()
  where id = p_batch_id;

  perform public.recompute_stock_for_item(v_batch.item_id, v_batch.warehouse_id);
end;
$$;


ALTER FUNCTION "public"."qc_release_batch"("p_batch_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."rebuild_order_line_items"("p_order_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_order record;
  v_item jsonb;
  v_item_id text;
  v_qty numeric;
  v_price numeric;
begin
  select * into v_order from public.orders where id = p_order_id;
  if not found then
    raise exception 'order not found';
  end if;
  delete from public.order_line_items where order_id = p_order_id;
  for v_item in select value from jsonb_array_elements(coalesce(v_order.items, v_order.data->'items', '[]'::jsonb))
  loop
    v_item_id := coalesce(v_item->>'itemId', v_item->>'id');
    v_qty := coalesce((v_item->>'quantity')::numeric, 0);
    v_price := coalesce((v_item->>'price')::numeric, 0);
    insert into public.order_line_items(order_id, item_id, quantity, unit_price, total, data)
    values (p_order_id, v_item_id, v_qty, v_price, v_qty * v_price, v_item);
  end loop;
end;
$$;


ALTER FUNCTION "public"."rebuild_order_line_items"("p_order_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."recalc_purchase_order_totals"("p_order_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
declare
  v_items_total numeric;
  v_returns_total numeric;
  v_net_total numeric;
begin
  if p_order_id is null then
    return;
  end if;

  select coalesce(sum(coalesce(pi.total_cost, coalesce(pi.quantity, 0) * coalesce(pi.unit_cost, 0))), 0)
  into v_items_total
  from public.purchase_items pi
  where pi.purchase_order_id = p_order_id;

  select coalesce(sum(coalesce(pri.total_cost, coalesce(pri.quantity, 0) * coalesce(pri.unit_cost, 0))), 0)
  into v_returns_total
  from public.purchase_returns pr
  join public.purchase_return_items pri on pri.return_id = pr.id
  where pr.purchase_order_id = p_order_id;

  v_net_total := greatest(0, coalesce(v_items_total, 0) - coalesce(v_returns_total, 0));

  update public.purchase_orders po
  set
    total_amount = v_net_total,
    items_count = coalesce((
      select count(*)
      from public.purchase_items pi
      where pi.purchase_order_id = p_order_id
    ), 0),
    paid_amount = least(coalesce(po.paid_amount, 0), v_net_total),
    updated_at = now()
  where po.id = p_order_id;
end;
$$;


ALTER FUNCTION "public"."recalc_purchase_order_totals"("p_order_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."receive_inventory_transfer"("p_transfer_id" "uuid", "p_idempotency_key" "text" DEFAULT NULL::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_actor uuid;
  v_transfer record;
  v_item record;
  v_source_batch record;
  v_dest_batch_id uuid;
  v_old_qty numeric;
  v_old_avg numeric;
  v_new_qty numeric;
  v_new_avg numeric;
  v_movement_id uuid;
begin
  v_actor := auth.uid();
  if not public.is_admin() then
    raise exception 'not allowed';
  end if;
  if p_transfer_id is null then
    raise exception 'p_transfer_id is required';
  end if;

  perform pg_advisory_xact_lock(hashtext(p_transfer_id::text));

  select *
  into v_transfer
  from public.inventory_transfers it
  where it.id = p_transfer_id
  for update;

  if not found then
    raise exception 'transfer not found';
  end if;

  if p_idempotency_key is not null and btrim(p_idempotency_key) <> '' then
    if v_transfer.receive_idempotency_key is not null and v_transfer.receive_idempotency_key = p_idempotency_key then
      return jsonb_build_object('status', v_transfer.state, 'transferId', p_transfer_id::text);
    end if;
  end if;

  if v_transfer.state = 'RECEIVED' then
    return jsonb_build_object('status', 'RECEIVED', 'transferId', p_transfer_id::text);
  end if;

  if v_transfer.state <> 'IN_TRANSIT' then
    raise exception 'cannot receive transfer in state %', v_transfer.state;
  end if;

  for v_item in
    select *
    from public.inventory_transfer_items iti
    where iti.transfer_id = p_transfer_id
    order by iti.created_at asc, iti.id asc
    for update
  loop
    if coalesce(v_item.received_qty, 0) > 0 then
      continue;
    end if;

    if v_item.received_batch_id is null then
      update public.inventory_transfer_items
      set received_batch_id = gen_random_uuid()
      where id = v_item.id
        and received_batch_id is null
      returning received_batch_id into v_dest_batch_id;

      if v_dest_batch_id is null then
        continue;
      end if;
    else
      v_dest_batch_id := v_item.received_batch_id;
    end if;

    if exists (
      select 1
      from public.inventory_movements im
      where im.reference_table = 'inventory_transfers'
        and im.reference_id = p_transfer_id::text
        and im.movement_type = 'transfer_in'
        and im.item_id = v_item.item_id
        and im.batch_id = v_dest_batch_id
        and im.warehouse_id is not distinct from v_transfer.to_warehouse_id
    ) then
      update public.inventory_transfer_items
      set received_qty = quantity,
          received_batch_id = v_dest_batch_id,
          updated_at = now()
      where id = v_item.id;
      continue;
    end if;

    select *
    into v_source_batch
    from public.batches b
    where b.id = v_item.source_batch_id
    for update;

    if not found then
      raise exception 'source batch not found';
    end if;

    insert into public.batches(
      id,
      item_id,
      receipt_item_id,
      receipt_id,
      warehouse_id,
      batch_code,
      production_date,
      expiry_date,
      quantity_received,
      quantity_consumed,
      quantity_transferred,
      unit_cost,
      data
    )
    values (
      v_dest_batch_id,
      v_item.item_id,
      null,
      null,
      v_transfer.to_warehouse_id,
      v_source_batch.batch_code,
      v_source_batch.production_date,
      v_source_batch.expiry_date,
      v_item.quantity,
      0,
      0,
      v_item.unit_cost,
      jsonb_build_object(
        'source', 'inventory_transfer',
        'transferId', p_transfer_id,
        'sourceBatchId', v_item.source_batch_id,
        'fromWarehouseId', v_transfer.from_warehouse_id
      )
    )
    on conflict (id) do nothing;

    select coalesce(sm.available_quantity,0), coalesce(sm.avg_cost,0)
    into v_old_qty, v_old_avg
    from public.stock_management sm
    where sm.item_id::text = v_item.item_id
      and sm.warehouse_id = v_transfer.to_warehouse_id
    for update;

    if not found then
      insert into public.stock_management(item_id, warehouse_id, available_quantity, reserved_quantity, unit, low_stock_threshold, avg_cost, last_updated, updated_at, data)
      select mi.id, v_transfer.to_warehouse_id, 0, 0, coalesce(mi.unit_type,'piece'), 5, 0, now(), now(), '{}'::jsonb
      from public.menu_items mi
      where mi.id = v_item.item_id
      on conflict (item_id, warehouse_id) do nothing;

      select coalesce(sm.available_quantity,0), coalesce(sm.avg_cost,0)
      into v_old_qty, v_old_avg
      from public.stock_management sm
      where sm.item_id::text = v_item.item_id
        and sm.warehouse_id = v_transfer.to_warehouse_id
      for update;
    end if;

    v_new_qty := v_old_qty + v_item.quantity;
    if v_new_qty <= 0 then
      v_new_avg := v_item.unit_cost;
    else
      v_new_avg := ((v_old_qty * v_old_avg) + (v_item.quantity * v_item.unit_cost)) / v_new_qty;
    end if;

    update public.stock_management
    set available_quantity = available_quantity + v_item.quantity,
        avg_cost = v_new_avg,
        last_updated = now(),
        updated_at = now()
    where item_id::text = v_item.item_id
      and warehouse_id = v_transfer.to_warehouse_id;

    insert into public.inventory_movements(
      item_id, movement_type, quantity, unit_cost, total_cost,
      reference_table, reference_id, occurred_at, created_by, data, batch_id, warehouse_id
    )
    values (
      v_item.item_id,
      'transfer_in',
      v_item.quantity,
      v_item.unit_cost,
      0,
      'inventory_transfers',
      p_transfer_id::text,
      now(),
      v_actor,
      jsonb_build_object(
        'transferId', p_transfer_id,
        'direction', 'in',
        'fromWarehouseId', v_transfer.from_warehouse_id,
        'toWarehouseId', v_transfer.to_warehouse_id,
        'sourceBatchId', v_item.source_batch_id
      ),
      v_dest_batch_id,
      v_transfer.to_warehouse_id
    )
    returning id into v_movement_id;

    perform public.post_inventory_movement(v_movement_id);

    update public.inventory_transfer_items
    set received_qty = quantity,
        received_batch_id = v_dest_batch_id,
        updated_at = now()
    where id = v_item.id;
  end loop;

  update public.inventory_transfers
  set state = 'RECEIVED',
      received_by = v_actor,
      received_at = now(),
      updated_at = now(),
      receive_idempotency_key = nullif(btrim(p_idempotency_key), '')
  where id = p_transfer_id;

  return jsonb_build_object('status', 'RECEIVED', 'transferId', p_transfer_id::text);
end;
$$;


ALTER FUNCTION "public"."receive_inventory_transfer"("p_transfer_id" "uuid", "p_idempotency_key" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."receive_purchase_order"("p_order_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_po record;
  v_pi record;
  v_old_qty numeric;
  v_old_avg numeric;
  v_new_qty numeric;
  v_effective_unit_cost numeric;
  v_new_avg numeric;
  v_movement_id uuid;
  v_batch_id uuid;
  v_wh uuid;
  v_category text;
begin
  perform public._require_staff('receive_purchase_order');

  if p_order_id is null then
    raise exception 'purchase order not found';
  end if;

  v_wh := public._resolve_default_warehouse_id();
  if v_wh is null then
    raise exception 'warehouse_id is required';
  end if;

  select *
  into v_po
  from public.purchase_orders
  where id = p_order_id
  for update;

  if not found then
    raise exception 'purchase order not found';
  end if;

  if v_po.status = 'cancelled' then
    raise exception 'cannot receive cancelled purchase order';
  end if;

  for v_pi in
    select pi.item_id, pi.quantity, pi.unit_cost
    from public.purchase_items pi
    where pi.purchase_order_id = p_order_id
  loop
    select mi.category
    into v_category
    from public.menu_items mi
    where mi.id = v_pi.item_id;

    if coalesce(v_category,'') = 'food' then
      raise exception 'expiryDate is required for food item % (use partial receiving)', v_pi.item_id;
    end if;

    v_batch_id := gen_random_uuid();

    insert into public.stock_management(item_id, warehouse_id, available_quantity, reserved_quantity, unit, low_stock_threshold, last_updated, data)
    select v_pi.item_id, v_wh, 0, 0, coalesce(mi.unit_type, 'piece'), 5, now(), '{}'::jsonb
    from public.menu_items mi
    where mi.id = v_pi.item_id
    on conflict (item_id, warehouse_id) do nothing;

    select coalesce(sm.available_quantity, 0), coalesce(sm.avg_cost, 0)
    into v_old_qty, v_old_avg
    from public.stock_management sm
    where sm.item_id::text = v_pi.item_id::text
      and sm.warehouse_id = v_wh
    for update;

    select (v_pi.unit_cost + coalesce(mi.transport_cost, 0) + coalesce(mi.supply_tax_cost, 0))
    into v_effective_unit_cost
    from public.menu_items mi
    where mi.id = v_pi.item_id;

    v_new_qty := v_old_qty + v_pi.quantity;
    if v_new_qty <= 0 then
      v_new_avg := v_effective_unit_cost;
    else
      v_new_avg := ((v_old_qty * v_old_avg) + (v_pi.quantity * v_effective_unit_cost)) / v_new_qty;
    end if;

    update public.stock_management
    set available_quantity = available_quantity + v_pi.quantity,
        avg_cost = v_new_avg,
        last_updated = now(),
        updated_at = now()
    where item_id::text = v_pi.item_id::text
      and warehouse_id = v_wh;

    insert into public.batch_balances(item_id, batch_id, warehouse_id, quantity, expiry_date)
    values (v_pi.item_id::text, v_batch_id, v_wh, v_pi.quantity, null)
    on conflict (item_id, batch_id, warehouse_id)
    do update set
      quantity = public.batch_balances.quantity + excluded.quantity,
      updated_at = now();

    update public.menu_items
    set buying_price = v_pi.unit_cost,
        cost_price = v_new_avg,
        updated_at = now()
    where id = v_pi.item_id;

    insert into public.inventory_movements(
      item_id, movement_type, quantity, unit_cost, total_cost,
      reference_table, reference_id, occurred_at, created_by, data, batch_id, warehouse_id
    )
    values (
      v_pi.item_id, 'purchase_in', v_pi.quantity, v_effective_unit_cost, (v_pi.quantity * v_effective_unit_cost),
      'purchase_orders', p_order_id::text, now(), auth.uid(), jsonb_build_object('purchaseOrderId', p_order_id, 'batchId', v_batch_id, 'warehouseId', v_wh),
      v_batch_id, v_wh
    )
    returning id into v_movement_id;

    perform public.post_inventory_movement(v_movement_id);
  end loop;

  update public.purchase_orders
  set status = 'completed',
      updated_at = now()
  where id = p_order_id;
end;
$$;


ALTER FUNCTION "public"."receive_purchase_order"("p_order_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."receive_purchase_order_partial"("p_order_id" "uuid", "p_items" "jsonb", "p_occurred_at" timestamp with time zone DEFAULT "now"()) RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $_$
declare
  v_po record;
  v_item jsonb;
  v_item_id text;
  v_qty numeric;
  v_unit_cost numeric;
  v_old_qty numeric;
  v_old_avg numeric;
  v_new_qty numeric;
  v_effective_unit_cost numeric;
  v_new_avg numeric;
  v_receipt_id uuid;
  v_receipt_total numeric := 0;
  v_all_received boolean := true;
  v_ordered numeric;
  v_received numeric;
  v_expiry text;
  v_harvest text;
  v_expiry_iso text;
  v_harvest_iso text;
  v_category text;
  v_is_food boolean;
  v_expiry_required boolean;
  v_batch_id uuid;
  v_movement_id uuid;
  v_wh uuid;
  v_receipt_req_id uuid;
  v_receipt_req_status text;
  v_po_req_id uuid;
  v_payload jsonb;
  v_payload_hash text;
  v_required_receipt boolean := false;
  v_required_po boolean := false;
  v_po_approved boolean := false;
  v_qc_status text;
  v_transport_cost numeric;
  v_supply_tax_cost numeric;
  v_used_transport_cost numeric;
  v_used_supply_tax_cost numeric;
  v_import_shipment_id uuid;
  v_idempotency_key text;
  v_existing_receipt_id uuid;
begin
  perform public._require_staff('receive_purchase_order_partial');
  if p_order_id is null then
    raise exception 'p_order_id is required';
  end if;
  if p_items is null or jsonb_typeof(p_items) <> 'array' then
    raise exception 'p_items must be a json array';
  end if;

  v_idempotency_key := nullif(
    btrim(
      coalesce(
        (p_items->0->>'idempotencyKey'),
        (p_items->0->>'idempotency_key')
      )
    ),
    ''
  );

  perform pg_advisory_xact_lock(hashtext('receive_po:' || p_order_id::text));

  if v_idempotency_key is not null then
    select pr.id
    into v_existing_receipt_id
    from public.purchase_receipts pr
    where pr.purchase_order_id = p_order_id
      and pr.idempotency_key = v_idempotency_key
    order by pr.created_at desc
    limit 1;
    if v_existing_receipt_id is not null then
      return v_existing_receipt_id;
    end if;
  end if;

  begin
    v_import_shipment_id := nullif(
      coalesce(
        (p_items->0->>'importShipmentId'),
        (p_items->0->>'shipmentId'),
        (p_items->0->>'import_shipment_id')
      ),
      ''
    )::uuid;
  exception when others then
    v_import_shipment_id := null;
  end;

  select * into v_po
  from public.purchase_orders
  where id = p_order_id
  for update;
  if not found then
    raise exception 'purchase order not found';
  end if;
  if v_po.status = 'cancelled' then
    raise exception 'cannot receive cancelled purchase order';
  end if;

  begin
    update public.purchase_orders
    set fx_locked = true
    where id = p_order_id
      and coalesce(fx_locked, false) = false;
  exception when undefined_column then
    null;
  end;

  v_wh := coalesce(v_po.warehouse_id, public._resolve_default_warehouse_id());
  if v_wh is null then
    raise exception 'warehouse_id is required';
  end if;

  v_payload := jsonb_build_object('purchaseOrderId', p_order_id::text);
  v_payload_hash := encode(digest(convert_to(coalesce(v_payload::text, ''), 'utf8'), 'sha256'::text), 'hex');

  v_required_receipt := public.approval_required('receipt', coalesce(v_po.total_amount, 0));
  select ar.id, ar.status
  into v_receipt_req_id, v_receipt_req_status
  from public.approval_requests ar
  where ar.target_table = 'purchase_orders'
    and ar.target_id = p_order_id::text
    and ar.request_type = 'receipt'
    and ar.status in ('approved','pending')
  order by ar.created_at desc
  limit 1;

  if v_required_receipt then
    if v_receipt_req_id is null then
      if public.is_owner() then
        insert into public.approval_requests(
          target_table, target_id, request_type, status,
          requested_by, approved_by, approved_at,
          payload_hash
        )
        values (
          'purchase_orders',
          p_order_id::text,
          'receipt',
          'approved',
          auth.uid(),
          auth.uid(),
          now(),
          v_payload_hash
        )
        returning id into v_receipt_req_id;

        insert into public.approval_steps(
          request_id, step_no, approver_role, status, action_by, action_at
        )
        values (v_receipt_req_id, 1, 'manager', 'approved', auth.uid(), now())
        on conflict (request_id, step_no) do nothing;
        v_receipt_req_status := 'approved';
      else
        begin
          v_receipt_req_id := public.create_approval_request(
            'purchase_orders',
            p_order_id::text,
            'receipt',
            coalesce(v_po.total_amount, 0),
            v_payload
          );
        exception when others then
          v_receipt_req_id := null;
        end;
        raise exception 'RECEIPT_APPROVAL_REQUIRED:%', coalesce(v_receipt_req_id::text, '');
      end if;
    elsif v_receipt_req_status <> 'approved' then
      raise exception 'RECEIPT_APPROVAL_PENDING:%', coalesce(v_receipt_req_id::text, '');
    end if;
  end if;

  begin
    insert into public.purchase_receipts(
      purchase_order_id,
      received_at,
      created_by,
      approval_status,
      approval_request_id,
      requires_approval,
      warehouse_id,
      import_shipment_id,
      idempotency_key
    )
    values (
      p_order_id,
      coalesce(p_occurred_at, now()),
      auth.uid(),
      case when v_receipt_req_id is null then 'pending' else 'approved' end,
      v_receipt_req_id,
      v_required_receipt,
      v_wh,
      v_import_shipment_id,
      v_idempotency_key
    )
    returning id into v_receipt_id;
  exception when unique_violation then
    if v_idempotency_key is not null then
      select pr.id
      into v_existing_receipt_id
      from public.purchase_receipts pr
      where pr.purchase_order_id = p_order_id
        and pr.idempotency_key = v_idempotency_key
      order by pr.created_at desc
      limit 1;
      if v_existing_receipt_id is not null then
        return v_existing_receipt_id;
      end if;
    end if;
    raise;
  end;

  for v_item in select value from jsonb_array_elements(p_items)
  loop
    v_item_id := coalesce(v_item->>'itemId', v_item->>'id');
    v_qty := coalesce(nullif(v_item->>'quantity', '')::numeric, 0);
    v_transport_cost := nullif(coalesce(v_item->>'transportCost', v_item->>'transport_cost'), '')::numeric;
    v_supply_tax_cost := nullif(coalesce(v_item->>'supplyTaxCost', v_item->>'supply_tax_cost'), '')::numeric;
    v_expiry := nullif(v_item->>'expiryDate', '');
    v_harvest := nullif(coalesce(v_item->>'harvestDate', v_item->>'productionDate'), '');
    v_expiry_iso := null;
    v_harvest_iso := null;
    v_category := null;

    if v_item_id is null or v_item_id = '' then
      raise exception 'Invalid itemId';
    end if;
    if v_qty <= 0 then
      continue;
    end if;

    select
      coalesce(pi.quantity, 0),
      coalesce(pi.received_quantity, 0),
      coalesce(pi.unit_cost_base, pi.unit_cost, 0)
    into v_ordered, v_received, v_unit_cost
    from public.purchase_items pi
    where pi.purchase_order_id = p_order_id
      and pi.item_id = v_item_id
    for update;
    if not found then
      raise exception 'item % not found in purchase order', v_item_id;
    end if;
    if (v_received + v_qty) > (v_ordered + 1e-9) then
      raise exception 'received exceeds ordered for item %', v_item_id;
    end if;

    insert into public.stock_management(item_id, warehouse_id, available_quantity, qc_hold_quantity, reserved_quantity, unit, low_stock_threshold, last_updated, data)
    select v_item_id, v_wh, 0, 0, 0, coalesce(mi.unit_type, 'piece'), 5, now(), '{}'::jsonb
    from public.menu_items mi
    where mi.id = v_item_id
    on conflict (item_id, warehouse_id) do nothing;

    select coalesce(sm.available_quantity, 0) + coalesce(sm.qc_hold_quantity, 0), coalesce(sm.avg_cost, 0)
    into v_old_qty, v_old_avg
    from public.stock_management sm
    where sm.item_id::text = v_item_id
      and sm.warehouse_id = v_wh
    for update;

    select
      coalesce(v_transport_cost, coalesce(mi.transport_cost, 0)),
      coalesce(v_supply_tax_cost, coalesce(mi.supply_tax_cost, 0)),
      (v_unit_cost + coalesce(v_transport_cost, coalesce(mi.transport_cost, 0)) + coalesce(v_supply_tax_cost, coalesce(mi.supply_tax_cost, 0))),
      mi.category,
      coalesce(mi.is_food, false),
      coalesce(mi.expiry_required, false)
    into v_used_transport_cost, v_used_supply_tax_cost, v_effective_unit_cost, v_category, v_is_food, v_expiry_required
    from public.menu_items mi
    where mi.id = v_item_id;

    if v_old_qty < 0 then v_old_qty := 0; end if;
    if v_effective_unit_cost < 0 then v_effective_unit_cost := 0; end if;

    v_new_qty := v_old_qty + v_qty;
    v_new_avg := case when v_new_qty > 0 then ((v_old_qty * v_old_avg) + (v_qty * v_effective_unit_cost)) / v_new_qty else v_old_avg end;

    v_is_food := coalesce(v_is_food, (coalesce(v_category,'') = 'food'), false);
    v_expiry_required := coalesce(v_expiry_required, v_is_food, false);

    if v_expiry is not null and v_expiry <> '' then
      if v_expiry ~ '^[0-9]{4}-[0-9]{2}-[0-9]{2}$' then
        v_expiry_iso := v_expiry;
      else
        raise exception 'invalid expiryDate for item %', v_item_id;
      end if;
    end if;
    if v_harvest is not null and v_harvest ~ '^[0-9]{4}-[0-9]{2}-[0-9]{2}$' then
      v_harvest_iso := v_harvest;
    end if;

    if v_expiry_required and (v_expiry_iso is null or v_expiry_iso = '') then
      raise exception 'expiryDate is required for food item %', v_item_id;
    end if;

    v_qc_status := case when v_expiry_required then 'pending' else 'released' end;

    insert into public.batches(
      id,
      item_id,
      receipt_item_id,
      receipt_id,
      warehouse_id,
      batch_code,
      production_date,
      expiry_date,
      quantity_received,
      quantity_consumed,
      quantity_transferred,
      unit_cost,
      qc_status,
      status,
      data
    )
    values (
      gen_random_uuid(),
      v_item_id,
      null,
      v_receipt_id,
      v_wh,
      null,
      case when v_harvest_iso is null then null else v_harvest_iso::date end,
      case when v_expiry_iso is null then null else v_expiry_iso::date end,
      v_qty,
      0,
      0,
      v_effective_unit_cost,
      v_qc_status,
      'active',
      jsonb_build_object(
        'purchaseOrderId', p_order_id,
        'purchaseReceiptId', v_receipt_id,
        'expiryDate', v_expiry_iso,
        'harvestDate', v_harvest_iso,
        'warehouseId', v_wh,
        'transportCost', v_used_transport_cost,
        'supplyTaxCost', v_used_supply_tax_cost
      )
    )
    returning id into v_batch_id;

    if v_qc_status = 'pending' then
      update public.stock_management
      set qc_hold_quantity = coalesce(qc_hold_quantity, 0) + v_qty,
          avg_cost = v_new_avg,
          last_batch_id = v_batch_id,
          last_updated = now(),
          updated_at = now(),
          data = jsonb_set(
            jsonb_set(
              jsonb_set(
                jsonb_set(coalesce(data, '{}'::jsonb), '{availableQuantity}', to_jsonb(coalesce(available_quantity, 0)), true),
                '{qcHoldQuantity}', to_jsonb(coalesce(qc_hold_quantity, 0) + v_qty), true
              ),
              '{avgCost}', to_jsonb(v_new_avg), true
            ),
            '{lastBatchId}', to_jsonb(v_batch_id), true
          )
      where item_id::text = v_item_id
        and warehouse_id = v_wh;
    else
      update public.stock_management
      set available_quantity = coalesce(available_quantity, 0) + v_qty,
          avg_cost = v_new_avg,
          last_batch_id = v_batch_id,
          last_updated = now(),
          updated_at = now(),
          data = jsonb_set(
            jsonb_set(
              jsonb_set(
                jsonb_set(coalesce(data, '{}'::jsonb), '{availableQuantity}', to_jsonb(coalesce(available_quantity, 0) + v_qty), true),
                '{qcHoldQuantity}', to_jsonb(coalesce(qc_hold_quantity, 0)), true
              ),
              '{avgCost}', to_jsonb(v_new_avg), true
            ),
            '{lastBatchId}', to_jsonb(v_batch_id), true
          )
      where item_id::text = v_item_id
        and warehouse_id = v_wh;
    end if;

    update public.purchase_items
    set received_quantity = received_quantity + v_qty
    where purchase_order_id = p_order_id
      and item_id = v_item_id;

    insert into public.purchase_receipt_items(receipt_id, item_id, quantity, unit_cost, total_cost)
    values (v_receipt_id, v_item_id, v_qty, v_effective_unit_cost, (v_qty * v_effective_unit_cost));

    v_receipt_total := v_receipt_total + (v_qty * v_effective_unit_cost);

    insert into public.inventory_movements(
      item_id, movement_type, quantity, unit_cost, total_cost,
      reference_table, reference_id, occurred_at, created_by, data, batch_id, warehouse_id
    )
    values (
      v_item_id, 'purchase_in', v_qty, v_effective_unit_cost, (v_qty * v_effective_unit_cost),
      'purchase_receipts', v_receipt_id::text, coalesce(p_occurred_at, now()), auth.uid(),
      jsonb_build_object('purchaseOrderId', p_order_id, 'purchaseReceiptId', v_receipt_id, 'batchId', v_batch_id, 'expiryDate', v_expiry_iso, 'harvestDate', v_harvest_iso, 'warehouseId', v_wh),
      v_batch_id,
      v_wh
    )
    returning id into v_movement_id;

    perform public.post_inventory_movement(v_movement_id);
  end loop;

  for v_item_id, v_ordered, v_received in
    select pi.item_id, coalesce(pi.quantity, 0), coalesce(pi.received_quantity, 0)
    from public.purchase_items pi
    where pi.purchase_order_id = p_order_id
  loop
    if (v_received + 1e-9) < v_ordered then
      v_all_received := false;
      exit;
    end if;
  end loop;

  v_required_po := public.approval_required('po', coalesce(v_po.total_amount, 0));
  select ar.id
  into v_po_req_id
  from public.approval_requests ar
  where ar.target_table = 'purchase_orders'
    and ar.target_id = p_order_id::text
    and ar.request_type = 'po'
    and ar.status = 'approved'
  order by ar.created_at desc
  limit 1;

  if v_required_po and v_po_req_id is null and v_all_received then
    if public.is_owner() then
      insert into public.approval_requests(
        target_table, target_id, request_type, status,
        requested_by, approved_by, approved_at,
        payload_hash
      )
      values (
        'purchase_orders',
        p_order_id::text,
        'po',
        'approved',
        auth.uid(),
        auth.uid(),
        now(),
        v_payload_hash
      )
      returning id into v_po_req_id;

      insert into public.approval_steps(
        request_id, step_no, approver_role, status, action_by, action_at
      )
      values (v_po_req_id, 1, 'manager', 'approved', auth.uid(), now())
      on conflict (request_id, step_no) do nothing;

      v_po_approved := true;
    else
      insert into public.approval_requests(
        target_table, target_id, request_type, status,
        requested_by, payload_hash
      )
      values (
        'purchase_orders',
        p_order_id::text,
        'po',
        'pending',
        auth.uid(),
        v_payload_hash
      )
      returning id into v_po_req_id;

      insert into public.approval_steps(
        request_id, step_no, approver_role, status
      )
      values (v_po_req_id, 1, 'manager', 'pending')
      on conflict (request_id, step_no) do nothing;

      v_po_approved := false;
    end if;
  elsif v_po_req_id is not null then
    v_po_approved := true;
  end if;

  if v_all_received then
    if (not v_required_po) or v_po_approved then
      update public.purchase_orders
      set status = 'completed',
          updated_at = now(),
          approval_status = case when v_po_approved then 'approved' else approval_status end,
          approval_request_id = coalesce(approval_request_id, v_po_req_id)
      where id = p_order_id;
    else
      update public.purchase_orders
      set status = 'partial',
          updated_at = now(),
          approval_status = 'pending',
          approval_request_id = coalesce(approval_request_id, v_po_req_id)
      where id = p_order_id;
    end if;
  else
    update public.purchase_orders
    set status = 'partial',
        updated_at = now()
    where id = p_order_id;
  end if;

  return v_receipt_id;
end;
$_$;


ALTER FUNCTION "public"."receive_purchase_order_partial"("p_order_id" "uuid", "p_items" "jsonb", "p_occurred_at" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."recompute_stock_for_item"("p_item_id" "text", "p_warehouse_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_is_food boolean := false;
begin
  perform public._require_staff('recompute_stock_for_item');

  if p_item_id is null or btrim(p_item_id) = '' then
    raise exception 'item_id is required';
  end if;
  if p_warehouse_id is null then
    raise exception 'warehouse_id is required';
  end if;

  select (coalesce(mi.category,'') = 'food')
  into v_is_food
  from public.menu_items mi
  where mi.id::text = p_item_id::text;

  insert into public.stock_management(item_id, warehouse_id, available_quantity, qc_hold_quantity, reserved_quantity, unit, low_stock_threshold, last_updated, data)
  select p_item_id, p_warehouse_id, 0, 0, 0, coalesce(mi.unit_type, 'piece'), 5, now(), '{}'::jsonb
  from public.menu_items mi
  where mi.id::text = p_item_id::text
  on conflict (item_id, warehouse_id) do nothing;

  update public.stock_management sm
  set
    reserved_quantity = coalesce((
      select sum(r.quantity)
      from public.order_item_reservations r
      where r.item_id::text = p_item_id::text
        and r.warehouse_id = p_warehouse_id
    ), 0),
    available_quantity = coalesce((
      select sum(
        greatest(
          coalesce(b.quantity_received,0)
          - coalesce(b.quantity_consumed,0)
          - coalesce(b.quantity_transferred,0),
          0
        )
      )
      from public.batches b
      where b.item_id::text = p_item_id::text
        and b.warehouse_id = p_warehouse_id
        and coalesce(b.status,'active') = 'active'
        and coalesce(b.qc_status,'') = 'released'
        and not exists (
          select 1 from public.batch_recalls br
          where br.batch_id = b.id and br.status = 'active'
        )
        and (
          not coalesce(v_is_food, false)
          or (b.expiry_date is not null and b.expiry_date >= current_date)
        )
    ), 0),
    qc_hold_quantity = coalesce((
      select sum(
        greatest(
          coalesce(b.quantity_received,0)
          - coalesce(b.quantity_consumed,0)
          - coalesce(b.quantity_transferred,0),
          0
        )
      )
      from public.batches b
      where b.item_id::text = p_item_id::text
        and b.warehouse_id = p_warehouse_id
        and coalesce(b.status,'active') = 'active'
        and coalesce(b.qc_status,'') <> 'released'
        and not exists (
          select 1 from public.batch_recalls br
          where br.batch_id = b.id and br.status = 'active'
        )
        and (
          not coalesce(v_is_food, false)
          or (b.expiry_date is not null and b.expiry_date >= current_date)
        )
    ), 0),
    last_updated = now(),
    updated_at = now()
  where sm.item_id::text = p_item_id::text
    and sm.warehouse_id = p_warehouse_id;
end;
$$;


ALTER FUNCTION "public"."recompute_stock_for_item"("p_item_id" "text", "p_warehouse_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."record_expense_accrual"("p_expense_id" "uuid", "p_amount" numeric, "p_occurred_at" timestamp with time zone DEFAULT "now"()) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_amount numeric;
  v_entry_id uuid;
  v_expenses uuid;
  v_ap uuid;
begin
  if not public.is_admin() then
    raise exception 'not allowed';
  end if;

  if p_expense_id is null then
    raise exception 'p_expense_id is required';
  end if;

  select coalesce(p_amount, 0)
  into v_amount;
  if v_amount <= 0 then
    select coalesce(e.amount, 0)
    into v_amount
    from public.expenses e
    where e.id = p_expense_id;
  end if;
  if v_amount <= 0 then
    raise exception 'invalid amount';
  end if;

  v_expenses := public.get_account_id_by_code('6100');
  v_ap := public.get_account_id_by_code('2010');
  if v_expenses is null or v_ap is null then
    raise exception 'required accounts not found';
  end if;

  insert into public.journal_entries(entry_date, memo, source_table, source_id, source_event, created_by)
  values (
    coalesce(p_occurred_at, now()),
    concat('Expense accrual ', p_expense_id::text),
    'expenses',
    p_expense_id::text,
    'accrual',
    auth.uid()
  )
  on conflict (source_table, source_id, source_event)
  do update set entry_date = excluded.entry_date, memo = excluded.memo
  returning id into v_entry_id;

  delete from public.journal_lines jl where jl.journal_entry_id = v_entry_id;

  insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
  values
    (v_entry_id, v_expenses, v_amount, 0, 'Accrued expense'),
    (v_entry_id, v_ap, 0, v_amount, 'Accounts payable');
end;
$$;


ALTER FUNCTION "public"."record_expense_accrual"("p_expense_id" "uuid", "p_amount" numeric, "p_occurred_at" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."record_expense_payment"("p_expense_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_amount numeric;
  v_method text;
  v_occurred_at timestamptz;
  v_payment_id uuid;
  v_shift_id uuid;
begin
  if not public.can_manage_expenses() then
    raise exception 'not allowed';
  end if;

  if p_expense_id is null then
    raise exception 'p_expense_id is required';
  end if;

  v_amount := coalesce(p_amount, 0);
  if v_amount <= 0 then
    select coalesce(e.amount, 0)
    into v_amount
    from public.expenses e
    where e.id = p_expense_id;
  end if;

  if v_amount <= 0 then
    raise exception 'invalid amount';
  end if;

  v_method := nullif(trim(coalesce(p_method, '')), '');
  if v_method is null then
    v_method := 'cash';
  end if;
  if v_method = 'card' then
    v_method := 'network';
  elsif v_method = 'bank' then
    v_method := 'kuraimi';
  end if;

  v_occurred_at := coalesce(p_occurred_at, now());
  v_shift_id := public._resolve_open_shift_for_cash(auth.uid());

  if v_method = 'cash' and v_shift_id is null then
    raise exception 'cash method requires an open cash shift';
  end if;

  insert into public.payments(direction, method, amount, currency, reference_table, reference_id, occurred_at, created_by, data, shift_id)
  values (
    'out',
    v_method,
    v_amount,
    'YER',
    'expenses',
    p_expense_id::text,
    v_occurred_at,
    auth.uid(),
    jsonb_build_object('expenseId', p_expense_id::text),
    v_shift_id
  )
  returning id into v_payment_id;

  perform public.post_payment(v_payment_id);
end;
$$;


ALTER FUNCTION "public"."record_expense_payment"("p_expense_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."record_import_expense_payment"("p_import_expense_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_amount numeric;
  v_method text;
  v_occurred_at timestamptz;
  v_payment_id uuid;
begin
  if not public.is_admin() then
    raise exception 'not allowed';
  end if;

  if p_import_expense_id is null then
    raise exception 'p_import_expense_id is required';
  end if;

  v_amount := coalesce(p_amount, 0);
  if v_amount <= 0 then
    select coalesce(ie.amount, 0) * coalesce(ie.exchange_rate, 1)
    into v_amount
    from public.import_expenses ie
    where ie.id = p_import_expense_id;
  end if;
  if v_amount <= 0 then
    raise exception 'invalid amount';
  end if;

  v_method := nullif(trim(coalesce(p_method, '')), '');
  if v_method is null then
    v_method := 'cash';
  end if;

  v_occurred_at := coalesce(p_occurred_at, now());

  insert into public.payments(direction, method, amount, currency, reference_table, reference_id, occurred_at, created_by, data)
  values (
    'out',
    v_method,
    v_amount,
    'YER',
    'import_expenses',
    p_import_expense_id::text,
    v_occurred_at,
    auth.uid(),
    jsonb_build_object('importExpenseId', p_import_expense_id::text)
  )
  returning id into v_payment_id;

  perform public.post_payment(v_payment_id);
end;
$$;


ALTER FUNCTION "public"."record_import_expense_payment"("p_import_expense_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."record_order_payment"("p_order_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone, "p_idempotency_key" "text" DEFAULT NULL::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_amount numeric;
  v_method text;
  v_occurred_at timestamptz;
  v_total numeric;
  v_paid numeric;
  v_idempotency text;
  v_shift_id uuid;
begin
  if auth.role() <> 'service_role' then
    if not public.is_staff() then
      raise exception 'not allowed';
    end if;
    if not public.has_admin_permission('orders.markPaid') then
      raise exception 'not allowed';
    end if;
  end if;
  if p_order_id is null then
    raise exception 'p_order_id is required';
  end if;
  select coalesce(nullif((o.data->>'total')::numeric, null), 0)
  into v_total
  from public.orders o
  where o.id = p_order_id;
  if not found then
    raise exception 'order not found';
  end if;
  v_amount := coalesce(p_amount, 0);
  if v_amount <= 0 then
    raise exception 'invalid amount';
  end if;
  select coalesce(sum(p.amount), 0)
  into v_paid
  from public.payments p
  where p.reference_table = 'orders'
    and p.reference_id = p_order_id::text
    and p.direction = 'in';
  if v_total > 0 and (v_paid + v_amount) > (v_total + 1e-9) then
    raise exception 'paid amount exceeds total';
  end if;
  v_method := nullif(trim(coalesce(p_method, '')), '');
  if v_method is null then
    v_method := 'cash';
  end if;
  v_occurred_at := coalesce(p_occurred_at, now());
  v_idempotency := nullif(trim(coalesce(p_idempotency_key, '')), '');
  select s.id
  into v_shift_id
  from public.cash_shifts s
  where s.cashier_id = auth.uid()
    and coalesce(s.status, 'open') = 'open'
  order by s.opened_at desc
  limit 1;
  if v_method = 'cash' and v_shift_id is null then
    raise exception 'cash method requires an open cash shift';
  end if;
  if v_idempotency is null then
    insert into public.payments(direction, method, amount, currency, reference_table, reference_id, occurred_at, created_by, data, shift_id)
    values (
      'in',
      v_method,
      v_amount,
      'YER',
      'orders',
      p_order_id::text,
      v_occurred_at,
      auth.uid(),
      jsonb_build_object('orderId', p_order_id::text),
      v_shift_id
    );
  else
    insert into public.payments(direction, method, amount, currency, reference_table, reference_id, occurred_at, created_by, data, idempotency_key, shift_id)
    values (
      'in',
      v_method,
      v_amount,
      'YER',
      'orders',
      p_order_id::text,
      v_occurred_at,
      auth.uid(),
      jsonb_build_object('orderId', p_order_id::text),
      v_idempotency,
      v_shift_id
    )
    on conflict (reference_table, reference_id, direction, idempotency_key)
    do update set
      method = excluded.method,
      amount = excluded.amount,
      occurred_at = excluded.occurred_at,
      created_by = coalesce(public.payments.created_by, excluded.created_by),
      data = excluded.data,
      shift_id = coalesce(public.payments.shift_id, excluded.shift_id);
  end if;
end;
$$;


ALTER FUNCTION "public"."record_order_payment"("p_order_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone, "p_idempotency_key" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."record_order_payment"("p_order_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone, "p_idempotency_key" "text" DEFAULT NULL::"text", "p_currency" "text" DEFAULT NULL::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_amount numeric;
  v_method text;
  v_occurred_at timestamptz;
  v_total numeric;
  v_paid numeric;
  v_idempotency text;
  v_shift_id uuid;
  v_base text;
  v_currency text;
begin
  if not public.is_staff() then
    raise exception 'not allowed';
  end if;
  if p_order_id is null then
    raise exception 'p_order_id is required';
  end if;
  v_base := public.get_base_currency();

  select coalesce(o.total, coalesce(nullif((o.data->>'total')::numeric, null), 0)),
         coalesce(nullif(btrim(coalesce(o.currency, '')), ''), nullif(btrim(coalesce(o.data->>'currency', '')), ''), v_base)
  into v_total, v_currency
  from public.orders o
  where o.id = p_order_id;

  if not found then
    raise exception 'order not found';
  end if;

  v_amount := coalesce(p_amount, 0);
  if v_amount <= 0 then
    raise exception 'invalid amount';
  end if;

  select coalesce(sum(p.amount), 0)
  into v_paid
  from public.payments p
  where p.reference_table = 'orders'
    and p.reference_id = p_order_id::text
    and p.direction = 'in';

  if v_total > 0 and (v_paid + v_amount) > (v_total + 1e-9) then
    raise exception 'paid amount exceeds total';
  end if;

  v_method := nullif(trim(coalesce(p_method, '')), '');
  if v_method is null then
    v_method := 'cash';
  end if;
  v_occurred_at := coalesce(p_occurred_at, now());
  v_idempotency := nullif(trim(coalesce(p_idempotency_key, '')), '');

  v_currency := upper(nullif(btrim(coalesce(p_currency, '')), ''));
  if v_currency is null then
    v_currency := upper(nullif(btrim(coalesce(v_currency, '')), ''));
  end if;
  if v_currency is null then
    v_currency := v_base;
  end if;

  select s.id
  into v_shift_id
  from public.cash_shifts s
  where s.cashier_id = auth.uid()
    and coalesce(s.status, 'open') = 'open'
  order by s.opened_at desc
  limit 1;

  if v_method = 'cash' and v_shift_id is null then
    raise exception 'cash method requires an open cash shift';
  end if;

  if v_idempotency is null then
    insert into public.payments(direction, method, amount, currency, reference_table, reference_id, occurred_at, created_by, data, shift_id)
    values (
      'in',
      v_method,
      v_amount,
      v_currency,
      'orders',
      p_order_id::text,
      v_occurred_at,
      auth.uid(),
      jsonb_build_object('orderId', p_order_id::text),
      v_shift_id
    );
  else
    insert into public.payments(direction, method, amount, currency, reference_table, reference_id, occurred_at, created_by, data, idempotency_key, shift_id)
    values (
      'in',
      v_method,
      v_amount,
      v_currency,
      'orders',
      p_order_id::text,
      v_occurred_at,
      auth.uid(),
      jsonb_build_object('orderId', p_order_id::text),
      v_idempotency,
      v_shift_id
    )
    on conflict (reference_table, reference_id, direction, idempotency_key)
    do update set
      method = excluded.method,
      amount = excluded.amount,
      currency = excluded.currency,
      occurred_at = excluded.occurred_at,
      created_by = coalesce(public.payments.created_by, excluded.created_by),
      data = excluded.data,
      shift_id = coalesce(public.payments.shift_id, excluded.shift_id);
  end if;
end;
$$;


ALTER FUNCTION "public"."record_order_payment"("p_order_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone, "p_idempotency_key" "text", "p_currency" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."record_purchase_order_payment"("p_purchase_order_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone, "p_data" "jsonb" DEFAULT '{}'::"jsonb") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_amount numeric;
  v_total numeric;
  v_status text;
  v_method text;
  v_occurred_at timestamptz;
  v_payment_id uuid;
  v_data jsonb;
  v_idempotency_key text;
  v_shift_id uuid;
  v_paid_sum numeric;
begin
  if not public.can_manage_stock() then
    raise exception 'not allowed';
  end if;

  if p_purchase_order_id is null then
    raise exception 'p_purchase_order_id is required';
  end if;

  select coalesce(po.total_amount, 0), po.status
  into v_total, v_status
  from public.purchase_orders po
  where po.id = p_purchase_order_id
  for update;

  if not found then
    raise exception 'purchase order not found';
  end if;

  if v_status = 'cancelled' then
    raise exception 'cannot pay cancelled purchase order';
  end if;

  v_total := coalesce(v_total, 0);
  if v_total <= 0 then
    raise exception 'purchase order total is zero';
  end if;

  v_amount := coalesce(p_amount, 0);
  if v_amount <= 0 then
    raise exception 'invalid amount';
  end if;

  select coalesce(sum(p.amount), 0)
  into v_paid_sum
  from public.payments p
  where p.reference_table = 'purchase_orders'
    and p.direction = 'out'
    and p.reference_id = p_purchase_order_id::text;

  if (v_total - coalesce(v_paid_sum, 0)) <= 0.000000001 then
    raise exception 'purchase order already fully paid';
  end if;

  if (coalesce(v_paid_sum, 0) + v_amount) > (v_total + 0.000000001) then
    raise exception 'paid amount exceeds total';
  end if;

  v_method := nullif(trim(coalesce(p_method, '')), '');
  if v_method is null then
    v_method := 'cash';
  end if;

  v_occurred_at := coalesce(p_occurred_at, now());
  v_data := jsonb_strip_nulls(jsonb_build_object('purchaseOrderId', p_purchase_order_id::text) || coalesce(p_data, '{}'::jsonb));
  v_idempotency_key := nullif(trim(coalesce(v_data->>'idempotencyKey', '')), '');
  v_shift_id := public._resolve_open_shift_for_cash(auth.uid());

  if v_method = 'cash' and v_shift_id is null then
    raise exception 'cash method requires an open cash shift';
  end if;

  if v_idempotency_key is null then
    insert into public.payments(direction, method, amount, currency, reference_table, reference_id, occurred_at, created_by, data, shift_id)
    values (
      'out',
      v_method,
      v_amount,
      'YER',
      'purchase_orders',
      p_purchase_order_id::text,
      v_occurred_at,
      auth.uid(),
      v_data,
      v_shift_id
    )
    returning id into v_payment_id;
  else
    insert into public.payments(direction, method, amount, currency, reference_table, reference_id, occurred_at, created_by, data, idempotency_key, shift_id)
    values (
      'out',
      v_method,
      v_amount,
      'YER',
      'purchase_orders',
      p_purchase_order_id::text,
      v_occurred_at,
      auth.uid(),
      v_data,
      v_idempotency_key,
      v_shift_id
    )
    on conflict (reference_table, reference_id, direction, idempotency_key)
    do nothing
    returning id into v_payment_id;

    if v_payment_id is null then
      return;
    end if;
  end if;
end;
$$;


ALTER FUNCTION "public"."record_purchase_order_payment"("p_purchase_order_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone, "p_data" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."record_purchase_order_payment"("p_purchase_order_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone, "p_data" "jsonb" DEFAULT '{}'::"jsonb", "p_currency" "text" DEFAULT NULL::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_amount numeric;
  v_total numeric;
  v_status text;
  v_method text;
  v_occurred_at timestamptz;
  v_payment_id uuid;
  v_data jsonb;
  v_idempotency_key text;
  v_shift_id uuid;
  v_paid_sum numeric;
  v_currency text;
  v_base text;
begin
  if not public.can_manage_stock() then
    raise exception 'not allowed';
  end if;
  if p_purchase_order_id is null then
    raise exception 'p_purchase_order_id is required';
  end if;
  select coalesce(po.total_amount, 0), po.status
  into v_total, v_status
  from public.purchase_orders po
  where po.id = p_purchase_order_id
  for update;
  if not found then
    raise exception 'purchase order not found';
  end if;
  if v_status = 'cancelled' then
    raise exception 'cannot pay cancelled purchase order';
  end if;
  v_total := coalesce(v_total, 0);
  if v_total <= 0 then
    raise exception 'purchase order total is zero';
  end if;
  v_amount := coalesce(p_amount, 0);
  if v_amount <= 0 then
    raise exception 'invalid amount';
  end if;
  select coalesce(sum(p.amount), 0)
  into v_paid_sum
  from public.payments p
  where p.reference_table = 'purchase_orders'
    and p.direction = 'out'
    and p.reference_id = p_purchase_order_id::text;
  if (v_total - coalesce(v_paid_sum, 0)) <= 0.000000001 then
    raise exception 'purchase order already fully paid';
  end if;
  if (coalesce(v_paid_sum, 0) + v_amount) > (v_total + 0.000000001) then
    raise exception 'paid amount exceeds total';
  end if;
  v_method := nullif(trim(coalesce(p_method, '')), '');
  if v_method is null then
    v_method := 'cash';
  end if;
  v_occurred_at := coalesce(p_occurred_at, now());
  v_data := jsonb_strip_nulls(jsonb_build_object('purchaseOrderId', p_purchase_order_id::text) || coalesce(p_data, '{}'::jsonb));
  v_idempotency_key := nullif(trim(coalesce(v_data->>'idempotencyKey', '')), '');
  v_shift_id := public._resolve_open_shift_for_cash(auth.uid());
  if v_method = 'cash' and v_shift_id is null then
    raise exception 'cash method requires an open cash shift';
  end if;
  v_base := public.get_base_currency();
  v_currency := upper(nullif(btrim(coalesce(p_currency, '')), ''));
  if v_currency is null then
    v_currency := v_base;
  end if;
  if v_idempotency_key is null then
    insert into public.payments(direction, method, amount, currency, reference_table, reference_id, occurred_at, created_by, data, shift_id)
    values (
      'out',
      v_method,
      v_amount,
      v_currency,
      'purchase_orders',
      p_purchase_order_id::text,
      v_occurred_at,
      auth.uid(),
      v_data,
      v_shift_id
    )
    returning id into v_payment_id;
  else
    insert into public.payments(direction, method, amount, currency, reference_table, reference_id, occurred_at, created_by, data, idempotency_key, shift_id)
    values (
      'out',
      v_method,
      v_amount,
      v_currency,
      'purchase_orders',
      p_purchase_order_id::text,
      v_occurred_at,
      auth.uid(),
      v_data,
      v_idempotency_key,
      v_shift_id
    )
    on conflict (reference_table, reference_id, direction, idempotency_key)
    do nothing
    returning id into v_payment_id;
    if v_payment_id is null then
      return;
    end if;
  end if;
end;
$$;


ALTER FUNCTION "public"."record_purchase_order_payment"("p_purchase_order_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone, "p_data" "jsonb", "p_currency" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."record_shift_cash_movement"("p_shift_id" "uuid", "p_direction" "text", "p_amount" numeric, "p_reason" "text" DEFAULT NULL::"text", "p_occurred_at" timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_shift public.cash_shifts%rowtype;
  v_amount numeric;
  v_dir text;
  v_actor_role text;
  v_payment_id uuid;
  v_reason text;
begin
  if auth.uid() is null then
    raise exception 'not allowed';
  end if;

  if p_shift_id is null then
    raise exception 'p_shift_id is required';
  end if;

  select au.role
  into v_actor_role
  from public.admin_users au
  where au.auth_user_id = auth.uid()
    and au.is_active = true;

  if v_actor_role is null then
    raise exception 'not allowed';
  end if;

  select *
  into v_shift
  from public.cash_shifts s
  where s.id = p_shift_id
  for update;

  if not found then
    raise exception 'cash shift not found';
  end if;

  if coalesce(v_shift.status, 'open') <> 'open' then
    raise exception 'cash shift is not open';
  end if;

  if auth.uid() <> v_shift.cashier_id and (v_actor_role not in ('owner', 'manager') and not public.has_admin_permission('cashShifts.manage')) then
    raise exception 'not allowed';
  end if;

  v_dir := lower(nullif(trim(coalesce(p_direction, '')), ''));
  if v_dir not in ('in', 'out') then
    raise exception 'invalid direction';
  end if;

  if auth.uid() = v_shift.cashier_id then
    if v_dir = 'in' and not public.has_admin_permission('cashShifts.cashIn') then
      raise exception 'not allowed';
    end if;
    if v_dir = 'out' and not public.has_admin_permission('cashShifts.cashOut') then
      raise exception 'not allowed';
    end if;
  end if;

  v_amount := coalesce(p_amount, 0);
  if v_amount <= 0 then
    raise exception 'invalid amount';
  end if;

  v_reason := nullif(trim(coalesce(p_reason, '')), '');
  if v_dir = 'out' and v_reason is null then
    raise exception '   .';
  end if;

  insert into public.payments(direction, method, amount, currency, reference_table, reference_id, occurred_at, created_by, data, shift_id)
  values (
    v_dir,
    'cash',
    v_amount,
    'YER',
    'cash_shifts',
    p_shift_id::text,
    coalesce(p_occurred_at, now()),
    auth.uid(),
    jsonb_strip_nulls(jsonb_build_object('shiftId', p_shift_id::text, 'reason', v_reason, 'kind', 'cash_movement')),
    p_shift_id
  )
  returning id into v_payment_id;

  perform public.post_payment(v_payment_id);

  insert into public.system_audit_logs(action, module, details, performed_by, performed_at, metadata, risk_level, reason_code)
  values (
    case when v_dir = 'in' then 'cash_shift_cash_in' else 'cash_shift_cash_out' end,
    'cash_shifts',
    case when v_dir = 'in' then 'Cash movement in' else 'Cash movement out' end,
    auth.uid(),
    now(),
    jsonb_strip_nulls(jsonb_build_object('shiftId', p_shift_id::text, 'paymentId', v_payment_id::text, 'amount', v_amount, 'direction', v_dir, 'reason', v_reason)),
    'MEDIUM',
    'SHIFT_CASH_MOVE'
  );
end;
$$;


ALTER FUNCTION "public"."record_shift_cash_movement"("p_shift_id" "uuid", "p_direction" "text", "p_amount" numeric, "p_reason" "text", "p_occurred_at" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."record_wastage_light"("p_item_id" "uuid", "p_warehouse_id" "uuid", "p_quantity" numeric, "p_batch_id" "uuid" DEFAULT NULL::"uuid", "p_unit" "text" DEFAULT 'piece'::"text", "p_reason" "text" DEFAULT NULL::"text", "p_occurred_at" timestamp with time zone DEFAULT "now"()) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_actor uuid;
  v_wh uuid;
  v_item_id text;
  v_needed numeric;
  v_batch record;
  v_reserved_other numeric;
  v_available numeric;
  v_alloc numeric;
  v_unit_cost numeric;
  v_total_cost numeric;
  v_movement_id uuid;
begin
  perform public._require_stock_manager('record_wastage_light');

  v_actor := auth.uid();
  if p_item_id is null or p_quantity is null or p_quantity <= 0 then
    raise exception 'invalid params';
  end if;

  v_item_id := p_item_id::text;
  v_wh := coalesce(p_warehouse_id, public._resolve_default_warehouse_id());
  if v_wh is null then
    raise exception 'warehouse_id is required';
  end if;

  v_needed := p_quantity;

  if p_batch_id is not null then
    select bb.batch_id, bb.quantity, bb.expiry_date
    into v_batch
    from public.batch_balances bb
    where bb.item_id = v_item_id
      and bb.warehouse_id = v_wh
      and bb.batch_id = p_batch_id
    for update;
    if not found then
      raise exception 'batch not found for item %', v_item_id;
    end if;

    select coalesce(sum(br.quantity), 0)
    into v_reserved_other
    from public.batch_reservations br
    where br.item_id = v_item_id
      and br.warehouse_id = v_wh
      and br.batch_id = p_batch_id;

    v_available := greatest(coalesce(v_batch.quantity, 0) - coalesce(v_reserved_other, 0), 0);
    if v_available + 1e-9 < v_needed then
      raise exception 'insufficient unreserved stock for wastage';
    end if;
  end if;

  for v_batch in
    select bb.batch_id, bb.quantity, bb.expiry_date
    from public.batch_balances bb
    where bb.item_id = v_item_id
      and bb.warehouse_id = v_wh
      and bb.quantity > 0
      and (p_batch_id is null or bb.batch_id = p_batch_id)
    order by bb.expiry_date asc nulls last, bb.batch_id asc
  loop
    exit when v_needed <= 0;

    select coalesce(sum(br.quantity), 0)
    into v_reserved_other
    from public.batch_reservations br
    where br.item_id = v_item_id
      and br.warehouse_id = v_wh
      and br.batch_id = v_batch.batch_id;

    v_available := greatest(coalesce(v_batch.quantity, 0) - coalesce(v_reserved_other, 0), 0);
    if v_available <= 0 then
      continue;
    end if;

    v_alloc := least(v_needed, v_available);
    if v_alloc <= 0 then
      continue;
    end if;

    update public.batch_balances
    set quantity = quantity - v_alloc,
        updated_at = now()
    where item_id = v_item_id
      and batch_id = v_batch.batch_id
      and warehouse_id = v_wh;

    select im.unit_cost
    into v_unit_cost
    from public.inventory_movements im
    where im.batch_id = v_batch.batch_id
      and im.item_id::text = v_item_id
      and im.movement_type = 'purchase_in'
    order by im.occurred_at asc
    limit 1;
    v_unit_cost := coalesce(v_unit_cost, 0);
    v_total_cost := v_alloc * v_unit_cost;

    insert into public.inventory_movements(
      item_id, movement_type, quantity, unit_cost, total_cost,
      reference_table, reference_id, occurred_at, created_by, data, batch_id, warehouse_id
    )
    values (
      v_item_id, 'wastage_out', v_alloc, v_unit_cost, v_total_cost,
      'accounting_light_entries', null, coalesce(p_occurred_at, now()), v_actor,
      jsonb_build_object('reason', coalesce(p_reason,''), 'warehouseId', v_wh, 'batchId', v_batch.batch_id, 'expiryDate', v_batch.expiry_date),
      v_batch.batch_id, v_wh
    )
    returning id into v_movement_id;
    perform public.post_inventory_movement(v_movement_id);

    insert into public.accounting_light_entries(
      entry_type, item_id, warehouse_id, batch_id, quantity, unit, unit_cost, total_cost,
      occurred_at, debit_account, credit_account, created_by, notes, source_ref
    )
    values (
      'wastage', v_item_id, v_wh, v_batch.batch_id, v_alloc, p_unit,
      coalesce(v_unit_cost,0), v_total_cost, coalesce(p_occurred_at, now()),
      'shrinkage', 'inventory', v_actor, p_reason, v_movement_id::text
    );

    v_needed := v_needed - v_alloc;
  end loop;

  if v_needed > 0 then
    raise exception 'insufficient unreserved stock for wastage';
  end if;

  update public.stock_management sm
  set available_quantity = coalesce((
        select sum(bb.quantity)
        from public.batch_balances bb
        where bb.item_id = v_item_id
          and bb.warehouse_id = v_wh
      ), 0),
      reserved_quantity = coalesce((
        select sum(br.quantity)
        from public.batch_reservations br
        where br.item_id = v_item_id
          and br.warehouse_id = v_wh
      ), 0),
      updated_at = now(),
      last_updated = now()
  where sm.item_id::text = v_item_id
    and sm.warehouse_id = v_wh;

  insert into public.system_audit_logs(action, module, details, performed_by, performed_at, metadata)
  values (
    'wastage.recorded',
    'stock',
    coalesce(p_reason,''),
    v_actor,
    now(),
    jsonb_build_object('itemId', v_item_id, 'warehouseId', v_wh, 'batchId', p_batch_id, 'quantity', p_quantity, 'unitCost', null)
  );
end;
$$;


ALTER FUNCTION "public"."record_wastage_light"("p_item_id" "uuid", "p_warehouse_id" "uuid", "p_quantity" numeric, "p_batch_id" "uuid", "p_unit" "text", "p_reason" "text", "p_occurred_at" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."register_pos_offline_sale_created"("p_offline_id" "text", "p_order_id" "uuid", "p_created_at" timestamp with time zone, "p_warehouse_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_actor uuid;
begin
  v_actor := auth.uid();
  if v_actor is null then
    raise exception 'not authenticated';
  end if;
  if not public.is_staff() then
    raise exception 'not allowed';
  end if;

  if p_offline_id is null or btrim(p_offline_id) = '' then
    raise exception 'p_offline_id is required';
  end if;
  if p_order_id is null then
    raise exception 'p_order_id is required';
  end if;
  if p_warehouse_id is null then
    raise exception 'p_warehouse_id is required';
  end if;

  insert into public.pos_offline_sales(offline_id, order_id, warehouse_id, state, payload, created_by, created_at, updated_at)
  values (p_offline_id, p_order_id, p_warehouse_id, 'CREATED_OFFLINE', '{}'::jsonb, v_actor, coalesce(p_created_at, now()), now())
  on conflict (offline_id)
  do update set
    order_id = excluded.order_id,
    warehouse_id = excluded.warehouse_id,
    created_by = coalesce(public.pos_offline_sales.created_by, excluded.created_by),
    created_at = least(public.pos_offline_sales.created_at, excluded.created_at),
    updated_at = now();

  return jsonb_build_object('status', 'OK', 'offlineId', p_offline_id, 'orderId', p_order_id::text);
end;
$$;


ALTER FUNCTION "public"."register_pos_offline_sale_created"("p_offline_id" "text", "p_order_id" "uuid", "p_created_at" timestamp with time zone, "p_warehouse_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."reject_approval_request"("p_request_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  update public.approval_requests
  set status = 'rejected', rejected_by = auth.uid(), rejected_at = now()
  where id = p_request_id;
  update public.approval_steps
  set status = 'rejected', action_by = auth.uid(), action_at = now()
  where request_id = p_request_id and status = 'pending';
end;
$$;


ALTER FUNCTION "public"."reject_approval_request"("p_request_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."release_reserved_stock_for_order"("p_items" "jsonb", "p_order_id" "uuid" DEFAULT NULL::"uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
declare
  v_wh uuid;
begin
  if p_order_id is null then
    raise exception 'p_order_id is required';
  end if;
  select
    coalesce(
      o.warehouse_id,
      case
        when nullif(o.data->>'warehouseId','') is not null
             and (o.data->>'warehouseId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$'
          then (o.data->>'warehouseId')::uuid
        else null
      end
    )
  into v_wh
  from public.orders o
  where o.id = p_order_id;

  if v_wh is null then
    begin
      v_wh := public._resolve_default_warehouse_id();
    exception when others then
      v_wh := null;
    end;
  end if;

  if v_wh is null then
    raise exception 'warehouse_id is required';
  end if;

  perform public.release_reserved_stock_for_order(p_items, p_order_id, v_wh);
end;
$_$;


ALTER FUNCTION "public"."release_reserved_stock_for_order"("p_items" "jsonb", "p_order_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."release_reserved_stock_for_order"("p_items" "jsonb", "p_order_id" "uuid" DEFAULT NULL::"uuid", "p_warehouse_id" "uuid" DEFAULT NULL::"uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_actor uuid;
  v_item jsonb;
  v_item_id text;
  v_qty numeric;
  v_to_release numeric;
  v_row record;
  v_take numeric;
  v_is_food boolean;
begin
  v_actor := auth.uid();
  if v_actor is null then
    raise exception 'not authenticated';
  end if;
  if p_order_id is null then
    raise exception 'p_order_id is required';
  end if;
  if p_warehouse_id is null then
    raise exception 'warehouse_id is required';
  end if;
  if p_items is null or jsonb_typeof(p_items) <> 'array' then
    raise exception 'p_items must be a json array';
  end if;

  if not exists (select 1 from public.orders o where o.id = p_order_id) then
    raise exception 'order not found';
  end if;

  if not public.is_staff() then
    if not exists (
      select 1
      from public.orders o
      where o.id = p_order_id
        and o.customer_auth_user_id = v_actor
    ) then
      raise exception 'not allowed';
    end if;
  end if;

  for v_item in select value from jsonb_array_elements(coalesce(p_items, '[]'::jsonb))
  loop
    v_item_id := nullif(trim(coalesce(v_item->>'itemId', v_item->>'id')), '');
    v_qty := coalesce(nullif(v_item->>'quantity','')::numeric, nullif(v_item->>'qty','')::numeric, 0);
    if v_item_id is null or v_qty <= 0 then
      continue;
    end if;

    v_to_release := v_qty;
    for v_row in
      select r.id, r.quantity
      from public.order_item_reservations r
      where r.order_id = p_order_id
        and r.item_id::text = v_item_id::text
        and r.warehouse_id = p_warehouse_id
        and r.quantity > 0
      order by r.created_at asc, r.id asc
    loop
      exit when v_to_release <= 0;
      v_take := least(v_to_release, coalesce(v_row.quantity, 0));
      if v_take <= 0 then
        continue;
      end if;
      if coalesce(v_row.quantity, 0) - v_take <= 0 then
        delete from public.order_item_reservations r
        where r.id = v_row.id;
      else
        update public.order_item_reservations
        set quantity = quantity - v_take,
            updated_at = now()
        where id = v_row.id;
      end if;
      v_to_release := v_to_release - v_take;
    end loop;

    select (coalesce(mi.category,'') = 'food')
    into v_is_food
    from public.menu_items mi
    where mi.id::text = v_item_id::text;

    update public.stock_management sm
    set reserved_quantity = coalesce((
          select sum(r2.quantity)
          from public.order_item_reservations r2
          where r2.item_id::text = v_item_id::text
            and r2.warehouse_id = p_warehouse_id
        ), 0),
        available_quantity = coalesce((
          select sum(
            greatest(
              coalesce(b.quantity_received,0)
              - coalesce(b.quantity_consumed,0)
              - coalesce(b.quantity_transferred,0),
              0
            )
          )
          from public.batches b
          where b.item_id::text = v_item_id::text
            and b.warehouse_id = p_warehouse_id
            and coalesce(b.status,'active') = 'active'
            and coalesce(b.qc_status,'') = 'released'
            and not exists (
              select 1 from public.batch_recalls br
              where br.batch_id = b.id and br.status = 'active'
            )
            and (
              not coalesce(v_is_food, false)
              or (b.expiry_date is not null and b.expiry_date >= current_date)
            )
        ), 0),
        last_updated = now(),
        updated_at = now()
    where sm.item_id::text = v_item_id::text
      and sm.warehouse_id = p_warehouse_id;
  end loop;
end;
$$;


ALTER FUNCTION "public"."release_reserved_stock_for_order"("p_items" "jsonb", "p_order_id" "uuid", "p_warehouse_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."request_offline_reconciliation"("p_offline_id" "text", "p_reason" "text" DEFAULT NULL::"text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_actor uuid;
  v_row record;
  v_req_id uuid;
  v_reason text;
begin
  v_actor := auth.uid();
  if v_actor is null then
    raise exception 'not authenticated';
  end if;
  if not public.is_staff() then
    raise exception 'not allowed';
  end if;

  v_reason := nullif(trim(coalesce(p_reason, '')), '');

  select *
  into v_row
  from public.pos_offline_sales s
  where s.offline_id = p_offline_id
  for update;

  if not found then
    raise exception 'offline sale not found';
  end if;

  if v_row.state not in ('CONFLICT','FAILED') then
    return jsonb_build_object('status', 'NOT_REQUIRED', 'offlineId', p_offline_id, 'state', v_row.state);
  end if;

  if v_row.reconciliation_status = 'PENDING'
     and v_row.reconciliation_approval_request_id is not null then
    return jsonb_build_object(
      'status', 'PENDING',
      'offlineId', p_offline_id,
      'approvalRequestId', v_row.reconciliation_approval_request_id::text
    );
  end if;

  v_req_id := public.create_approval_request(
    'pos_offline_sales',
    p_offline_id,
    'offline_reconciliation',
    0,
    jsonb_build_object(
      'offlineId', p_offline_id,
      'orderId', v_row.order_id::text,
      'state', v_row.state,
      'lastError', v_row.last_error,
      'reason', v_reason
    )
  );

  update public.pos_offline_sales
  set reconciliation_status = 'PENDING',
      reconciliation_approval_request_id = v_req_id,
      reconciliation_note = v_reason,
      updated_at = now()
  where offline_id = p_offline_id;

  return jsonb_build_object(
    'status', 'PENDING',
    'offlineId', p_offline_id,
    'approvalRequestId', v_req_id::text
  );
end;
$$;


ALTER FUNCTION "public"."request_offline_reconciliation"("p_offline_id" "text", "p_reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."reserve_stock_for_order"("p_payload" "jsonb") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
declare
  v_items jsonb;
  v_order_id_text text;
  v_warehouse_id_text text;
  v_order_id uuid;
  v_warehouse_id uuid;
begin
  if p_payload is null or jsonb_typeof(p_payload) <> 'object' then
    raise exception 'p_payload must be a json object';
  end if;

  v_items := p_payload->'p_items';
  if v_items is null then
    v_items := p_payload->'items';
  end if;
  if v_items is null then
    v_items := '[]'::jsonb;
  end if;

  v_order_id_text := nullif(coalesce(p_payload->>'p_order_id', p_payload->>'order_id', p_payload->>'orderId'), '');
  if v_order_id_text is not null and v_order_id_text ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$' then
    v_order_id := v_order_id_text::uuid;
  else
    v_order_id := null;
  end if;

  v_warehouse_id_text := nullif(coalesce(p_payload->>'p_warehouse_id', p_payload->>'warehouse_id', p_payload->>'warehouseId'), '');
  if v_warehouse_id_text is not null and v_warehouse_id_text ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$' then
    v_warehouse_id := v_warehouse_id_text::uuid;
  else
    v_warehouse_id := null;
  end if;

  perform public.reserve_stock_for_order(v_items, v_order_id, v_warehouse_id);
end;
$_$;


ALTER FUNCTION "public"."reserve_stock_for_order"("p_payload" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."reserve_stock_for_order"("p_items" "jsonb", "p_order_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  raise exception 'warehouse_id is required';
end;
$$;


ALTER FUNCTION "public"."reserve_stock_for_order"("p_items" "jsonb", "p_order_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."reserve_stock_for_order"("p_items" "jsonb", "p_order_id" "uuid" DEFAULT NULL::"uuid", "p_warehouse_id" "uuid" DEFAULT NULL::"uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_item jsonb;
  v_item_id text;
  v_requested numeric;
  v_needed numeric;
  v_is_food boolean;
  v_batch record;
  v_reserved_other numeric;
  v_free numeric;
  v_alloc numeric;
begin
  if auth.uid() is null then
    raise exception 'not authenticated';
  end if;
  if p_order_id is null or p_warehouse_id is null then
    raise exception 'order_id and warehouse_id are required';
  end if;
  if p_items is null or jsonb_typeof(p_items) <> 'array' then
    raise exception 'p_items must be a json array';
  end if;

  for v_item in select value from jsonb_array_elements(coalesce(p_items, '[]'::jsonb))
  loop
    v_item_id := coalesce(nullif(v_item->>'itemId',''), nullif(v_item->>'id',''));
    v_requested := coalesce(nullif(v_item->>'quantity','')::numeric, nullif(v_item->>'qty','')::numeric, 0);
    if v_item_id is null or v_item_id = '' or v_requested <= 0 then
      continue;
    end if;

    select (coalesce(mi.category,'') = 'food')
    into v_is_food
    from public.menu_items mi
    where mi.id::text = v_item_id::text;

    delete from public.order_item_reservations r
    where r.order_id = p_order_id
      and r.item_id = v_item_id::text
      and r.warehouse_id = p_warehouse_id;

    v_needed := v_requested;

    for v_batch in
      select
        b.id as batch_id,
        b.expiry_date,
        b.unit_cost,
        greatest(
          coalesce(b.quantity_received,0)
          - coalesce(b.quantity_consumed,0)
          - coalesce(b.quantity_transferred,0),
          0
        ) as remaining_qty
      from public.batches b
      where b.item_id::text = v_item_id::text
        and b.warehouse_id = p_warehouse_id
        and coalesce(b.status, 'active') = 'active'
        and coalesce(b.qc_status,'') = 'released'
        and not exists (
          select 1 from public.batch_recalls br
          where br.batch_id = b.id and br.status = 'active'
        )
        and (
          not coalesce(v_is_food, false)
          or (b.expiry_date is not null and b.expiry_date >= current_date)
        )
      order by b.expiry_date asc nulls last, b.created_at asc, b.id asc
      for update
    loop
      exit when v_needed <= 0;
      if coalesce(v_batch.remaining_qty, 0) <= 0 then
        continue;
      end if;

      select coalesce(sum(r2.quantity), 0)
      into v_reserved_other
      from public.order_item_reservations r2
      where r2.batch_id = v_batch.batch_id
        and r2.warehouse_id = p_warehouse_id
        and r2.order_id <> p_order_id;

      v_free := greatest(coalesce(v_batch.remaining_qty, 0) - coalesce(v_reserved_other, 0), 0);
      if v_free <= 0 then
        continue;
      end if;

      v_alloc := least(v_needed, v_free);
      if v_alloc <= 0 then
        continue;
      end if;

      insert into public.order_item_reservations(order_id, item_id, warehouse_id, batch_id, quantity, created_at, updated_at)
      values (p_order_id, v_item_id::text, p_warehouse_id, v_batch.batch_id, v_alloc, now(), now());

      v_needed := v_needed - v_alloc;
    end loop;

    if v_needed > 0 then
      raise exception 'INSUFFICIENT_FEFO_BATCH_STOCK_FOR_ITEM_%', v_item_id;
    end if;

    update public.stock_management sm
    set reserved_quantity = coalesce((
          select sum(r.quantity)
          from public.order_item_reservations r
          where r.item_id = v_item_id::text
            and r.warehouse_id = p_warehouse_id
        ), 0),
        available_quantity = coalesce((
          select sum(
            greatest(coalesce(b.quantity_received,0) - coalesce(b.quantity_consumed,0) - coalesce(b.quantity_transferred,0), 0)
          )
          from public.batches b
          where b.item_id::text = v_item_id::text
            and b.warehouse_id = p_warehouse_id
            and coalesce(b.status,'active') = 'active'
            and coalesce(b.qc_status,'') = 'released'
            and not exists (
              select 1 from public.batch_recalls br
              where br.batch_id = b.id and br.status = 'active'
            )
            and (
              not coalesce(v_is_food, false)
              or (b.expiry_date is not null and b.expiry_date >= current_date)
            )
        ), 0),
        last_updated = now(),
        updated_at = now()
    where sm.item_id::text = v_item_id::text
      and sm.warehouse_id = p_warehouse_id;
  end loop;
end;
$$;


ALTER FUNCTION "public"."reserve_stock_for_order"("p_items" "jsonb", "p_order_id" "uuid", "p_warehouse_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."retry_offline_pos_sale"("p_offline_id" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_sale record;
  v_err text;
  v_result jsonb;
  v_i int := 0;
  v_payment jsonb;
begin
  if p_offline_id is null or btrim(p_offline_id) = '' then
    raise exception 'p_offline_id is required';
  end if;

  perform pg_advisory_xact_lock(hashtext(p_offline_id));

  select *
  into v_sale
  from public.pos_offline_sales s
  where s.offline_id = p_offline_id
  for update;

  if not found then
    raise exception 'offline_sale_not_found';
  end if;

  if coalesce(v_sale.state, 'SYNCED') = 'DELIVERED' then
    return jsonb_build_object('status','DELIVERED','orderId', v_sale.order_id::text, 'offlineId', p_offline_id);
  end if;

  begin
    perform public.confirm_order_delivery(
      v_sale.order_id,
      coalesce(v_sale.payload->'items','[]'::jsonb),
      coalesce(v_sale.payload, '{}'::jsonb),
      coalesce(nullif(v_sale.payload->>'warehouseId','')::uuid, public._resolve_default_warehouse_id())
    );
  exception when others then
    v_err := sqlerrm;
    update public.pos_offline_sales
    set state = case
          when v_err ilike '%insufficient%' then 'CONFLICT'
          when v_err ilike '%expired%' then 'CONFLICT'
          when v_err ilike '%reservation%' then 'CONFLICT'
          when v_err ilike '%delivery_driver_required%' then 'CONFLICT'
          else 'FAILED'
        end,
        last_error = v_err,
        updated_at = now()
    where offline_id = p_offline_id;
    update public.orders
    set data = jsonb_set(coalesce(data, '{}'::jsonb), '{offlineState}', to_jsonb('CONFLICT'::text), true),
        updated_at = now()
    where id = v_sale.order_id;
    return jsonb_build_object('status', 'CONFLICT', 'orderId', v_sale.order_id::text, 'offlineId', p_offline_id, 'error', v_err);
  end;

  for v_payment in
    select value
    from jsonb_array_elements(coalesce(v_sale.payload->'payments','[]'::jsonb))
  loop
    begin
      perform public.record_order_payment(
        v_sale.order_id,
        coalesce(nullif(v_payment->>'amount','')::numeric, 0),
        coalesce(nullif(v_payment->>'method',''), ''),
        coalesce(nullif(v_payment->>'occurredAt','')::timestamptz, now()),
        'offline:' || p_offline_id || ':retry:' || v_i::text
      );
    exception when others then
      null;
    end;
    v_i := v_i + 1;
  end loop;

  update public.pos_offline_sales
  set state = 'DELIVERED',
      last_error = null,
      updated_at = now()
  where offline_id = p_offline_id;

  update public.orders
  set data = jsonb_set(coalesce(data, '{}'::jsonb), '{offlineState}', to_jsonb('DELIVERED'::text), true),
      updated_at = now()
  where id = v_sale.order_id;

  v_result := jsonb_build_object('status', 'DELIVERED', 'orderId', v_sale.order_id::text, 'offlineId', p_offline_id);
  return v_result;
end;
$$;


ALTER FUNCTION "public"."retry_offline_pos_sale"("p_offline_id" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."reverse_journal_entry"("p_journal_entry_id" "uuid", "p_reason" "text") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_src public.journal_entries%rowtype;
  v_new_entry_id uuid;
begin
  if not (auth.role() = 'service_role' or public.has_admin_permission('accounting.manage')) then
    raise exception 'not authorized to post accounting entries';
  end if;
  if p_journal_entry_id is null then
    raise exception 'p_journal_entry_id is required';
  end if;

  select *
  into v_src
  from public.journal_entries je
  where je.id = p_journal_entry_id
  for update;

  if not found then
    raise exception 'journal entry not found';
  end if;

  if coalesce(v_src.source_table, '') = '' then
    raise exception 'not allowed';
  end if;

  if exists (
    select 1
    from public.journal_entries je
    where je.source_table = 'journal_entries'
      and je.source_id = p_journal_entry_id::text
      and je.source_event = 'reversal'
  ) then
    raise exception 'already reversed';
  end if;

  insert into public.journal_entries(entry_date, memo, source_table, source_id, source_event, created_by)
  values (
    now(),
    concat('REVERSAL of ', p_journal_entry_id::text, ': ', coalesce(nullif(p_reason,''), '')),
    'journal_entries',
    p_journal_entry_id::text,
    'reversal',
    auth.uid()
  )
  returning id into v_new_entry_id;

  insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
  select
    v_new_entry_id,
    jl.account_id,
    jl.credit,
    jl.debit,
    concat('Reversal: ', coalesce(jl.line_memo,''))
  from public.journal_lines jl
  where jl.journal_entry_id = p_journal_entry_id;

  perform public.check_journal_entry_balance(v_new_entry_id);

  return v_new_entry_id;
end;
$$;


ALTER FUNCTION "public"."reverse_journal_entry"("p_journal_entry_id" "uuid", "p_reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."reverse_payment_journal"("p_payment_id" "uuid", "p_reason" "text") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_reason text;
  v_existing_id uuid;
  v_new_entry_id uuid;
begin
  if not public.is_owner_or_manager() then
    raise exception 'not allowed';
  end if;
  if p_payment_id is null then
    raise exception 'p_payment_id is required';
  end if;
  v_reason := nullif(trim(coalesce(p_reason,'')), '');
  if v_reason is null then
    raise exception 'reason required';
  end if;
  perform public.set_audit_reason(v_reason);
  select id into v_existing_id
  from public.journal_entries
  where source_table = 'payments' and source_id = p_payment_id::text
  order by created_at desc
  limit 1;
  if v_existing_id is null then
    raise exception 'payment journal not found';
  end if;
  insert into public.journal_entries(entry_date, memo, source_table, source_id, source_event, created_by)
  values (now(), concat('Void payment ', p_payment_id::text), 'payments', p_payment_id::text, 'void', auth.uid())
  returning id into v_new_entry_id;
  insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
  select v_new_entry_id, account_id, credit, debit, coalesce(line_memo,'') || ' (reversal)'
  from public.journal_lines
  where journal_entry_id = v_existing_id;
  insert into public.system_audit_logs(action, module, details, performed_by, performed_at, metadata, risk_level, reason_code)
  values ('payments.void', 'payments', p_payment_id::text, auth.uid(), now(),
          jsonb_build_object('voidOfJournal', v_existing_id::text, 'newEntryId', v_new_entry_id::text),
          'HIGH', v_reason);
  return v_new_entry_id;
end;
$$;


ALTER FUNCTION "public"."reverse_payment_journal"("p_payment_id" "uuid", "p_reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."rpc_echo_text"("p_text" "text") RETURNS "text"
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select coalesce(p_text, '');
$$;


ALTER FUNCTION "public"."rpc_echo_text"("p_text" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."rpc_has_function"("p_name" "text") RETURNS boolean
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select to_regproc(p_name) is not null;
$$;


ALTER FUNCTION "public"."rpc_has_function"("p_name" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."rpc_list_public_functions"("p_like" "text") RETURNS "text"[]
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_result text[];
begin
  select array_agg(n.nspname || '.' || p.proname || '(' || pg_get_function_identity_arguments(p.oid) || ')')
  into v_result
  from pg_proc p
  join pg_namespace n on n.oid = p.pronamespace
  where n.nspname = 'public'
    and p.proname ilike p_like;
  return coalesce(v_result, array[]::text[]);
end;
$$;


ALTER FUNCTION "public"."rpc_list_public_functions"("p_like" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."rpc_reload_postgrest_schema"() RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  perform pg_notify('pgrst', 'reload schema');
  return true;
end;
$$;


ALTER FUNCTION "public"."rpc_reload_postgrest_schema"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."run_expiry_job"() RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_run_id uuid;
begin
  insert into public.job_runs(job_name, started_at, status)
  values ('process_expired_batches', now(), 'running')
  returning id into v_run_id;
  begin
    perform public.process_expired_items();
    update public.job_runs set status = 'success', finished_at = now() where id = v_run_id;
  exception when others then
    update public.job_runs set status = 'failed', finished_at = now(), error = sqlerrm where id = v_run_id;
    raise;
  end;
end;
$$;


ALTER FUNCTION "public"."run_expiry_job"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."run_fx_revaluation"("p_period_end" "date") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_gain_unreal uuid := public.get_account_id_by_code('6250');
  v_loss_unreal uuid := public.get_account_id_by_code('6251');
  v_ar uuid := public.get_account_id_by_code('1200');
  v_ap uuid := public.get_account_id_by_code('2010');
  v_base text := public.get_base_currency();
  v_base_high boolean := false;
  v_item record;
  v_rate numeric;
  v_revalued numeric;
  v_diff numeric;
  v_reval_entry_id uuid;
  v_rev_entry_id uuid;
  v_source_id uuid;
begin
  if p_period_end is null then
    raise exception 'period end required';
  end if;

  select coalesce(c.is_high_inflation, false)
  into v_base_high
  from public.currencies c
  where upper(c.code) = upper(v_base)
  limit 1;

  for v_item in
    select a.id as open_item_id,
           a.invoice_id as entity_id,
           upper(coalesce(o.currency, v_base)) as currency,
           coalesce(a.open_balance, 0) as original_base,
           coalesce(o.total, 0) as invoice_total_foreign,
           coalesce(o.base_total, coalesce(o.total,0) * coalesce(o.fx_rate,1)) as invoice_total_base
    from public.ar_open_items a
    join public.orders o on o.id = a.invoice_id
    where a.status = 'open'
  loop
    if exists(
      select 1
      from public.fx_revaluation_audit x
      where x.period_end = p_period_end
        and x.entity_type = 'AR'
        and x.entity_id = v_item.entity_id
    ) then
      continue;
    end if;

    if upper(v_item.currency) = upper(v_base) then
      if not v_base_high then
        continue;
      end if;
      v_rate := public.get_fx_rate(v_base, p_period_end, 'accounting');
      if v_rate is null then
        raise exception 'accounting rate missing for base currency % at %', v_base, p_period_end;
      end if;
      v_revalued := v_item.original_base * v_rate;
    else
      v_rate := public.get_fx_rate(v_item.currency, p_period_end, 'accounting');
      if v_rate is null then
        raise exception 'accounting fx rate missing for currency % at %', v_item.currency, p_period_end;
      end if;
      if coalesce(v_item.invoice_total_base, 0) <= 0 then
        continue;
      end if;
      v_revalued := (v_item.invoice_total_foreign * (v_item.original_base / v_item.invoice_total_base)) * v_rate;
    end if;

    v_diff := v_revalued - v_item.original_base;
    if abs(v_diff) <= 0.0000001 then
      continue;
    end if;

    v_source_id := public.uuid_from_text(concat('AR:', v_item.entity_id::text, ':', p_period_end::text, ':reval'));

    insert into public.journal_entries(entry_date, memo, source_table, source_id, source_event, created_by)
    values (
      p_period_end,
      concat('FX Revaluation AR ', v_item.entity_id::text),
      'fx_revaluation',
      v_source_id::text,
      'reval',
      auth.uid()
    )
    returning id into v_reval_entry_id;

    if v_diff > 0 then
      insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
      values
        (v_reval_entry_id, v_ar, v_diff, 0, 'Increase AR'),
        (v_reval_entry_id, v_gain_unreal, 0, v_diff, 'Unrealized FX Gain');
    else
      insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
      values
        (v_reval_entry_id, v_loss_unreal, abs(v_diff), 0, 'Unrealized FX Loss'),
        (v_reval_entry_id, v_ar, 0, abs(v_diff), 'Decrease AR');
    end if;

    select je.id into v_rev_entry_id
    from public.journal_entries je
    where je.source_table = 'journal_entries'
      and je.source_id = v_reval_entry_id::text
      and je.source_event = 'reversal'
    limit 1;

    if v_rev_entry_id is null then
      insert into public.journal_entries(entry_date, memo, source_table, source_id, source_event, created_by, document_id, branch_id, company_id)
      select
        (p_period_end + interval '1 day'),
        concat('Reversal FX Revaluation AR ', v_item.entity_id::text),
        'journal_entries',
        v_reval_entry_id::text,
        'reversal',
        auth.uid(),
        je.document_id,
        je.branch_id,
        je.company_id
      from public.journal_entries je
      where je.id = v_reval_entry_id
      returning id into v_rev_entry_id;

      insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
      select v_rev_entry_id, jl.account_id, jl.credit, jl.debit, 'Reversal'
      from public.journal_lines jl
      where jl.journal_entry_id = v_reval_entry_id;
    end if;

    insert into public.fx_revaluation_audit(period_end, entity_type, entity_id, currency, original_base, revalued_base, diff, journal_entry_id, reversal_journal_entry_id)
    values (p_period_end, 'AR', v_item.entity_id, v_item.currency, v_item.original_base, v_revalued, v_diff, v_reval_entry_id, v_rev_entry_id)
    on conflict (period_end, entity_type, entity_id) do nothing;
  end loop;

  for v_item in
    select po.id as entity_id,
           upper(coalesce(po.currency, v_base)) as currency,
           greatest(0, coalesce(po.base_total, 0) - coalesce((select sum(coalesce(p.base_amount, p.amount)) from public.payments p where p.reference_table='purchase_orders' and p.direction='out' and p.reference_id = po.id::text), 0)) as original_base,
           coalesce(po.total_amount, 0) - coalesce((select sum(coalesce(p.amount,0)) from public.payments p where p.reference_table='purchase_orders' and p.direction='out' and p.reference_id = po.id::text), 0) as remaining_foreign
    from public.purchase_orders po
    where coalesce(po.base_total, 0) > coalesce((select sum(coalesce(p.base_amount, p.amount)) from public.payments p where p.reference_table='purchase_orders' and p.direction='out' and p.reference_id = po.id::text), 0)
  loop
    if exists(
      select 1
      from public.fx_revaluation_audit x
      where x.period_end = p_period_end
        and x.entity_type = 'AP'
        and x.entity_id = v_item.entity_id
    ) then
      continue;
    end if;

    if upper(v_item.currency) = upper(v_base) then
      if not v_base_high then
        continue;
      end if;
      v_rate := public.get_fx_rate(v_base, p_period_end, 'accounting');
      if v_rate is null then
        raise exception 'accounting rate missing for base currency % at %', v_base, p_period_end;
      end if;
      v_revalued := v_item.original_base * v_rate;
    else
      v_rate := public.get_fx_rate(v_item.currency, p_period_end, 'accounting');
      if v_rate is null then
        raise exception 'accounting fx rate missing for currency % at %', v_item.currency, p_period_end;
      end if;
      v_revalued := greatest(0, v_item.remaining_foreign) * v_rate;
    end if;

    v_diff := v_revalued - v_item.original_base;
    if abs(v_diff) <= 0.0000001 then
      continue;
    end if;

    v_source_id := public.uuid_from_text(concat('AP:', v_item.entity_id::text, ':', p_period_end::text, ':reval'));

    insert into public.journal_entries(entry_date, memo, source_table, source_id, source_event, created_by)
    values (
      p_period_end,
      concat('FX Revaluation AP ', v_item.entity_id::text),
      'fx_revaluation',
      v_source_id::text,
      'reval',
      auth.uid()
    )
    returning id into v_reval_entry_id;

    if v_diff > 0 then
      insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
      values
        (v_reval_entry_id, v_loss_unreal, v_diff, 0, 'Unrealized FX Loss'),
        (v_reval_entry_id, v_ap, 0, v_diff, 'Increase AP');
    else
      insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
      values
        (v_reval_entry_id, v_ap, abs(v_diff), 0, 'Decrease AP'),
        (v_reval_entry_id, v_gain_unreal, 0, abs(v_diff), 'Unrealized FX Gain');
    end if;

    select je.id into v_rev_entry_id
    from public.journal_entries je
    where je.source_table = 'journal_entries'
      and je.source_id = v_reval_entry_id::text
      and je.source_event = 'reversal'
    limit 1;

    if v_rev_entry_id is null then
      insert into public.journal_entries(entry_date, memo, source_table, source_id, source_event, created_by, document_id, branch_id, company_id)
      select
        (p_period_end + interval '1 day'),
        concat('Reversal FX Revaluation AP ', v_item.entity_id::text),
        'journal_entries',
        v_reval_entry_id::text,
        'reversal',
        auth.uid(),
        je.document_id,
        je.branch_id,
        je.company_id
      from public.journal_entries je
      where je.id = v_reval_entry_id
      returning id into v_rev_entry_id;

      insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
      select v_rev_entry_id, jl.account_id, jl.credit, jl.debit, 'Reversal'
      from public.journal_lines jl
      where jl.journal_entry_id = v_reval_entry_id;
    end if;

    insert into public.fx_revaluation_audit(period_end, entity_type, entity_id, currency, original_base, revalued_base, diff, journal_entry_id, reversal_journal_entry_id)
    values (p_period_end, 'AP', v_item.entity_id, v_item.currency, v_item.original_base, v_revalued, v_diff, v_reval_entry_id, v_rev_entry_id)
    on conflict (period_end, entity_type, entity_id) do nothing;
  end loop;
end;
$$;


ALTER FUNCTION "public"."run_fx_revaluation"("p_period_end" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_audit_reason"("p_reason" "text") RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  PERFORM set_config('app.audit_reason', p_reason, true);
END;
$$;


ALTER FUNCTION "public"."set_audit_reason"("p_reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_base_currency"("p_code" "text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_new text;
  v_current text;
  v_has_postings boolean;
  v_updated int;
begin
  if not public.is_owner() then
    raise exception 'not allowed';
  end if;
  v_new := upper(nullif(btrim(coalesce(p_code, '')), ''));
  if v_new is null then
    raise exception 'base currency code required';
  end if;
  v_has_postings := exists(select 1 from public.journal_entries);
  begin
    v_current := public.get_base_currency();
  exception when others then
    v_current := null;
  end;
  if v_has_postings and v_current is not null and v_new <> v_current then
    raise exception 'cannot change base currency after postings exist';
  end if;

  insert into public.app_settings(id, data)
  values (
    'app',
    jsonb_build_object('id', 'app', 'settings', jsonb_build_object('baseCurrency', v_new), 'updatedAt', now()::text)
  )
  on conflict (id) do update
  set data = jsonb_set(coalesce(public.app_settings.data, '{}'::jsonb), '{settings,baseCurrency}', to_jsonb(v_new), true),
      updated_at = now();

  update public.currencies set is_base = false where is_base = true and upper(code) <> v_new;
  update public.currencies set is_base = true where upper(code) = v_new;
  get diagnostics v_updated = row_count;
  if v_updated = 0 then
    insert into public.currencies(code, name, is_base)
    values (v_new, v_new, true);
  end if;
end;
$$;


ALTER FUNCTION "public"."set_base_currency"("p_code" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_chart_account_active"("p_account_id" "uuid", "p_is_active" boolean) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_used boolean;
  v_is_control boolean;
  v_row record;
begin
  if not public.is_owner() then
    raise exception 'not allowed';
  end if;
  if p_account_id is null then
    raise exception 'account_id is required';
  end if;

  select *
  into v_row
  from public.chart_of_accounts coa
  where coa.id = p_account_id
  for update;
  if not found then
    raise exception 'account not found';
  end if;

  if coalesce(p_is_active, true) = false then
    select exists(select 1 from public.journal_lines jl where jl.account_id = p_account_id)
    into v_used;

    select exists (
      select 1
      from public.app_settings s
      cross join lateral jsonb_each_text(coalesce(s.data->'settings'->'accounting_accounts', '{}'::jsonb)) e
      where e.value = p_account_id::text
    )
    into v_is_control;

    if v_used then
      raise exception 'cannot deactivate account with journal lines';
    end if;
    if v_is_control then
      raise exception 'cannot deactivate control account';
    end if;
  end if;

  update public.chart_of_accounts
  set is_active = coalesce(p_is_active, true)
  where id = p_account_id;
end;
$$;


ALTER FUNCTION "public"."set_chart_account_active"("p_account_id" "uuid", "p_is_active" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_transfer_number"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  IF NEW.transfer_number IS NULL OR NEW.transfer_number = '' THEN
    NEW.transfer_number := public.generate_transfer_number();
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_transfer_number"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
begin
  new.updated_at = now();
  return new;
end;
$$;


ALTER FUNCTION "public"."set_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."sync_ar_on_invoice"("p_order_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_order record;
  v_is_cod boolean := false;
  v_entry_id uuid;
  v_ar_id uuid;
  v_ar_amount numeric := 0;
begin
  if p_order_id is null then
    raise exception 'p_order_id is required';
  end if;
  select *
  into v_order
  from public.orders o
  where o.id = p_order_id;
  if not found then
    raise exception 'order not found';
  end if;
  v_is_cod := public._is_cod_delivery_order(coalesce(v_order.data,'{}'::jsonb), v_order.delivery_zone_id);
  if v_is_cod then
    return;
  end if;

  select je.id
  into v_entry_id
  from public.journal_entries je
  where je.source_table = 'orders'
    and je.source_id = p_order_id::text
    and je.source_event in ('invoiced','delivered')
  order by
    case when je.source_event = 'invoiced' then 0 else 1 end asc,
    je.entry_date desc
  limit 1;
  if not found then
    return;
  end if;

  select public.get_account_id_by_code('1200') into v_ar_id;
  if v_ar_id is null then
    raise exception 'AR account not found';
  end if;
  select coalesce(sum(jl.debit), 0) - coalesce(sum(jl.credit), 0)
  into v_ar_amount
  from public.journal_lines jl
  where jl.journal_entry_id = v_entry_id
    and jl.account_id = v_ar_id;
  if v_ar_amount is null or v_ar_amount <= 0 then
    return;
  end if;

  if exists (
    select 1 from public.ar_open_items a
    where a.invoice_id = p_order_id
      and a.status = 'open'
  ) then
    update public.ar_open_items
    set original_amount = v_ar_amount,
        open_balance = greatest(open_balance, v_ar_amount)
    where invoice_id = p_order_id
      and status = 'open';
  else
    insert into public.ar_open_items(invoice_id, order_id, journal_entry_id, original_amount, open_balance, status)
    values (p_order_id, p_order_id, v_entry_id, v_ar_amount, v_ar_amount, 'open');
  end if;
end;
$$;


ALTER FUNCTION "public"."sync_ar_on_invoice"("p_order_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."sync_expense_cost_center"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
declare
  v_entry_id uuid;
begin
  -- Find the journal entry associated with this expense
  select id into v_entry_id
  from public.journal_entries
  where source_table = 'expenses' and source_id = new.id::text;

  if v_entry_id is not null then
    -- Update ALL lines (debit and credit) to match the expense cost center
    -- This ensures the cash side is also tagged, allowing for balanced reporting per cost center for expenses
    update public.journal_lines
    set cost_center_id = new.cost_center_id
    where journal_entry_id = v_entry_id;
  end if;
  
  return new;
end;
$$;


ALTER FUNCTION "public"."sync_expense_cost_center"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."sync_offline_pos_sale"("p_offline_id" "text", "p_order_id" "uuid", "p_order_data" "jsonb", "p_items" "jsonb", "p_warehouse_id" "uuid", "p_payments" "jsonb" DEFAULT '[]'::"jsonb") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_actor uuid;
  v_existing_state text;
  v_reco_status text;
  v_reco_req uuid;
  v_err text;
  v_result jsonb;
  v_payment jsonb;
  v_i int := 0;
begin
  v_actor := auth.uid();
  if not public.is_staff() then
    raise exception 'not allowed';
  end if;

  if p_offline_id is null or btrim(p_offline_id) = '' then
    raise exception 'p_offline_id is required';
  end if;
  if p_order_id is null then
    raise exception 'p_order_id is required';
  end if;
  if p_warehouse_id is null then
    raise exception 'p_warehouse_id is required';
  end if;
  if p_items is null or jsonb_typeof(p_items) <> 'array' then
    raise exception 'p_items must be a json array';
  end if;
  if p_payments is null then
    p_payments := '[]'::jsonb;
  end if;
  if jsonb_typeof(p_payments) <> 'array' then
    raise exception 'p_payments must be a json array';
  end if;

  if jsonb_typeof(coalesce(p_order_data, '{}'::jsonb)->'promotionLines') = 'array'
     and jsonb_array_length(coalesce(p_order_data, '{}'::jsonb)->'promotionLines') > 0 then
    raise exception 'POS offline promotions are not allowed';
  end if;

  if exists (
    select 1
    from jsonb_array_elements(p_items) e(value)
    where (e.value ? 'promotionId')
       or (e.value ? 'promotion_id')
       or lower(coalesce(e.value->>'lineType','')) = 'promotion'
       or lower(coalesce(e.value->>'line_type','')) = 'promotion'
  ) then
    raise exception 'POS offline promotions are not allowed';
  end if;

  perform pg_advisory_xact_lock(hashtext(p_offline_id));

  select s.state, coalesce(s.reconciliation_status, 'NONE'), s.reconciliation_approval_request_id
  into v_existing_state, v_reco_status, v_reco_req
  from public.pos_offline_sales s
  where s.offline_id = p_offline_id
  for update;

  if found and v_existing_state = 'DELIVERED' then
    return jsonb_build_object('status', 'DELIVERED', 'orderId', p_order_id::text, 'offlineId', p_offline_id);
  end if;

  if found and v_existing_state in ('CONFLICT','FAILED') and v_reco_status <> 'APPROVED' then
    return jsonb_build_object(
      'status', 'REQUIRES_RECONCILIATION',
      'orderId', p_order_id::text,
      'offlineId', p_offline_id,
      'approvalRequestId', case when v_reco_req is null then null else v_reco_req::text end
    );
  end if;

  insert into public.pos_offline_sales(offline_id, order_id, warehouse_id, state, payload, created_by, created_at, updated_at)
  values (p_offline_id, p_order_id, p_warehouse_id, 'SYNCED', coalesce(p_order_data, '{}'::jsonb), v_actor, now(), now())
  on conflict (offline_id)
  do update set
    order_id = excluded.order_id,
    warehouse_id = excluded.warehouse_id,
    state = case
      when public.pos_offline_sales.state = 'DELIVERED' then 'DELIVERED'
      else 'SYNCED'
    end,
    payload = excluded.payload,
    created_by = coalesce(public.pos_offline_sales.created_by, excluded.created_by),
    updated_at = now();

  select * from public.orders o where o.id = p_order_id for update;
  if not found then
    insert into public.orders(id, customer_auth_user_id, status, invoice_number, data, created_at, updated_at)
    values (
      p_order_id,
      v_actor,
      'pending',
      null,
      coalesce(p_order_data, '{}'::jsonb),
      now(),
      now()
    );
  else
    update public.orders
    set data = coalesce(p_order_data, data),
        updated_at = now()
    where id = p_order_id;
  end if;

  begin
    perform public.confirm_order_delivery(p_order_id, p_items, coalesce(p_order_data, '{}'::jsonb), p_warehouse_id);
  exception when others then
    v_err := sqlerrm;
    update public.pos_offline_sales
    set state = case
          when v_err ilike '%insufficient%' then 'CONFLICT'
          when v_err ilike '%expired%' then 'CONFLICT'
          when v_err ilike '%reservation%' then 'CONFLICT'
          else 'FAILED'
        end,
        last_error = v_err,
        reconciliation_status = case when v_existing_state in ('CONFLICT','FAILED') then 'NONE' else reconciliation_status end,
        reconciliation_approval_request_id = case when v_existing_state in ('CONFLICT','FAILED') then null else reconciliation_approval_request_id end,
        reconciled_by = case when v_existing_state in ('CONFLICT','FAILED') then null else reconciled_by end,
        reconciled_at = case when v_existing_state in ('CONFLICT','FAILED') then null else reconciled_at end,
        updated_at = now()
    where offline_id = p_offline_id;
    update public.orders
    set data = jsonb_set(coalesce(data, '{}'::jsonb), '{offlineState}', to_jsonb('CONFLICT'::text), true),
        updated_at = now()
    where id = p_order_id;
    return jsonb_build_object('status', 'CONFLICT', 'orderId', p_order_id::text, 'offlineId', p_offline_id, 'error', v_err);
  end;

  for v_payment in
    select value
    from jsonb_array_elements(p_payments)
  loop
    begin
      perform public.record_order_payment(
        p_order_id,
        coalesce(nullif(v_payment->>'amount','')::numeric, 0),
        coalesce(nullif(v_payment->>'method',''), ''),
        coalesce(nullif(v_payment->>'occurredAt','')::timestamptz, now()),
        'offline:' || p_offline_id || ':' || v_i::text
      );
    exception when others then
      null;
    end;
    v_i := v_i + 1;
  end loop;

  update public.pos_offline_sales
  set state = 'DELIVERED',
      last_error = null,
      updated_at = now()
  where offline_id = p_offline_id;

  update public.orders
  set data = jsonb_set(coalesce(data, '{}'::jsonb), '{offlineState}', to_jsonb('DELIVERED'::text), true),
      updated_at = now()
  where id = p_order_id;

  v_result := jsonb_build_object('status', 'DELIVERED', 'orderId', p_order_id::text, 'offlineId', p_offline_id);
  return v_result;
end;
$$;


ALTER FUNCTION "public"."sync_offline_pos_sale"("p_offline_id" "text", "p_order_id" "uuid", "p_order_data" "jsonb", "p_items" "jsonb", "p_warehouse_id" "uuid", "p_payments" "jsonb") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."sync_offline_pos_sale"("p_offline_id" "text", "p_order_id" "uuid", "p_order_data" "jsonb", "p_items" "jsonb", "p_warehouse_id" "uuid", "p_payments" "jsonb") IS 'PHASE7: Accepted drift. For POS offline sales, FEFO selection, expiry validation, stock deduction timestamp, and COGS posting are performed at SYNC time (server time), not at offline sale time.';



CREATE OR REPLACE FUNCTION "public"."sync_purchase_order_paid_amount_from_payments"("p_order_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
declare
  v_total numeric;
  v_sum numeric;
begin
  if p_order_id is null then
    return;
  end if;

  select coalesce(po.total_amount, 0)
  into v_total
  from public.purchase_orders po
  where po.id = p_order_id
  for update;

  if not found then
    return;
  end if;

  select coalesce(sum(p.amount), 0)
  into v_sum
  from public.payments p
  where p.reference_table = 'purchase_orders'
    and p.direction = 'out'
    and p.reference_id = p_order_id::text;

  update public.purchase_orders po
  set paid_amount = least(coalesce(v_sum, 0), coalesce(v_total, 0)),
      updated_at = now()
  where po.id = p_order_id;
end;
$$;


ALTER FUNCTION "public"."sync_purchase_order_paid_amount_from_payments"("p_order_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."transfer_total_cost"("p_transfer_id" "uuid") RETURNS numeric
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select coalesce(sum(quantity * unit_cost), 0)
  from public.inventory_transfer_items
  where transfer_id = p_transfer_id
$$;


ALTER FUNCTION "public"."transfer_total_cost"("p_transfer_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_accounting_period_generate_snapshot_on_close"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if tg_op = 'UPDATE'
     and old.status is distinct from new.status
     and new.status = 'closed' then
    perform public.generate_accounting_period_snapshot(new.id);
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_accounting_period_generate_snapshot_on_close"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."trg_accounting_period_generate_snapshot_on_close"() IS 'Purpose: auto-generate snapshots when accounting_periods.status transitions to closed. Source of truth: accounting_periods updates performed by close_accounting_period.';



CREATE OR REPLACE FUNCTION "public"."trg_accounting_period_snapshots_immutable"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
begin
  if public._is_migration_actor() then
    return coalesce(new, old);
  end if;
  raise exception 'accounting_period_snapshots are immutable';
end;
$$;


ALTER FUNCTION "public"."trg_accounting_period_snapshots_immutable"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."trg_accounting_period_snapshots_immutable"() IS 'Purpose: hard-seal snapshots (no update/delete). Source of truth: accounting_period_snapshots; migration actors bypass via _is_migration_actor().';



CREATE OR REPLACE FUNCTION "public"."trg_after_journal_entry_insert_flag_payment"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if new.source_table = 'payments' and new.source_event like 'in:orders:%' then
    perform public.flag_payment_allocation_status((new.source_id)::uuid);
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_after_journal_entry_insert_flag_payment"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_apply_import_shipment_landed_cost_on_delivered"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_item record;
  v_sm record;
  v_im record;
  v_avail numeric;
  v_total_current numeric;
  v_total_adjusted numeric;
  v_new_avg numeric;
begin
  if coalesce(new.destination_warehouse_id, '') is null then
    raise exception 'destination_warehouse_id is required to apply landed cost on delivered for shipment %', new.id;
  end if;
  perform public.calculate_shipment_landed_cost(new.id);
  for v_item in
    select isi.item_id::text as item_id_text,
           coalesce(isi.quantity, 0) as qty,
           coalesce(isi.landing_cost_per_unit, 0) as landed_unit
    from public.import_shipments_items isi
    where isi.shipment_id = new.id
  loop
    select sm.*
    into v_sm
    from public.stock_management sm
    where (case
            when pg_typeof(sm.item_id)::text = 'uuid' then sm.item_id::text = v_item.item_id_text
            else sm.item_id::text = v_item.item_id_text
          end)
      and sm.warehouse_id = new.destination_warehouse_id
    for update;
    if not found then
      raise exception 'Stock record not found for item % in warehouse %', v_item.item_id_text, new.destination_warehouse_id;
    end if;
    if v_sm.last_batch_id is null then
      raise exception 'Missing last_batch_id for item % in warehouse %', v_item.item_id_text, new.destination_warehouse_id;
    end if;
    select im.*
    into v_im
    from public.inventory_movements im
    where im.batch_id = v_sm.last_batch_id
      and im.movement_type = 'purchase_in'
    limit 1
    for update;
    if not found then
      raise exception 'Purchase-in movement for batch % not found (item % warehouse %)', v_sm.last_batch_id, v_item.item_id_text, new.destination_warehouse_id;
    end if;
    if coalesce(v_im.reference_table, '') <> 'purchase_receipts' then
      raise exception 'Last batch % is not linked to a receipt movement (item % warehouse %)', v_sm.last_batch_id, v_item.item_id_text, new.destination_warehouse_id;
    end if;
    if new.actual_arrival_date is not null and v_im.occurred_at < new.actual_arrival_date then
      raise exception 'Receipt movement for batch % predates shipment arrival (item % warehouse %)', v_sm.last_batch_id, v_item.item_id_text, new.destination_warehouse_id;
    end if;
    update public.inventory_movements
    set unit_cost = v_item.landed_unit,
        total_cost = (coalesce(v_im.quantity, 0) * v_item.landed_unit)
    where id = v_im.id;
    update public.batches b
    set unit_cost = v_item.landed_unit,
        updated_at = now()
    where b.item_id = v_item.item_id_text
      and b.warehouse_id = new.destination_warehouse_id
      and coalesce(b.quantity_consumed,0) < coalesce(b.quantity_received,0)
      and exists (
        select 1
        from public.inventory_movements im2
        where im2.batch_id = b.id
          and im2.movement_type = 'purchase_in'
          and im2.reference_table = 'purchase_receipts'
          and (new.actual_arrival_date is null or im2.occurred_at >= new.actual_arrival_date)
      );
    v_avail := coalesce(v_sm.available_quantity, 0);
    if v_avail > 0 then
      v_total_current := (coalesce(v_sm.avg_cost, 0) * v_avail);
      v_total_adjusted := v_total_current
                        - (coalesce(v_im.unit_cost, 0) * coalesce(v_im.quantity, 0))
                        + (v_item.landed_unit * coalesce(v_im.quantity, 0));
      v_new_avg := v_total_adjusted / v_avail;
      update public.stock_management
      set avg_cost = v_new_avg,
          updated_at = now(),
          last_updated = now()
      where id = v_sm.id;
    end if;
  end loop;
  return new;
exception
  when others then
    raise;
end;
$$;


ALTER FUNCTION "public"."trg_apply_import_shipment_landed_cost_on_delivered"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_audit_journal_entries_insert"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  insert into public.ledger_audit_log(actor_user_id, actor_role, action, table_name, record_id, context)
  values (
    auth.uid(),
    auth.role(),
    'insert',
    'journal_entries',
    new.id::text,
    jsonb_build_object('source_table', new.source_table, 'source_id', new.source_id, 'source_event', new.source_event, 'entry_date', new.entry_date)
  );
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_audit_journal_entries_insert"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_audit_journal_lines_insert"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  insert into public.ledger_audit_log(actor_user_id, actor_role, action, table_name, record_id, context)
  values (
    auth.uid(),
    auth.role(),
    'insert',
    'journal_lines',
    new.id::text,
    jsonb_build_object('journal_entry_id', new.journal_entry_id, 'account_id', new.account_id, 'debit', new.debit, 'credit', new.credit)
  );
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_audit_journal_lines_insert"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_batch_balances_expiry_immutable"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if auth.uid() is null then
    if current_user not in ('postgres','supabase_admin') then
      raise exception 'not authenticated';
    end if;
  else
    perform public._require_staff('inventory_receive');
  end if;

  if old.expiry_date is distinct from new.expiry_date then
    raise exception 'expiry_date is immutable';
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_batch_balances_expiry_immutable"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_batches_pricing_defaults"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_cost numeric;
  v_margin numeric;
begin
  v_cost := coalesce(new.cost_per_unit, 0);
  if v_cost <= 0 then
    v_cost := coalesce(new.unit_cost, 0);
  end if;

  if coalesce(new.unit_cost, 0) <= 0 and v_cost > 0 then
    new.unit_cost := v_cost;
  end if;
  new.cost_per_unit := v_cost;

  v_margin := coalesce(new.min_margin_pct, 0);
  if v_margin <= 0 then
    v_margin := public._resolve_default_min_margin_pct(new.item_id, new.warehouse_id);
  end if;
  new.min_margin_pct := greatest(0, v_margin);

  new.min_selling_price := public._money_round(new.cost_per_unit * (1 + (new.min_margin_pct / 100)));
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_batches_pricing_defaults"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_block_journal_entries_in_closed_period"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_date timestamptz;
begin
  v_date := coalesce(new.entry_date, old.entry_date);
  if v_date is not null and public.is_in_closed_period(v_date) then
    raise exception 'accounting period is closed';
  end if;
  return coalesce(new, old);
end;
$$;


ALTER FUNCTION "public"."trg_block_journal_entries_in_closed_period"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_block_journal_in_closed_period"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if public.is_in_closed_period(new.entry_date) then
    raise exception 'accounting period is closed';
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_block_journal_in_closed_period"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_block_journal_lines_in_closed_period"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_entry_id uuid;
  v_date timestamptz;
begin
  v_entry_id := coalesce(new.journal_entry_id, old.journal_entry_id);
  if v_entry_id is null then
    if tg_op = 'DELETE' then return old; end if;
    return new;
  end if;
  select je.entry_date into v_date
  from public.journal_entries je
  where je.id = v_entry_id;
  if v_date is null then
    if tg_op = 'DELETE' then return old; end if;
    return new;
  end if;
  if public.is_in_closed_period(v_date) then
    raise exception 'accounting period is closed';
  end if;
  if tg_op = 'DELETE' then return old; end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_block_journal_lines_in_closed_period"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_block_manual_entry_changes"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if tg_op = 'DELETE' then
    raise exception 'not allowed';
  end if;

  if current_setting('app.accounting_bypass', true) = '1' then
    return new;
  end if;

  if old.source_table = 'manual' and old.status <> 'draft' then
    raise exception 'not allowed';
  end if;

  return new;
end;
$$;


ALTER FUNCTION "public"."trg_block_manual_entry_changes"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_block_manual_line_changes"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_source_table text;
  v_status text;
begin
  if current_setting('app.accounting_bypass', true) = '1' then
    return coalesce(new, old);
  end if;

  select je.source_table, je.status
  into v_source_table, v_status
  from public.journal_entries je
  where je.id = coalesce(new.journal_entry_id, old.journal_entry_id);

  if v_source_table = 'manual' and v_status <> 'draft' then
    raise exception 'not allowed';
  end if;

  return coalesce(new, old);
end;
$$;


ALTER FUNCTION "public"."trg_block_manual_line_changes"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_block_sale_below_cost"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_batch record;
  v_order jsonb;
  v_line jsonb;
  v_unit_price numeric;
  v_item_id text;
  v_fx numeric;
  v_currency text;
  v_unit_price_base numeric;
begin
  if tg_op not in ('INSERT','UPDATE') then
    return new;
  end if;
  if new.movement_type <> 'sale_out' then
    return new;
  end if;
  if new.batch_id is null then
    return new;
  end if;
  if coalesce(new.reference_table,'') <> 'orders' or nullif(coalesce(new.reference_id,''),'') is null then
    return new;
  end if;

  select b.cost_per_unit, b.min_selling_price
  into v_batch
  from public.batches b
  where b.id = new.batch_id;

  select o.data, o.fx_rate, o.currency
  into v_order, v_fx, v_currency
  from public.orders o
  where o.id = (new.reference_id)::uuid;
  if v_order is null then
    return new;
  end if;

  v_item_id := new.item_id::text;
  v_unit_price := null;

  for v_line in
    select value from jsonb_array_elements(coalesce(v_order->'items','[]'::jsonb))
  loop
    if coalesce(nullif(v_line->>'id',''), nullif(v_line->>'itemId','')) = v_item_id then
      begin
        v_unit_price := nullif((v_line->>'price')::numeric, null);
      exception when others then
        v_unit_price := null;
      end;
      exit;
    end if;
  end loop;

  if v_unit_price is null then
    return new;
  end if;

  v_unit_price_base := coalesce(v_unit_price, 0) * coalesce(v_fx, 1);
  if v_unit_price_base + 1e-9 < coalesce(v_batch.min_selling_price, 0) then
    raise exception 'SELLING_BELOW_COST_NOT_ALLOWED';
  end if;

  return new;
end;
$$;


ALTER FUNCTION "public"."trg_block_sale_below_cost"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_block_sale_on_qc"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_qc text;
  v_recall boolean;
begin
  if new.movement_type in ('sale_out','transfer_out') and new.batch_id is not null then
    select qc_status into v_qc from public.batches where id = new.batch_id;
    select exists(
      select 1 from public.batch_recalls br
      where br.batch_id = new.batch_id and br.status = 'active'
    ) into v_recall;
    if v_qc is distinct from 'released' or v_recall then
      raise exception 'batch not released or recalled';
    end if;
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_block_sale_on_qc"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_block_system_journal_entry_mutation"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if coalesce(old.source_table, '') <> '' and old.source_table <> 'manual' then
    raise exception 'GL is append-only: system journal entries are immutable';
  end if;
  return coalesce(new, old);
end;
$$;


ALTER FUNCTION "public"."trg_block_system_journal_entry_mutation"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_block_system_journal_lines_mutation"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_source_table text;
begin
  select je.source_table
  into v_source_table
  from public.journal_entries je
  where je.id = old.journal_entry_id;

  if coalesce(v_source_table, '') <> '' and v_source_table <> 'manual' then
    raise exception 'GL is append-only: system journal lines cannot be changed';
  end if;

  return old;
end;
$$;


ALTER FUNCTION "public"."trg_block_system_journal_lines_mutation"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_check_journal_balance"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  perform public.check_journal_entry_balance(coalesce(new.journal_entry_id, old.journal_entry_id));
  return null;
end;
$$;


ALTER FUNCTION "public"."trg_check_journal_balance"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_check_journal_entry_balance_on_entry"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  perform public.check_journal_entry_balance(new.id);
  return null;
end;
$$;


ALTER FUNCTION "public"."trg_check_journal_entry_balance_on_entry"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_check_order_closed_period"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
declare
  v_date timestamptz;
begin
  -- Check OLD row on DELETE or UPDATE
  if (TG_OP = 'DELETE' or TG_OP = 'UPDATE') then
    if OLD.status = 'delivered' then
       -- Try to find delivery date, fallback to updated_at
       v_date := public.order_delivered_at(OLD.id);
       if v_date is null then v_date := OLD.updated_at; end if;
       
       if public.is_in_closed_period(v_date) then
         raise exception 'Cannot modify delivered order in a closed accounting period.';
       end if;
    end if;
  end if;

  -- Check NEW row on UPDATE
  -- If we are updating an order that IS delivered (or becoming delivered with a past date?)
  if (TG_OP = 'UPDATE') then
    if NEW.status = 'delivered' then
       -- If it was already delivered, we checked OLD above.
       -- If it is JUST becoming delivered, the delivery date is NOW (open period), so it's fine.
       -- Unless user manually forces a past updated_at?
       v_date := public.order_delivered_at(NEW.id);
       if v_date is null then v_date := NEW.updated_at; end if;
       
       if public.is_in_closed_period(v_date) then
         raise exception 'Cannot set order to delivered in a closed accounting period.';
       end if;
    end if;
  end if;

  return coalesce(NEW, OLD);
end;
$$;


ALTER FUNCTION "public"."trg_check_order_closed_period"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_check_po_closed_period"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
declare
  v_date date;
begin
  -- Check OLD row on DELETE or UPDATE
  if (TG_OP = 'DELETE' or TG_OP = 'UPDATE') then
    if OLD.status = 'completed' then
       v_date := OLD.purchase_date;
       -- purchase_date is DATE. is_in_closed_period takes timestamptz but casts internally or we cast here.
       if public.is_in_closed_period(v_date::timestamptz) then
         raise exception 'Cannot modify completed purchase order in a closed accounting period.';
       end if;
    end if;
  end if;

  -- Check NEW row on UPDATE
  if (TG_OP = 'UPDATE') then
    if NEW.status = 'completed' then
       v_date := NEW.purchase_date;
       if public.is_in_closed_period(v_date::timestamptz) then
         raise exception 'Cannot complete purchase order in a closed accounting period.';
       end if;
    end if;
  end if;

  -- INSERT: If inserting a completed PO directly?
  if (TG_OP = 'INSERT') then
    if NEW.status = 'completed' then
       v_date := NEW.purchase_date;
       if public.is_in_closed_period(v_date::timestamptz) then
         raise exception 'Cannot create completed purchase order in a closed accounting period.';
       end if;
    end if;
  end if;

  return coalesce(NEW, OLD);
end;
$$;


ALTER FUNCTION "public"."trg_check_po_closed_period"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_check_shift_closed_period"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
declare
  v_date timestamptz;
begin
  -- Check OLD row on DELETE or UPDATE
  if (TG_OP = 'DELETE' or TG_OP = 'UPDATE') then
    if OLD.status = 'closed' then
       v_date := OLD.closed_at;
       if public.is_in_closed_period(v_date) then
         raise exception 'Cannot modify closed shift in a closed accounting period.';
       end if;
    end if;
  end if;
  -- Check NEW row on UPDATE (if closing a shift with past date? unlikely but possible)
  if (TG_OP = 'UPDATE') then
    if NEW.status = 'closed' and NEW.closed_at is not null then
       if public.is_in_closed_period(NEW.closed_at) then
          -- If we are just closing it NOW, closed_at is NOW (open).
          -- If we force a past date, block it.
          raise exception 'Cannot close shift in a closed accounting period.';
       end if;
    end if;
  end if;

  return coalesce(NEW, OLD);
end;
$$;


ALTER FUNCTION "public"."trg_check_shift_closed_period"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_check_simple_date_closed_period"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $_$
declare
  v_col_name text := TG_ARGV[0];
  v_date_val timestamptz;
begin
  -- Check OLD row on DELETE or UPDATE
  if (TG_OP = 'DELETE' or TG_OP = 'UPDATE') then
    execute format('select ($1).%I', v_col_name) using OLD into v_date_val;
    if public.is_in_closed_period(v_date_val) then
      raise exception 'Cannot modify records in a closed accounting period.';
    end if;
  end if;

  -- Check NEW row on INSERT or UPDATE
  if (TG_OP = 'INSERT' or TG_OP = 'UPDATE') then
    execute format('select ($1).%I', v_col_name) using NEW into v_date_val;
    if public.is_in_closed_period(v_date_val) then
      raise exception 'Cannot create or modify records in a closed accounting period.';
    end if;
  end if;

  return coalesce(NEW, OLD);
end;
$_$;


ALTER FUNCTION "public"."trg_check_simple_date_closed_period"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_close_import_shipment"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_row record;
  v_im record;
  v_batch record;
  v_out record;
  v_qty_linked numeric;
  v_new_unit numeric;
  v_close_at timestamptz;
  v_total_delta_sold numeric := 0;
  v_total_delta_rem numeric := 0;
  v_delta numeric;
  v_entry_id uuid;
  v_accounts jsonb;
  v_inventory uuid;
  v_cogs uuid;
  v_clearing uuid;
  v_branch uuid;
  v_company uuid;
  v_order_id uuid;
  v_total_delta numeric;
  v_sm_avg numeric;
  v_rem_qty numeric;
begin
  if coalesce(new.status, '') <> 'closed' then
    return new;
  end if;
  if coalesce(old.status, '') = 'closed' then
    return new;
  end if;
  if new.destination_warehouse_id is null then
    raise exception 'destination_warehouse_id is required to close import shipment %', new.id;
  end if;
  if not exists (select 1 from public.purchase_receipts pr where pr.import_shipment_id = new.id) then
    raise exception 'No linked purchase receipts for import shipment %', new.id;
  end if;

  v_close_at := coalesce(new.actual_arrival_date::timestamptz, now());
  perform public.calculate_shipment_landed_cost(new.id);

  for v_row in
    select
      isi.item_id::text as item_id_text,
      coalesce(isi.quantity, 0) as expected_qty
    from public.import_shipments_items isi
    where isi.shipment_id = new.id
  loop
    select coalesce(sum(pri.quantity), 0)
    into v_qty_linked
    from public.purchase_receipt_items pri
    join public.purchase_receipts pr on pr.id = pri.receipt_id
    where pr.import_shipment_id = new.id
      and pr.warehouse_id = new.destination_warehouse_id
      and pri.item_id::text = v_row.item_id_text;

    if abs(coalesce(v_qty_linked, 0) - coalesce(v_row.expected_qty, 0)) > 1e-6 then
      raise exception 'Linked receipt quantity mismatch for item % (expected %, got %)', v_row.item_id_text, v_row.expected_qty, v_qty_linked;
    end if;
  end loop;

  for v_row in
    select
      pr.id as receipt_id,
      pri.id as receipt_item_id,
      pri.item_id::text as item_id_text,
      coalesce(pri.quantity, 0) as qty,
      coalesce(pri.transport_cost, 0) as transport_unit,
      coalesce(pri.supply_tax_cost, 0) as tax_unit,
      coalesce(isi.landing_cost_per_unit, 0) as landed_unit
    from public.purchase_receipts pr
    join public.purchase_receipt_items pri on pri.receipt_id = pr.id
    join public.import_shipments_items isi
      on isi.shipment_id = new.id and isi.item_id::text = pri.item_id::text
    where pr.import_shipment_id = new.id
      and pr.warehouse_id = new.destination_warehouse_id
  loop
    v_new_unit := coalesce(v_row.landed_unit, 0) + coalesce(v_row.transport_unit, 0) + coalesce(v_row.tax_unit, 0);

    select im.*
    into v_im
    from public.inventory_movements im
    where im.reference_table = 'purchase_receipts'
      and im.reference_id = v_row.receipt_id::text
      and im.item_id::text = v_row.item_id_text
      and im.movement_type = 'purchase_in'
    order by im.occurred_at asc
    limit 1
    for update;

    if not found then
      raise exception 'Missing purchase_in movement for receipt % item %', v_row.receipt_id, v_row.item_id_text;
    end if;

    if abs(coalesce(v_im.quantity, 0) - coalesce(v_row.qty, 0)) > 1e-6 then
      raise exception 'Receipt movement quantity mismatch for receipt % item % (receipt %, movement %)',
        v_row.receipt_id, v_row.item_id_text, v_row.qty, v_im.quantity;
    end if;

    select b.* into v_batch
    from public.batches b
    where b.id = v_im.batch_id
    for update;

    if not found then
      raise exception 'Batch not found for movement %', v_im.id;
    end if;

    for v_out in
      select im2.*
      from public.inventory_movements im2
      where im2.batch_id = v_im.batch_id
        and im2.movement_type in ('sale_out','wastage_out','expired_out')
        and im2.occurred_at < v_close_at
      for update
    loop
      v_delta := (v_new_unit - coalesce(v_out.unit_cost, 0)) * coalesce(v_out.quantity, 0);
      v_total_delta_sold := v_total_delta_sold + v_delta;

      update public.inventory_movements
      set unit_cost = v_new_unit,
          total_cost = coalesce(v_out.quantity, 0) * v_new_unit
      where id = v_out.id;

      if v_out.reference_table = 'orders' then
        begin
          v_order_id := nullif(v_out.reference_id, '')::uuid;
        exception when others then
          v_order_id := null;
        end;

        if v_order_id is not null and to_regclass('public.order_item_cogs') is not null then
          update public.order_item_cogs
          set total_cost = coalesce(total_cost, 0) + v_delta,
              unit_cost = case
                when coalesce(quantity, 0) > 0 then (coalesce(total_cost, 0) + v_delta) / quantity
                else unit_cost
              end
          where order_id = v_order_id
            and item_id::text = v_row.item_id_text;
        end if;
      end if;
    end loop;

    v_rem_qty := greatest(coalesce(v_batch.quantity_received, 0) - coalesce(v_batch.quantity_consumed, 0), 0);
    v_total_delta_rem := v_total_delta_rem + ((v_new_unit - coalesce(v_im.unit_cost, 0)) * v_rem_qty);

    update public.inventory_movements
    set unit_cost = v_new_unit,
        total_cost = coalesce(v_im.quantity, 0) * v_new_unit
    where id = v_im.id;

    update public.purchase_receipt_items
    set unit_cost = v_new_unit,
        total_cost = coalesce(v_row.qty, 0) * v_new_unit
    where id = v_row.receipt_item_id;

    update public.batches
    set unit_cost = v_new_unit,
        updated_at = now()
    where id = v_batch.id;
  end loop;

  for v_row in
    select distinct pri.item_id::text as item_id_text
    from public.purchase_receipt_items pri
    join public.purchase_receipts pr on pr.id = pri.receipt_id
    where pr.import_shipment_id = new.id
      and pr.warehouse_id = new.destination_warehouse_id
  loop
    select
      case when sum(greatest(coalesce(b.quantity_received,0) - coalesce(b.quantity_consumed,0), 0)) > 0 then
        sum(greatest(coalesce(b.quantity_received,0) - coalesce(b.quantity_consumed,0), 0) * coalesce(b.unit_cost,0))
        / sum(greatest(coalesce(b.quantity_received,0) - coalesce(b.quantity_consumed,0), 0))
      else 0 end
    into v_sm_avg
    from public.batches b
    where b.item_id::text = v_row.item_id_text
      and b.warehouse_id = new.destination_warehouse_id;

    update public.stock_management
    set avg_cost = coalesce(v_sm_avg, 0),
        updated_at = now(),
        last_updated = now()
    where item_id::text = v_row.item_id_text
      and warehouse_id = new.destination_warehouse_id;
  end loop;

  v_total_delta := coalesce(v_total_delta_sold, 0) + coalesce(v_total_delta_rem, 0);
  if abs(coalesce(v_total_delta, 0)) > 1e-6 then
    if exists (
      select 1
      from public.journal_entries je
      where je.source_table = 'import_shipments'
        and je.source_id = new.id::text
        and je.source_event = 'landed_cost_close'
    ) then
      if abs(coalesce(v_total_delta_sold, 0)) > 1e-6 and not exists (
        select 1
        from public.journal_entries je
        where je.source_table = 'import_shipments'
          and je.source_id = new.id::text
          and je.source_event = 'landed_cost_cogs_adjust'
      ) then
        select s.data->'settings'->'accounting_accounts'
        into v_accounts
        from public.app_settings s
        where s.id = 'app';

        if v_accounts is null then
          select s.data->'accounting_accounts'
          into v_accounts
          from public.app_settings s
          where s.id = 'singleton';
        end if;

        v_inventory := null;
        if v_accounts is not null and nullif(v_accounts->>'inventory', '') is not null then
          begin
            v_inventory := (v_accounts->>'inventory')::uuid;
          exception when others then
            v_inventory := public.get_account_id_by_code(v_accounts->>'inventory');
          end;
        end if;
        v_inventory := coalesce(v_inventory, public.get_account_id_by_code('1410'));

        v_cogs := null;
        if v_accounts is not null and nullif(v_accounts->>'cogs', '') is not null then
          begin
            v_cogs := (v_accounts->>'cogs')::uuid;
          exception when others then
            v_cogs := public.get_account_id_by_code(v_accounts->>'cogs');
          end;
        end if;
        v_cogs := coalesce(v_cogs, public.get_account_id_by_code('5010'));

        v_branch := coalesce(public.branch_from_warehouse(new.destination_warehouse_id), public.get_default_branch_id());
        v_company := coalesce(public.company_from_branch(v_branch), public.get_default_company_id());

        insert into public.journal_entries(
          id, source_table, source_id, source_event, entry_date, memo, created_by, branch_id, company_id
        )
        values (
          gen_random_uuid(),
          'import_shipments',
          new.id::text,
          'landed_cost_cogs_adjust',
          v_close_at,
          concat('Import landed cost COGS adjust ', coalesce(new.reference_number, new.id::text)),
          new.created_by,
          v_branch,
          v_company
        )
        returning id into v_entry_id;

        if v_total_delta_sold > 0 then
          insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
          values (v_entry_id, v_cogs, v_total_delta_sold, 0, 'Landed cost COGS adjust');
          insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
          values (v_entry_id, v_inventory, 0, v_total_delta_sold, 'Landed cost inventory reclass');
        else
          insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
          values (v_entry_id, v_cogs, 0, -v_total_delta_sold, 'Landed cost COGS adjust');
          insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
          values (v_entry_id, v_inventory, -v_total_delta_sold, 0, 'Landed cost inventory reclass');
        end if;

        perform public.check_journal_entry_balance(v_entry_id);
      end if;
      return new;
    end if;

    select s.data->'settings'->'accounting_accounts'
    into v_accounts
    from public.app_settings s
    where s.id = 'app';

    if v_accounts is null then
      select s.data->'accounting_accounts'
      into v_accounts
      from public.app_settings s
      where s.id = 'singleton';
    end if;

    v_inventory := null;
    if v_accounts is not null and nullif(v_accounts->>'inventory', '') is not null then
      begin
        v_inventory := (v_accounts->>'inventory')::uuid;
      exception when others then
        v_inventory := public.get_account_id_by_code(v_accounts->>'inventory');
      end;
    end if;
    v_inventory := coalesce(v_inventory, public.get_account_id_by_code('1410'));

    v_cogs := null;
    if v_accounts is not null and nullif(v_accounts->>'cogs', '') is not null then
      begin
        v_cogs := (v_accounts->>'cogs')::uuid;
      exception when others then
        v_cogs := public.get_account_id_by_code(v_accounts->>'cogs');
      end;
    end if;
    v_cogs := coalesce(v_cogs, public.get_account_id_by_code('5010'));

    v_clearing := null;
    if v_accounts is not null and nullif(v_accounts->>'landed_cost_clearing', '') is not null then
      begin
        v_clearing := (v_accounts->>'landed_cost_clearing')::uuid;
      exception when others then
        v_clearing := public.get_account_id_by_code(v_accounts->>'landed_cost_clearing');
      end;
    end if;
    v_clearing := coalesce(v_clearing, public.get_account_id_by_code('2060'));

    if v_inventory is null or v_clearing is null or v_cogs is null then
      raise exception 'Missing accounting accounts for import landed cost posting';
    end if;

    v_branch := coalesce(public.branch_from_warehouse(new.destination_warehouse_id), public.get_default_branch_id());
    v_company := coalesce(public.company_from_branch(v_branch), public.get_default_company_id());

    insert into public.journal_entries(
      id, source_table, source_id, source_event, entry_date, memo, created_by, branch_id, company_id
    )
    values (
      gen_random_uuid(),
      'import_shipments',
      new.id::text,
      'landed_cost_close',
      v_close_at,
      concat('Import landed cost adjustment ', coalesce(new.reference_number, new.id::text)),
      new.created_by,
      v_branch,
      v_company
    )
    returning id into v_entry_id;

    if abs(coalesce(v_total_delta_rem, 0)) > 1e-6 then
      if v_total_delta_rem > 0 then
        insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
        values (v_entry_id, v_inventory, v_total_delta_rem, 0, 'Landed cost inventory adjustment');
      else
        insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
        values (v_entry_id, v_inventory, 0, -v_total_delta_rem, 'Landed cost inventory adjustment');
      end if;
    end if;

    if abs(coalesce(v_total_delta_sold, 0)) > 1e-6 then
      if v_total_delta_sold > 0 then
        insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
        values (v_entry_id, v_cogs, v_total_delta_sold, 0, 'Landed cost COGS adjustment');
      else
        insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
        values (v_entry_id, v_cogs, 0, -v_total_delta_sold, 'Landed cost COGS adjustment');
      end if;
    end if;

    if v_total_delta > 0 then
      insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
      values (v_entry_id, v_clearing, 0, v_total_delta, 'Landed cost clearing');
    else
      insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
      values (v_entry_id, v_clearing, -v_total_delta, 0, 'Landed cost clearing');
    end if;

    perform public.check_journal_entry_balance(v_entry_id);
  end if;

  return new;
end;
$$;


ALTER FUNCTION "public"."trg_close_import_shipment"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_coa_require_ifrs_mapping"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
begin
  if public._is_migration_actor() then
    return new;
  end if;

  if new.is_active = true then
    if new.ifrs_statement is null or new.ifrs_category is null or btrim(new.ifrs_category) = '' then
      raise exception 'IFRS mapping required for active account';
    end if;
  end if;

  return new;
end;
$$;


ALTER FUNCTION "public"."trg_coa_require_ifrs_mapping"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."trg_coa_require_ifrs_mapping"() IS 'Purpose: prevent active accounts without IFRS classification. Source of truth: chart_of_accounts columns; migration actors bypass via _is_migration_actor().';



CREATE OR REPLACE FUNCTION "public"."trg_consume_order_item_reservation_on_sale_out"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_order_id uuid;
  v_source text;
begin
  if new.reference_table <> 'orders' or new.movement_type <> 'sale_out' then
    return new;
  end if;
  if new.warehouse_id is null then
    return new;
  end if;
  if new.batch_id is null then
    raise exception 'SALE_OUT_CONSUME_REQUIRES_BATCH';
  end if;

  begin
    v_order_id := nullif(new.reference_id, '')::uuid;
  exception when others then
    return new;
  end;

  select coalesce(nullif(o.data->>'orderSource',''), '') into v_source
  from public.orders o
  where o.id = v_order_id;

  if coalesce(v_source, '') = 'in_store' then
    return new;
  end if;

  update public.order_item_reservations
  set quantity = quantity - coalesce(new.quantity, 0),
      updated_at = now()
  where order_id = v_order_id
    and item_id = new.item_id::text
    and warehouse_id = new.warehouse_id
    and batch_id = new.batch_id;

  delete from public.order_item_reservations r
  where r.order_id = v_order_id
    and r.item_id = new.item_id::text
    and r.warehouse_id = new.warehouse_id
    and r.batch_id = new.batch_id
    and r.quantity <= 0;

  return new;
end;
$$;


ALTER FUNCTION "public"."trg_consume_order_item_reservation_on_sale_out"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_delivered_order_requires_journal_entry"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if public._is_migration_actor() then
    return null;
  end if;

  if tg_op = 'UPDATE' and old.status is distinct from new.status and new.status = 'delivered' then
    if not exists (
      select 1
      from public.journal_entries je
      where je.source_table = 'orders'
        and je.source_id = new.id::text
        and je.source_event = 'delivered'
    ) then
      raise exception 'delivered order requires journal entry';
    end if;
  end if;

  return null;
end;
$$;


ALTER FUNCTION "public"."trg_delivered_order_requires_journal_entry"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_enforce_approval_branch"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_branch uuid;
begin
  select branch_id into v_branch from public.approval_requests where id = new.request_id;
  if v_branch is not null then
    if exists (
      select 1 from public.admin_users au
      where au.auth_user_id = auth.uid()
        and au.branch_id is distinct from v_branch
    ) then
      raise exception 'cross-branch approval is not allowed';
    end if;
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_enforce_approval_branch"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_enforce_base_currency_singleton"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_has_postings boolean := false;
  v_other_base int := 0;
begin
  select exists(select 1 from public.journal_entries) into v_has_postings;

  if tg_op = 'INSERT' then
    if coalesce(new.is_base, false) then
      if exists(select 1 from public.currencies c where upper(c.code) = upper(new.code) and c.is_base = true) then
        return new;
      end if;

      select count(*)
      into v_other_base
      from public.currencies c
      where c.is_base = true and upper(c.code) <> upper(new.code);

      if v_other_base > 0 then
        if v_has_postings then
          raise exception 'cannot set another base currency after postings exist';
        else
          update public.currencies set is_base = false where is_base = true;
        end if;
      end if;
    end if;
    return new;
  end if;

  if tg_op = 'UPDATE' then
    if coalesce(old.is_base, false) <> coalesce(new.is_base, false) then
      if v_has_postings then
        raise exception 'cannot change base currency after postings exist';
      end if;
    end if;
    if coalesce(new.is_base, false) then
      update public.currencies set is_base = false where upper(code) <> upper(new.code) and is_base = true;
    end if;
    return new;
  end if;

  return new;
end;
$$;


ALTER FUNCTION "public"."trg_enforce_base_currency_singleton"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_enforce_discount_approval"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if new.discount_requires_approval and new.discount_approval_status <> 'approved' then
    if new.status in ('delivered','out_for_delivery','completed') then
      raise exception 'order discount requires approval';
    end if;
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_enforce_discount_approval"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_enforce_po_approval"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_required boolean;
begin
  if tg_op = 'UPDATE' and new.status = 'completed' then
    v_required := public.approval_required('po', new.total_amount);
    new.requires_approval := v_required;
    if v_required and new.approval_status <> 'approved' then
      raise exception 'purchase order requires approval';
    end if;
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_enforce_po_approval"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_enforce_receipt_approval"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_total numeric;
  v_required boolean;
begin
  select coalesce(total_amount, 0) into v_total
  from public.purchase_orders
  where id = new.purchase_order_id;

  v_required := public.approval_required('receipt', v_total);
  new.requires_approval := v_required;

  if v_required and new.approval_status <> 'approved' then
    raise exception 'purchase receipt requires approval';
  end if;

  return new;
end;
$$;


ALTER FUNCTION "public"."trg_enforce_receipt_approval"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_enforce_transfer_approval"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_total numeric;
  v_required boolean;
begin
  v_total := public.transfer_total_cost(new.id);
  v_required := public.approval_required('transfer', v_total);
  new.requires_approval := v_required;

  if (new.state in ('IN_TRANSIT','RECEIVED')) and v_required and new.approval_status <> 'approved' then
    raise exception 'transfer requires approval';
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_enforce_transfer_approval"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_enforce_writeoff_approval"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_required boolean;
begin
  if new.movement_type in ('wastage_out','adjust_out') then
    v_required := public.approval_required('writeoff', new.total_cost);
    new.requires_approval := v_required;
    if v_required and new.approval_status <> 'approved' then
      raise exception 'writeoff requires approval';
    end if;
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_enforce_writeoff_approval"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_forbid_delete_batch"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
begin
  raise exception 'BATCH_DELETE_FORBIDDEN';
end;
$$;


ALTER FUNCTION "public"."trg_forbid_delete_batch"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_forbid_disable_batch"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
declare
  v_remaining numeric;
  v_has_reservation boolean;
  v_has_movement boolean;
begin
  if tg_op <> 'UPDATE' then
    return new;
  end if;
  if old.id is distinct from new.id then
    return new;
  end if;
  if coalesce(new.status, 'active') = 'inactive' and coalesce(old.status, 'active') <> 'inactive' then
    select greatest(coalesce(b.quantity_received,0) - coalesce(b.quantity_consumed,0) - coalesce(b.quantity_transferred,0), 0)
    into v_remaining
    from public.batches b
    where b.id = new.id;

    select exists(select 1 from public.inventory_movements im where im.batch_id = new.id)
    into v_has_movement;

    -- If reservations table has batch_id column, check directly; otherwise fallback to stock_management JSON
    begin
      select exists(select 1 from public.order_item_reservations r where r.batch_id = new.id)
      into v_has_reservation;
    exception when undefined_column then
      select exists(
        select 1
        from public.stock_management sm
        where jsonb_typeof(sm.data->'reservedBatches') = 'object'
          and (sm.data->'reservedBatches') ? new.id::text
      )
      into v_has_reservation;
    end;

    if coalesce(v_remaining,0) > 0 or v_has_reservation or v_has_movement then
      raise exception 'BATCH_LOCKED_HAS_STOCK_OR_RESERVATIONS_OR_MOVEMENTS';
    end if;
    new.locked_at := now();
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_forbid_disable_batch"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_forbid_update_delete"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  RAISE EXCEPTION 'immutable_record';
END;
$$;


ALTER FUNCTION "public"."trg_forbid_update_delete"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_freeze_ledger_tables"() RETURNS "event_trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_cmd record;
  v_allow text;
begin
  v_allow := current_setting('app.allow_ledger_ddl', true);
  if v_allow = '1' then
    return;
  end if;
  for v_cmd in select * from pg_event_trigger_ddl_commands()
  loop
    if v_cmd.object_type in ('table','trigger','function')
      and coalesce(v_cmd.schema_name,'') = 'public'
      and (
        v_cmd.object_identity like '%public.accounting_documents%'
        or v_cmd.object_identity like '%public.journal_entries%'
        or v_cmd.object_identity like '%public.journal_lines%'
      )
    then
      raise exception 'ledger ddl frozen';
    end if;
  end loop;
end;
$$;


ALTER FUNCTION "public"."trg_freeze_ledger_tables"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_freeze_posting_engine"() RETURNS "event_trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_cmd record;
  v_upgrade text;
begin
  v_upgrade := current_setting('app.posting_engine_upgrade', true);
  if v_upgrade = '1' then
    return;
  end if;

  for v_cmd in
    select *
    from pg_event_trigger_ddl_commands()
  loop
    if v_cmd.object_type = 'function'
      and coalesce(v_cmd.schema_name,'') = 'public'
      and (
        v_cmd.object_identity like 'function public.post_inventory_movement(%'
        or v_cmd.object_identity like 'function public.post_order_delivery(%'
        or v_cmd.object_identity like 'function public.post_payment(%'
      )
    then
      raise exception 'posting engine frozen: overriding post_* functions is forbidden';
    end if;
  end loop;
end;
$$;


ALTER FUNCTION "public"."trg_freeze_posting_engine"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_immutable_block"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  raise exception 'immutable record';
end;
$$;


ALTER FUNCTION "public"."trg_immutable_block"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_inventory_movement_requires_journal_entry"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if public._is_migration_actor() then
    return null;
  end if;

  if new.movement_type in ('transfer_out','transfer_in') then
    return null;
  end if;

  if not exists (
    select 1
    from public.journal_entries je
    where je.source_table = 'inventory_movements'
      and je.source_id = new.id::text
  ) then
    raise exception 'inventory movement requires journal entry';
  end if;

  return null;
end;
$$;


ALTER FUNCTION "public"."trg_inventory_movement_requires_journal_entry"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_inventory_movements_ensure_batch_exists"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
declare
  v_wh uuid;
  v_expiry date;
  v_prod date;
begin
  if new.movement_type <> 'purchase_in' then
    return new;
  end if;
  if new.batch_id is null then
    return new;
  end if;
  if exists (select 1 from public.batches b where b.id = new.batch_id) then
    return new;
  end if;

  if auth.uid() is null then
    raise exception 'not authenticated';
  end if;
  if not public.has_admin_permission('stock.manage') then
    raise exception 'not allowed';
  end if;

  v_wh := coalesce(new.warehouse_id, public._resolve_default_warehouse_id());
  v_expiry := case
    when (new.data->>'expiryDate') ~ '^[0-9]{4}-[0-9]{2}-[0-9]{2}$' then (new.data->>'expiryDate')::date
    else null
  end;
  v_prod := case
    when (new.data->>'harvestDate') ~ '^[0-9]{4}-[0-9]{2}-[0-9]{2}$' then (new.data->>'harvestDate')::date
    else null
  end;

  insert into public.batches(
    id,
    item_id,
    receipt_item_id,
    receipt_id,
    warehouse_id,
    batch_code,
    production_date,
    expiry_date,
    quantity_received,
    quantity_consumed,
    unit_cost,
    status,
    locked_at,
    data
  )
  values (
    new.batch_id,
    new.item_id::text,
    null,
    null,
    v_wh,
    null,
    v_prod,
    v_expiry,
    coalesce(new.quantity, 0),
    0,
    coalesce(new.unit_cost, 0),
    'active',
    null,
    jsonb_build_object('autoCreated', true, 'sourceTable', coalesce(new.reference_table, ''), 'sourceId', coalesce(new.reference_id, ''))
  )
  on conflict (id) do nothing;

  return new;
end;
$_$;


ALTER FUNCTION "public"."trg_inventory_movements_ensure_batch_exists"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_inventory_movements_purchase_in_defaults"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
declare
  v_wh uuid;
begin
  if new.movement_type = 'purchase_in' then
    if new.batch_id is null then
      raise exception 'purchase_in requires batch_id';
    end if;
    if new.warehouse_id is null then
      v_wh := public._resolve_default_warehouse_id();
      if v_wh is null then
        raise exception 'warehouse_id is required';
      end if;
      new.warehouse_id := v_wh;
    end if;
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_inventory_movements_purchase_in_defaults"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_inventory_movements_purchase_in_immutable"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
begin
  if old.movement_type = 'purchase_in' or new.movement_type = 'purchase_in' then
    if old.movement_type is distinct from new.movement_type then
      raise exception 'purchase_in is immutable';
    end if;
    if old.quantity is distinct from new.quantity then
      raise exception 'purchase_in is immutable';
    end if;
    if old.batch_id is distinct from new.batch_id then
      raise exception 'purchase_in is immutable';
    end if;
    if old.warehouse_id is distinct from new.warehouse_id then
      raise exception 'purchase_in is immutable';
    end if;
    if (old.data->>'expiryDate') is distinct from (new.data->>'expiryDate') then
      raise exception 'purchase_in is immutable';
    end if;
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_inventory_movements_purchase_in_immutable"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_inventory_movements_purchase_in_no_delete"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
begin
  if old.movement_type = 'purchase_in' then
    raise exception 'purchase_in is insert-only';
  end if;
  return old;
end;
$$;


ALTER FUNCTION "public"."trg_inventory_movements_purchase_in_no_delete"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_inventory_movements_purchase_in_sync_batch_balances"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
declare
  v_wh uuid;
  v_expiry date;
begin
  if auth.uid() is null then
    if current_user not in ('postgres','supabase_admin') then
      raise exception 'not authenticated';
    end if;
  else
    perform public._require_stock_manager('batch_balances_sync');
  end if;

  if new.movement_type <> 'purchase_in' then
    return new;
  end if;
  if new.batch_id is null then
    raise exception 'purchase_in requires batch_id';
  end if;
  v_wh := new.warehouse_id;
  if v_wh is null then
    raise exception 'warehouse_id is required';
  end if;
  v_expiry := case
    when (new.data->>'expiryDate') ~ '^[0-9]{4}-[0-9]{2}-[0-9]{2}$' then (new.data->>'expiryDate')::date
    else null
  end;

  insert into public.batch_balances(item_id, batch_id, warehouse_id, quantity, expiry_date)
  values (new.item_id::text, new.batch_id, v_wh, new.quantity, v_expiry)
  on conflict (item_id, batch_id, warehouse_id)
  do update set
    quantity = public.batch_balances.quantity + excluded.quantity,
    updated_at = now();

  return new;
end;
$_$;


ALTER FUNCTION "public"."trg_inventory_movements_purchase_in_sync_batch_balances"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_journal_entries_hard_rules"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
declare
  v_max_date timestamptz;
  v_date timestamptz;
  v_is_finance_admin boolean := false;
begin
  if public._is_migration_actor() then
    return new;
  end if;

  v_is_finance_admin := (auth.role() = 'service_role') or public.has_admin_permission('accounting.manage');

  if new.source_table is null or btrim(new.source_table) = '' then
    raise exception 'source_type is required';
  end if;

  if new.source_table = 'manual' then
    if not v_is_finance_admin then
      raise exception 'not allowed';
    end if;
  else
    if new.source_id is null or btrim(new.source_id) = '' then
      raise exception 'source_id is required';
    end if;
    if new.source_id !~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$' then
      raise exception 'source_id must be uuid';
    end if;
  end if;

  v_date := coalesce(new.entry_date, now());

  if public.is_in_closed_period(v_date) then
    raise exception 'Accounting period is closed';
  end if;

  if not v_is_finance_admin then
    if (v_date::date) < (current_date - 1) or (v_date::date) > (current_date + 1) then
      raise exception 'Back/forward dating not allowed';
    end if;
  end if;

  select max(je.entry_date) into v_max_date
  from public.journal_entries je;

  if v_max_date is not null and v_date < v_max_date and not v_is_finance_admin then
    raise exception 'Back-dating not allowed';
  end if;

  new.entry_date := v_date;
  return new;
end;
$_$;


ALTER FUNCTION "public"."trg_journal_entries_hard_rules"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_journal_entries_immutable"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
begin
  if public._is_migration_actor() then
    return coalesce(new, old);
  end if;
  raise exception 'Journal entries are immutable';
end;
$$;


ALTER FUNCTION "public"."trg_journal_entries_immutable"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_journal_entries_set_document"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_branch uuid;
  v_company uuid;
  v_doc_type text;
begin
  if new.branch_id is null then
    if new.source_table = 'inventory_movements' then
      select branch_id, company_id into v_branch, v_company
      from public.inventory_movements where id = new.source_id::uuid;
      v_doc_type := 'movement';
    elsif new.source_table = 'purchase_receipts' then
      select branch_id, company_id into v_branch, v_company
      from public.purchase_receipts where id = new.source_id::uuid;
      v_doc_type := 'grn';
    elsif new.source_table = 'supplier_invoices' then
      select branch_id, company_id into v_branch, v_company
      from public.supplier_invoices where id = new.source_id::uuid;
      v_doc_type := 'invoice';
    elsif new.source_table = 'payments' then
      select branch_id, company_id into v_branch, v_company
      from public.payments where id = new.source_id::uuid;
      v_doc_type := 'payment';
    elsif new.source_table = 'orders' then
      select branch_id, company_id into v_branch, v_company
      from public.orders where id = new.source_id::uuid;
      v_doc_type := 'invoice';
    elsif new.source_table = 'manual' then
      v_branch := public.get_default_branch_id();
      v_company := public.get_default_company_id();
      v_doc_type := 'manual';
    else
      v_branch := public.get_default_branch_id();
      v_company := public.get_default_company_id();
      v_doc_type := 'movement';
    end if;
    new.branch_id := coalesce(new.branch_id, v_branch);
    new.company_id := coalesce(new.company_id, v_company);
  end if;
  if new.document_id is null then
    new.document_id := public.create_accounting_document(
      coalesce(v_doc_type, 'movement'),
      coalesce(new.source_table, 'manual'),
      coalesce(new.source_id, new.id::text),
      new.branch_id,
      new.company_id,
      new.memo
    );
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_journal_entries_set_document"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_journal_lines_immutable"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
begin
  if public._is_migration_actor() then
    return coalesce(new, old);
  end if;
  raise exception 'Journal entries are immutable';
end;
$$;


ALTER FUNCTION "public"."trg_journal_lines_immutable"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_journal_lines_sync_ar_open_item"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_entry record;
begin
  select je.source_table, je.source_id, je.source_event
  into v_entry
  from public.journal_entries je
  where je.id = coalesce(new.journal_entry_id, old.journal_entry_id)
  limit 1;

  if v_entry.source_table = 'orders' and v_entry.source_event in ('invoiced','delivered') then
    begin
      perform public.sync_ar_on_invoice((v_entry.source_id)::uuid);
    exception when others then
      null;
    end;
  end if;

  return null;
end;
$$;


ALTER FUNCTION "public"."trg_journal_lines_sync_ar_open_item"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_ledger_audit_log_immutable"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
begin
  if public._is_migration_actor() then
    return coalesce(new, old);
  end if;
  raise exception 'ledger_audit_log is immutable';
end;
$$;


ALTER FUNCTION "public"."trg_ledger_audit_log_immutable"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_lock_approval_requests"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if tg_op = 'DELETE' then
    raise exception 'approval request is immutable';
  end if;

  if new.id <> old.id
     or new.target_table <> old.target_table
     or new.target_id <> old.target_id
     or new.request_type <> old.request_type
     or new.requested_by <> old.requested_by
     or new.payload_hash <> old.payload_hash
     or new.created_at <> old.created_at then
    raise exception 'approval request is immutable';
  end if;

  if old.status <> 'pending' then
    raise exception 'approval request already finalized';
  end if;

  if new.status = 'pending' then
    if new.approved_by is not null or new.approved_at is not null or new.rejected_by is not null or new.rejected_at is not null then
      raise exception 'approval request is immutable';
    end if;
  end if;

  if new.status = 'approved' then
    if new.approved_by is null or new.approved_at is null then
      raise exception 'approval request missing approved_by/approved_at';
    end if;
    if new.rejected_by is not null or new.rejected_at is not null then
      raise exception 'approval request is immutable';
    end if;
  end if;

  if new.status = 'rejected' then
    if new.rejected_by is null or new.rejected_at is null then
      raise exception 'approval request missing rejected_by/rejected_at';
    end if;
    if new.approved_by is not null or new.approved_at is not null then
      raise exception 'approval request is immutable';
    end if;
  end if;

  return new;
end;
$$;


ALTER FUNCTION "public"."trg_lock_approval_requests"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_lock_approval_steps"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if tg_op = 'DELETE' then
    raise exception 'approval step is immutable';
  end if;

  if new.id <> old.id
     or new.request_id <> old.request_id
     or new.step_no <> old.step_no
     or new.approver_role <> old.approver_role then
    raise exception 'approval step is immutable';
  end if;

  if old.status <> 'pending' then
    raise exception 'approval step already finalized';
  end if;

  if new.status = 'pending' then
    if new.action_by is not null or new.action_at is not null then
      raise exception 'approval step is immutable';
    end if;
  end if;

  if new.status in ('approved', 'rejected') then
    if new.action_by is null or new.action_at is null then
      raise exception 'approval step missing action_by/action_at';
    end if;
  end if;

  return new;
end;
$$;


ALTER FUNCTION "public"."trg_lock_approval_steps"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_menu_items_lock_after_first_movement"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if auth.uid() is null then
    if current_user not in ('postgres','supabase_admin') then
      raise exception 'not authenticated';
    end if;
  else
    perform public._require_staff('menu_items_update');
  end if;

  if (new.base_unit is distinct from old.base_unit)
     or (new.is_food is distinct from old.is_food)
     or (new.expiry_required is distinct from old.expiry_required)
  then
    if exists (
      select 1
      from public.inventory_movements im
      where im.item_id::text = new.id
      limit 1
    ) then
      raise exception 'cannot modify base_unit/is_food/expiry_required after first stock movement';
    end if;
  end if;

  return new;
end;
$$;


ALTER FUNCTION "public"."trg_menu_items_lock_after_first_movement"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_menu_items_sot_sync_validate"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
declare
  v_name jsonb;
  v_barcode text;
  v_unit text;
  v_price_text text;
  v_price numeric;
  v_sellable boolean;
  v_bool_text text;
begin
  if auth.uid() is null then
    if current_user not in ('postgres','supabase_admin') then
      raise exception 'not authenticated';
    end if;
  else
    perform public._require_staff('menu_items_update');
  end if;

  if new.data is null then
    new.data := '{}'::jsonb;
  end if;
  if jsonb_typeof(new.data) <> 'object' then
    raise exception 'menu_items.data must be an object';
  end if;

  v_name := case when jsonb_typeof(new.data->'name') = 'object' then new.data->'name' else null end;
  v_barcode := nullif(btrim(coalesce(new.data->>'barcode','')), '');
  v_unit := nullif(btrim(coalesce(new.data->>'unitType', new.data->>'baseUnit', new.data->>'base_unit','')), '');
  v_price_text := nullif(btrim(coalesce(new.data->>'price','')), '');
  if v_price_text is not null and v_price_text ~ '^-?[0-9]+(\.[0-9]+)?$' then
    v_price := v_price_text::numeric;
  else
    v_price := null;
  end if;
  v_bool_text := lower(nullif(btrim(coalesce(new.data->>'sellable','')), ''));
  if v_bool_text in ('true','t','1','yes','y') then
    v_sellable := true;
  elsif v_bool_text in ('false','f','0','no','n') then
    v_sellable := false;
  else
    v_sellable := null;
  end if;

  if tg_op = 'INSERT' then
    if new.name is null and v_name is not null then
      new.name := v_name;
    end if;
    if new.barcode is null and v_barcode is not null then
      new.barcode := v_barcode;
    end if;
    if new.base_unit is null then
      if v_unit is not null then
        new.base_unit := v_unit;
      elsif nullif(btrim(coalesce(new.unit_type,'')), '') is not null then
        new.base_unit := new.unit_type;
      end if;
    end if;
    if new.price is null and v_price is not null then
      new.price := v_price;
    end if;
    if new.sellable is null and v_sellable is not null then
      new.sellable := v_sellable;
    end if;
    if new.is_food is null then
      new.is_food := (lower(coalesce(new.category, new.data->>'category','')) = 'food');
    end if;
    if new.expiry_required is null then
      if lower(coalesce(new.data->>'expiry_required', new.data->>'expiryRequired','')) in ('true','t','1','yes','y') then
        new.expiry_required := true;
      else
        new.expiry_required := (lower(coalesce(new.category, new.data->>'category','')) = 'food');
      end if;
    end if;
  end if;

  new.barcode := nullif(btrim(coalesce(new.barcode,'')), '');

  if new.name is null or jsonb_typeof(new.name) <> 'object' or btrim(coalesce(new.name->>'ar','')) = '' then
    raise exception 'name.ar is required';
  end if;
  if new.price is null or new.price < 0 then
    raise exception 'price must be >= 0';
  end if;
  if new.base_unit is null or btrim(new.base_unit) = '' then
    raise exception 'base_unit is required';
  end if;
  if new.sellable is null then
    new.sellable := true;
  end if;
  if new.is_food is null then
    new.is_food := false;
  end if;
  if new.expiry_required is null then
    new.expiry_required := false;
  end if;
  if new.expiry_required = true and new.is_food <> true then
    raise exception 'expiry_required=true requires is_food=true';
  end if;

  new.unit_type := new.base_unit;

  return new;
end;
$_$;


ALTER FUNCTION "public"."trg_menu_items_sot_sync_validate"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_orders_promotion_guards"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_has_promos boolean;
  v_coupon text;
  v_points numeric;
begin
  v_has_promos := (jsonb_typeof(coalesce(new.data->'promotionLines', '[]'::jsonb)) = 'array')
                  and (jsonb_array_length(coalesce(new.data->'promotionLines', '[]'::jsonb)) > 0);
  if not v_has_promos then
    return new;
  end if;

  v_coupon := nullif(btrim(coalesce(new.data->>'appliedCouponCode', new.data->>'couponCode', '')), '');
  if v_coupon is not null then
    raise exception 'promotion_coupon_conflict';
  end if;

  v_points := coalesce(nullif((new.data->>'pointsRedeemedValue')::numeric, null), 0);
  if v_points > 0 then
    raise exception 'promotion_points_conflict';
  end if;

  return new;
end;
$$;


ALTER FUNCTION "public"."trg_orders_promotion_guards"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_orders_require_sale_out_on_delivered"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_wh uuid;
begin
  if new.status = 'delivered' and (old.status is distinct from new.status) then
    v_wh := coalesce(
      nullif(trim(coalesce(new.data->>'warehouseId', '')), '')::uuid,
      (select w.id from public.warehouses w where w.code = 'MAIN' limit 1)
    );
    if not exists (
      select 1
      from public.inventory_movements im
      where im.reference_table = 'orders'
        and im.reference_id = new.id::text
        and im.movement_type = 'sale_out'
        and (v_wh is null or im.warehouse_id = v_wh)
    ) then
      raise exception 'cannot mark delivered without stock movements for this order/warehouse';
    end if;
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_orders_require_sale_out_on_delivered"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_payment_requires_journal_entry"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if public._is_migration_actor() then
    return null;
  end if;

  if new.reference_table in ('orders','purchase_orders','expenses') then
    if not exists (
      select 1
      from public.journal_entries je
      where je.source_table = 'payments'
        and je.source_id = new.id::text
    ) then
      raise exception 'payment requires journal entry';
    end if;
  end if;

  return null;
end;
$$;


ALTER FUNCTION "public"."trg_payment_requires_journal_entry"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_post_import_expense"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if tg_op = 'UPDATE' then
    if new.amount is not distinct from old.amount
      and new.exchange_rate is not distinct from old.exchange_rate
      and new.paid_at is not distinct from old.paid_at
      and new.payment_method is not distinct from old.payment_method
      and new.invoice_number is not distinct from old.invoice_number then
      return new;
    end if;
  end if;

  perform public.post_import_expense(new.id);
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_post_import_expense"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_post_inventory_movement"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  perform public.post_inventory_movement(new.id);
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_post_inventory_movement"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_post_order_delivery"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if new.status = 'delivered' and (old.status is distinct from new.status) then
    perform public.post_order_delivery(new.id);
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_post_order_delivery"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_post_payment"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  perform public.post_payment(new.id);
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_post_payment"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_product_audit_log"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if auth.uid() is null then
    if current_user not in ('postgres','supabase_admin') then
      raise exception 'not authenticated';
    end if;
  else
    perform public._require_staff('audit_write');
  end if;

  if old.name is distinct from new.name then
    insert into public.product_audit_log(item_id, field, old_value, new_value, updated_at)
    values (new.id, 'name', old.name::text, new.name::text, now());
  end if;

  if old.barcode is distinct from new.barcode then
    insert into public.product_audit_log(item_id, field, old_value, new_value, updated_at)
    values (new.id, 'barcode', old.barcode, new.barcode, now());
  end if;

  if old.price is distinct from new.price then
    insert into public.product_audit_log(item_id, field, old_value, new_value, updated_at)
    values (new.id, 'price', old.price::text, new.price::text, now());
  end if;

  if old.sellable is distinct from new.sellable then
    insert into public.product_audit_log(item_id, field, old_value, new_value, updated_at)
    values (new.id, 'sellable', old.sellable::text, new.sellable::text, now());
  end if;

  if old.status is distinct from new.status then
    insert into public.product_audit_log(item_id, field, old_value, new_value, updated_at)
    values (new.id, 'status', old.status, new.status, now());
  end if;

  return new;
end;
$$;


ALTER FUNCTION "public"."trg_product_audit_log"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_promotion_items_lock_after_usage"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_promo_id uuid;
begin
  v_promo_id := coalesce(old.promotion_id, new.promotion_id);
  if v_promo_id is not null and exists (select 1 from public.promotion_usage u where u.promotion_id = v_promo_id limit 1) then
    raise exception 'promotion_items_are_immutable_after_usage';
  end if;
  if tg_op = 'DELETE' then
    return old;
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_promotion_items_lock_after_usage"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_promotion_usage_enforce_valid"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_promo record;
  v_used_count int;
begin
  select *
  into v_promo
  from public.promotions p
  where p.id = new.promotion_id;
  if not found then
    raise exception 'promotion_not_found';
  end if;

  if not v_promo.is_active then
    raise exception 'promotion_inactive';
  end if;
  if now() < v_promo.start_at or now() > v_promo.end_at then
    raise exception 'promotion_outside_time_window';
  end if;
  if v_promo.approval_status <> 'approved' then
    raise exception 'promotion_requires_approval';
  end if;

  if v_promo.max_uses is not null then
    select count(*)
    into v_used_count
    from public.promotion_usage u
    where u.promotion_id = new.promotion_id;
    if v_used_count >= v_promo.max_uses then
      raise exception 'promotion_usage_limit_reached';
    end if;
  end if;

  return new;
end;
$$;


ALTER FUNCTION "public"."trg_promotion_usage_enforce_valid"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_promotions_enforce_active_window_and_approval"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if tg_op in ('INSERT','UPDATE') then
    if new.is_active then
      if new.approval_status <> 'approved' then
        raise exception 'promotion_requires_approval';
      end if;
      if now() > new.end_at then
        raise exception 'promotion_already_ended';
      end if;
    end if;
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_promotions_enforce_active_window_and_approval"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_promotions_lock_after_usage"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_used boolean;
begin
  if tg_op = 'DELETE' then
    if exists (select 1 from public.promotion_usage u where u.promotion_id = old.id limit 1) then
      raise exception 'promotion_is_immutable_after_usage';
    end if;
    return old;
  end if;

  v_used := exists (select 1 from public.promotion_usage u where u.promotion_id = old.id limit 1);
  if not v_used then
    return new;
  end if;

  if new.id <> old.id
     or new.name <> old.name
     or new.start_at <> old.start_at
     or new.end_at <> old.end_at
     or new.discount_mode <> old.discount_mode
     or coalesce(new.fixed_total, -1) <> coalesce(old.fixed_total, -1)
     or coalesce(new.percent_off, -1) <> coalesce(old.percent_off, -1)
     or coalesce(new.display_original_total, -1) <> coalesce(old.display_original_total, -1)
     or coalesce(new.max_uses, -1) <> coalesce(old.max_uses, -1)
     or new.stack_policy <> old.stack_policy
     or new.exclusive_with_coupon <> old.exclusive_with_coupon
  then
    raise exception 'promotion_is_immutable_after_usage';
  end if;

  if old.is_active = false and new.is_active = true then
    raise exception 'promotion_cannot_be_reactivated_after_usage';
  end if;

  return new;
end;
$$;


ALTER FUNCTION "public"."trg_promotions_lock_after_usage"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_purchase_items_set_costs"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_po record;
begin
  select * into v_po from public.purchase_orders po where po.id = coalesce(new.purchase_order_id, old.purchase_order_id);
  if v_po.id is null then
    raise exception 'purchase order not found';
  end if;
  if v_po.currency is null then
    raise exception 'purchase order currency missing';
  end if;
  if v_po.fx_rate is null then
    raise exception 'purchase order fx rate missing';
  end if;
  if tg_op in ('INSERT','UPDATE') then
    if new.unit_cost_foreign is null then
      new.unit_cost_foreign := coalesce(new.unit_cost, 0);
    end if;
    new.unit_cost_base := coalesce(new.unit_cost_foreign, 0) * coalesce(v_po.fx_rate, 0);
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_purchase_items_set_costs"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_purchase_orders_fx_lock"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_base text;
begin
  v_base := public.get_base_currency();
  if tg_op = 'INSERT' then
    if new.currency is null then
      raise exception 'currency required';
    end if;
    if new.fx_rate is null then
      raise exception 'fx rate required';
    end if;
    new.base_total := coalesce(new.total_amount, 0) * coalesce(new.fx_rate, 0);
    return new;
  end if;
  if tg_op = 'UPDATE' then
    if (new.status = 'completed') and (old.status is distinct from 'completed') then
      if new.currency is null or new.fx_rate is null then
        raise exception 'currency/fx_rate required to complete PO';
      end if;
      new.fx_locked := true;
    end if;
    if coalesce(old.fx_locked, false) = true then
      if new.currency is distinct from old.currency or new.fx_rate is distinct from old.fx_rate then
        raise exception 'fx locked: currency/fx_rate cannot change after completion';
      end if;
    end if;
    new.base_total := coalesce(new.total_amount, 0) * coalesce(new.fx_rate, 0);
    return new;
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_purchase_orders_fx_lock"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_recall_batch_update"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if new.status = 'active' then
    update public.batches set qc_status = 'recalled' where id = new.batch_id;
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_recall_batch_update"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_sale_out_require_batch"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
declare
  v_category text;
  v_expiry date;
begin
  if tg_op not in ('INSERT','UPDATE') then
    return new;
  end if;
  if new.movement_type <> 'sale_out' then
    return new;
  end if;
  select mi.category into v_category from public.menu_items mi where mi.id::text = new.item_id;
  if coalesce(v_category,'') = 'food' then
    if new.batch_id is null then
      raise exception 'FOOD_SALE_REQUIRES_BATCH';
    end if;
    select b.expiry_date into v_expiry from public.batches b where b.id = new.batch_id;
    if v_expiry is not null and v_expiry < new.occurred_at::date then
      raise exception 'BATCH_EXPIRED';
    end if;
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_sale_out_require_batch"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_set_approval_request_scope"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_branch uuid;
  v_company uuid;
begin
  if new.branch_id is null then
    if new.target_table = 'purchase_orders' then
      select branch_id, company_id into v_branch, v_company
      from public.purchase_orders where id = new.target_id::uuid;
    elsif new.target_table = 'purchase_receipts' then
      select branch_id, company_id into v_branch, v_company
      from public.purchase_receipts where id = new.target_id::uuid;
    elsif new.target_table = 'inventory_transfers' then
      select branch_id, company_id into v_branch, v_company
      from public.inventory_transfers where id = new.target_id::uuid;
    elsif new.target_table = 'inventory_movements' then
      select branch_id, company_id into v_branch, v_company
      from public.inventory_movements where id = new.target_id::uuid;
    elsif new.target_table = 'orders' then
      select branch_id, company_id into v_branch, v_company
      from public.orders where id = new.target_id::uuid;
    end if;
    new.branch_id := coalesce(v_branch, public.get_default_branch_id());
    new.company_id := coalesce(v_company, public.company_from_branch(new.branch_id), public.get_default_company_id());
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_set_approval_request_scope"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_set_journal_entry_status"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if new.source_table = 'manual' then
    new.status := 'draft';
  else
    new.status := coalesce(nullif(new.status, ''), 'posted');
    if new.status = 'draft' then
      new.status := 'posted';
    end if;
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_set_journal_entry_status"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_set_movement_branch_scope"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  new.branch_id := coalesce(new.branch_id, public.branch_from_warehouse(new.warehouse_id), public.get_default_branch_id());
  new.company_id := coalesce(new.company_id, public.company_from_branch(new.branch_id), public.get_default_company_id());
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_set_movement_branch_scope"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_set_order_branch_scope"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
begin
  if new.warehouse_id is null then
    if nullif(new.data->>'warehouseId','') is not null and (new.data->>'warehouseId') ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$' then
      new.warehouse_id := (new.data->>'warehouseId')::uuid;
    else
      select id into new.warehouse_id
      from public.warehouses
      where is_active = true
      order by created_at asc
      limit 1;
    end if;
  end if;
  new.branch_id := coalesce(new.branch_id, public.branch_from_warehouse(new.warehouse_id), public.get_default_branch_id());
  new.company_id := coalesce(new.company_id, public.company_from_branch(new.branch_id), public.get_default_company_id());
  return new;
end;
$_$;


ALTER FUNCTION "public"."trg_set_order_branch_scope"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_set_order_fx"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_base text;
  v_currency text;
  v_rate numeric;
  v_total numeric;
  v_data_fx numeric;
begin
  v_base := public.get_base_currency();

  if tg_op = 'UPDATE' and coalesce(old.fx_locked, true) then
    new.currency := old.currency;
    new.fx_rate := old.fx_rate;
  else
    v_currency := upper(nullif(btrim(coalesce(new.currency, new.data->>'currency', '')), ''));
    if v_currency is null then
      v_currency := v_base;
    end if;
    new.currency := v_currency;

    if new.fx_rate is null then
      v_data_fx := null;
      begin
        v_data_fx := nullif((new.data->>'fxRate')::numeric, null);
      exception when others then
        v_data_fx := null;
      end;
      if v_data_fx is not null and v_data_fx > 0 then
        new.fx_rate := v_data_fx;
      else
        v_rate := public.get_fx_rate(new.currency, current_date, 'operational');
        if v_rate is null then
          raise exception 'fx rate missing for currency %', new.currency;
        end if;
        new.fx_rate := v_rate;
      end if;
    end if;
  end if;

  v_total := 0;
  begin
    v_total := nullif((new.data->>'total')::numeric, null);
  exception when others then
    v_total := 0;
  end;
  new.base_total := coalesce(v_total, 0) * coalesce(new.fx_rate, 1);

  return new;
end;
$$;


ALTER FUNCTION "public"."trg_set_order_fx"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_set_payment_branch_scope"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_branch uuid;
  v_company uuid;
begin
  if new.branch_id is null then
    if new.reference_table = 'orders' then
      select branch_id, company_id into v_branch, v_company
      from public.orders where id = nullif(new.reference_id, '')::uuid;
    elsif new.reference_table = 'purchase_orders' then
      select branch_id, company_id into v_branch, v_company
      from public.purchase_orders where id = nullif(new.reference_id, '')::uuid;
    elsif new.reference_table = 'expenses' then
      v_branch := public.get_default_branch_id();
      v_company := public.get_default_company_id();
    end if;
    new.branch_id := coalesce(new.branch_id, v_branch, public.get_default_branch_id());
    new.company_id := coalesce(new.company_id, v_company, public.company_from_branch(new.branch_id), public.get_default_company_id());
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_set_payment_branch_scope"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_set_payment_fx"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_rate numeric;
begin
  if new.currency is null then
    raise exception 'currency required';
  end if;
  if new.fx_rate is null then
    v_rate := public.get_fx_rate(new.currency, current_date, 'operational');
    if v_rate is null then
      raise exception 'fx rate missing for currency %', new.currency;
    end if;
    new.fx_rate := v_rate;
  end if;
  if tg_op = 'UPDATE' and coalesce(old.fx_locked,true) then
    if new.currency is distinct from old.currency or new.fx_rate is distinct from old.fx_rate then
      raise exception 'fx locked: cannot change currency/fx_rate';
    end if;
  end if;
  new.base_amount := coalesce(new.amount, 0) * coalesce(new.fx_rate, 1);
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_set_payment_fx"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_set_po_branch_scope"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_branch uuid;
  v_company uuid;
begin
  if new.warehouse_id is null then
    select id into new.warehouse_id
    from public.warehouses
    where is_active = true
    order by created_at asc
    limit 1;
  end if;
  v_branch := public.branch_from_warehouse(new.warehouse_id);
  if v_branch is null then
    v_branch := public.get_default_branch_id();
  end if;
  new.branch_id := coalesce(new.branch_id, v_branch);
  v_company := public.company_from_branch(new.branch_id);
  new.company_id := coalesce(new.company_id, v_company, public.get_default_company_id());
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_set_po_branch_scope"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_set_qty_base_inventory_movements"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_base uuid;
begin
  select base_uom_id into v_base from public.item_uom where item_id = new.item_id limit 1;
  if v_base is null then
    raise exception 'base uom missing for item';
  end if;
  if new.uom_id is null then
    new.uom_id := v_base;
  end if;
  new.qty_base := public.convert_qty(new.quantity, new.uom_id, v_base);
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_set_qty_base_inventory_movements"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_set_qty_base_purchase_items"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_base uuid;
begin
  select base_uom_id into v_base from public.item_uom where item_id = new.item_id limit 1;
  if v_base is null then
    raise exception 'base uom missing for item';
  end if;
  if new.uom_id is null then
    new.uom_id := v_base;
  end if;
  new.qty_base := public.convert_qty(new.quantity, new.uom_id, v_base);
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_set_qty_base_purchase_items"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_set_qty_base_receipt_items"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_base uuid;
begin
  select base_uom_id into v_base from public.item_uom where item_id = new.item_id limit 1;
  if v_base is null then
    raise exception 'base uom missing for item';
  end if;
  if new.uom_id is null then
    new.uom_id := v_base;
  end if;
  new.qty_base := public.convert_qty(new.quantity, new.uom_id, v_base);
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_set_qty_base_receipt_items"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_set_qty_base_transfer_items"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_base uuid;
begin
  select base_uom_id into v_base from public.item_uom where item_id = new.item_id limit 1;
  if v_base is null then
    raise exception 'base uom missing for item';
  end if;
  if new.uom_id is null then
    new.uom_id := v_base;
  end if;
  new.qty_base := public.convert_qty(new.quantity, new.uom_id, v_base);
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_set_qty_base_transfer_items"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_set_receipt_branch_scope"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_po record;
begin
  select * into v_po from public.purchase_orders where id = new.purchase_order_id;
  if new.warehouse_id is null then
    new.warehouse_id := v_po.warehouse_id;
  end if;
  new.branch_id := coalesce(new.branch_id, v_po.branch_id, public.branch_from_warehouse(new.warehouse_id));
  new.company_id := coalesce(new.company_id, v_po.company_id, public.company_from_branch(new.branch_id));
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_set_receipt_branch_scope"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_set_supplier_invoice_branch_scope"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if new.branch_id is null then
    new.branch_id := public.get_default_branch_id();
  end if;
  new.company_id := coalesce(new.company_id, public.company_from_branch(new.branch_id), public.get_default_company_id());
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_set_supplier_invoice_branch_scope"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_set_transfer_branch_scope"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  new.branch_id := coalesce(new.branch_id, public.branch_from_warehouse(new.from_warehouse_id), public.get_default_branch_id());
  new.company_id := coalesce(new.company_id, public.company_from_branch(new.branch_id), public.get_default_company_id());
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_set_transfer_branch_scope"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_sync_batch_balances_from_batches"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_wh uuid;
  v_qty numeric;
begin
  if tg_op = 'DELETE' then
    delete from public.batch_balances bb
    where bb.item_id::text = old.item_id::text
      and bb.batch_id = old.id
      and bb.warehouse_id = old.warehouse_id;
    return old;
  end if;

  v_wh := coalesce(new.warehouse_id, public._resolve_default_admin_warehouse_id());
  if v_wh is null then
    raise exception 'warehouse_id is required';
  end if;

  if tg_op = 'UPDATE' then
    if old.warehouse_id is distinct from v_wh or old.item_id::text is distinct from new.item_id::text then
      delete from public.batch_balances bb
      where bb.item_id::text = old.item_id::text
        and bb.batch_id = old.id
        and bb.warehouse_id = old.warehouse_id;
    end if;
  end if;

  v_qty := greatest(
    coalesce(new.quantity_received, 0)
    - coalesce(new.quantity_consumed, 0)
    - coalesce(new.quantity_transferred, 0),
    0
  );

  insert into public.batch_balances(item_id, batch_id, warehouse_id, quantity, expiry_date, created_at, updated_at)
  values (new.item_id::text, new.id, v_wh, v_qty, new.expiry_date, now(), now())
  on conflict (item_id, batch_id, warehouse_id)
  do update set
    quantity = excluded.quantity,
    expiry_date = case
      when public.batch_balances.expiry_date is null then excluded.expiry_date
      else public.batch_balances.expiry_date
    end,
    updated_at = now();

  return new;
end;
$$;


ALTER FUNCTION "public"."trg_sync_batch_balances_from_batches"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_sync_discount_approval_to_order"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if tg_op <> 'UPDATE' then
    return new;
  end if;

  if new.request_type = 'discount'
     and new.target_table = 'orders'
     and new.status is distinct from old.status then
    update public.orders
    set
      discount_requires_approval = true,
      discount_approval_status = new.status,
      discount_approval_request_id = new.id
    where id::text = new.target_id;
  end if;

  return new;
end;
$$;


ALTER FUNCTION "public"."trg_sync_discount_approval_to_order"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_sync_discount_approval_to_promotion"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if tg_op <> 'UPDATE' then
    return new;
  end if;

  if new.request_type = 'discount'
     and new.target_table = 'promotions'
     and new.status is distinct from old.status then
    update public.promotions
    set
      requires_approval = true,
      approval_status = new.status,
      approval_request_id = new.id,
      updated_at = now()
    where id::text = new.target_id;
  end if;

  return new;
end;
$$;


ALTER FUNCTION "public"."trg_sync_discount_approval_to_promotion"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_sync_offline_reconciliation_approval"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if tg_op <> 'UPDATE' then
    return new;
  end if;

  if new.request_type = 'offline_reconciliation'
     and new.target_table = 'pos_offline_sales'
     and new.status is distinct from old.status then
    update public.pos_offline_sales
    set reconciliation_status = upper(new.status),
        reconciliation_approval_request_id = new.id,
        reconciled_by = case
          when new.status = 'approved' then new.approved_by
          when new.status = 'rejected' then new.rejected_by
          else null
        end,
        reconciled_at = case
          when new.status = 'approved' then new.approved_at
          when new.status = 'rejected' then new.rejected_at
          else null
        end,
        updated_at = now()
    where offline_id = new.target_id;
  end if;

  return new;
end;
$$;


ALTER FUNCTION "public"."trg_sync_offline_reconciliation_approval"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_sync_order_line_items"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  perform public.rebuild_order_line_items(new.id);
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_sync_order_line_items"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_sync_po_approval_to_purchase_order"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_po_id uuid;
  v_all_received boolean := true;
  v_item record;
  v_total numeric;
begin
  if tg_op <> 'UPDATE' then
    return new;
  end if;
  if new.target_table <> 'purchase_orders'
     or new.request_type <> 'po'
     or new.status is not distinct from old.status then
    return new;
  end if;
  begin
    v_po_id := nullif(trim(coalesce(new.target_id, '')), '')::uuid;
  exception when others then
    return new;
  end;
  select coalesce(total_amount, 0)
  into v_total
  from public.purchase_orders
  where id = v_po_id;
  if not found then
    return new;
  end if;
  update public.purchase_orders
  set approval_status = new.status,
      approval_request_id = new.id,
      requires_approval = public.approval_required('po', v_total),
      updated_at = now()
  where id = v_po_id;
  if new.status <> 'approved' then
    return new;
  end if;
  for v_item in
    select coalesce(pi.quantity, 0) as ordered, coalesce(pi.received_quantity, 0) as received
    from public.purchase_items pi
    where pi.purchase_order_id = v_po_id
  loop
    if (coalesce(v_item.received, 0) + 1e-9) < coalesce(v_item.ordered, 0) then
      v_all_received := false;
      exit;
    end if;
  end loop;
  if v_all_received then
    update public.purchase_orders
    set status = 'completed',
        approval_status = 'approved',
        approval_request_id = new.id,
        requires_approval = public.approval_required('po', v_total),
        updated_at = now()
    where id = v_po_id
      and status = 'partial';
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_sync_po_approval_to_purchase_order"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_sync_purchase_order_paid_amount"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
declare
  v_old_id uuid;
  v_new_id uuid;
  v_status text;
begin
  if tg_op = 'DELETE' then
    begin
      v_old_id := nullif(trim(coalesce(old.reference_id, '')), '')::uuid;
    exception when others then
      return old;
    end;
    if old.reference_table = 'purchase_orders' and old.direction = 'out' then
      perform public.sync_purchase_order_paid_amount_from_payments(v_old_id);
    end if;
    return old;
  end if;

  if new.reference_table is distinct from 'purchase_orders' or new.direction is distinct from 'out' then
    return new;
  end if;

  begin
    v_new_id := nullif(trim(coalesce(new.reference_id, '')), '')::uuid;
  exception when others then
    raise exception 'invalid purchase order reference_id';
  end;

  select po.status
  into v_status
  from public.purchase_orders po
  where po.id = v_new_id;

  if not found then
    raise exception 'purchase order not found';
  end if;

  if v_status = 'cancelled' then
    raise exception 'cannot record payment for cancelled purchase order';
  end if;

  if tg_op = 'UPDATE' and (new.reference_id is distinct from old.reference_id) then
    begin
      v_old_id := nullif(trim(coalesce(old.reference_id, '')), '')::uuid;
    exception when others then
      v_old_id := null;
    end;
    if v_old_id is not null then
      perform public.sync_purchase_order_paid_amount_from_payments(v_old_id);
    end if;
  end if;

  perform public.sync_purchase_order_paid_amount_from_payments(v_new_id);
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_sync_purchase_order_paid_amount"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_trace_batch_sales"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if new.movement_type = 'sale_out' and new.batch_id is not null and new.reference_table = 'orders' then
    insert into public.batch_sales_trace(batch_id, order_id, quantity, sold_at)
    values (new.batch_id, new.reference_id::uuid, new.quantity, new.occurred_at);
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_trace_batch_sales"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_validate_base_currency_config"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  perform public.get_base_currency();
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_validate_base_currency_config"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_validate_reserved_batches"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_key text;
  v_qc text;
  v_recall boolean;
begin
  if jsonb_typeof(new.data->'reservedBatches') = 'object' then
    for v_key in select key from jsonb_each(new.data->'reservedBatches')
    loop
      select qc_status into v_qc from public.batches where id = v_key::uuid;
      select exists(
        select 1 from public.batch_recalls br
        where br.batch_id = v_key::uuid and br.status = 'active'
      ) into v_recall;
      if v_qc is distinct from 'released' or v_recall then
        raise exception 'reserved batch not released or recalled';
      end if;
    end loop;
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."trg_validate_reserved_batches"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trial_balance"("p_start" "date", "p_end" "date", "p_cost_center_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("account_code" "text", "account_name" "text", "account_type" "text", "normal_balance" "text", "debit" numeric, "credit" numeric, "balance" numeric)
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  if not public.can_view_accounting_reports() then
    raise exception 'not allowed';
  end if;

  return query
  select
    coa.code as account_code,
    coa.name as account_name,
    coa.account_type,
    coa.normal_balance,
    coalesce(sum(jl.debit), 0) as debit,
    coalesce(sum(jl.credit), 0) as credit,
    coalesce(sum(jl.debit - jl.credit), 0) as balance
  from public.chart_of_accounts coa
  left join public.journal_lines jl on jl.account_id = coa.id
  left join public.journal_entries je
    on je.id = jl.journal_entry_id
   and (p_start is null or je.entry_date::date >= p_start)
   and (p_end is null or je.entry_date::date <= p_end)
  where (p_cost_center_id is null or jl.cost_center_id = p_cost_center_id)
  group by coa.code, coa.name, coa.account_type, coa.normal_balance
  order by coa.code;
end;
$$;


ALTER FUNCTION "public"."trial_balance"("p_start" "date", "p_end" "date", "p_cost_center_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trial_balance_by_range"("p_start" "date", "p_end" "date") RETURNS TABLE("account_code" "text", "account_name" "text", "account_type" "text", "normal_balance" "text", "opening_balance" numeric, "total_debits" numeric, "total_credits" numeric, "closing_balance" numeric)
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  with opening as (
    select
      coa.id as account_id,
      coalesce(sum(
        case
          when coa.normal_balance = 'debit' then jl.debit - jl.credit
          else jl.credit - jl.debit
        end
      ), 0) as opening_balance
    from public.chart_of_accounts coa
    left join public.journal_lines jl on jl.account_id = coa.id
    left join public.journal_entries je
      on je.id = jl.journal_entry_id
     and (p_start is null or je.entry_date::date < p_start)
    where coa.is_active = true
    group by coa.id
  ),
  period as (
    select
      coa.id as account_id,
      coalesce(sum(jl.debit), 0) as total_debits,
      coalesce(sum(jl.credit), 0) as total_credits,
      coalesce(sum(
        case
          when coa.normal_balance = 'debit' then jl.debit - jl.credit
          else jl.credit - jl.debit
        end
      ), 0) as period_delta
    from public.chart_of_accounts coa
    left join public.journal_lines jl on jl.account_id = coa.id
    left join public.journal_entries je
      on je.id = jl.journal_entry_id
     and (p_start is null or je.entry_date::date >= p_start)
     and (p_end is null or je.entry_date::date <= p_end)
    where coa.is_active = true
    group by coa.id
  )
  select
    coa.code as account_code,
    coa.name as account_name,
    coa.account_type,
    coa.normal_balance,
    o.opening_balance,
    p.total_debits,
    p.total_credits,
    (o.opening_balance + p.period_delta) as closing_balance
  from public.chart_of_accounts coa
  join opening o on o.account_id = coa.id
  join period p on p.account_id = coa.id
  where public.has_admin_permission('accounting.view')
  order by coa.code;
$$;


ALTER FUNCTION "public"."trial_balance_by_range"("p_start" "date", "p_end" "date") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."trial_balance_by_range"("p_start" "date", "p_end" "date") IS 'Purpose: period trial balance with opening/period/closing and control totals computed externally. Source of truth: journal_entries/journal_lines signed by normal_balance.';



CREATE OR REPLACE FUNCTION "public"."trigger_encrypt_customer_data"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'extensions', 'public'
    AS $$
BEGIN
  -- Encrypt Phone if changed
  IF NEW.phone_number IS NOT NULL AND (OLD.phone_number IS NULL OR NEW.phone_number <> OLD.phone_number) THEN
    NEW.phone_encrypted := public.encrypt_text(NEW.phone_number);
  END IF;

  -- Encrypt Address if changed (assuming address is in data->>'address')
  IF (NEW.data->>'address') IS NOT NULL AND (OLD.data IS NULL OR (NEW.data->>'address') <> (OLD.data->>'address')) THEN
    NEW.address_encrypted := public.encrypt_text(NEW.data->>'address');
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trigger_encrypt_customer_data"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_chart_account"("p_account_id" "uuid", "p_code" "text" DEFAULT NULL::"text", "p_name" "text" DEFAULT NULL::"text", "p_account_type" "text" DEFAULT NULL::"text", "p_normal_balance" "text" DEFAULT NULL::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
declare
  v_existing record;
  v_used boolean;
  v_next_code text;
  v_next_name text;
  v_next_type text;
  v_next_balance text;
begin
  if not public.is_owner() then
    raise exception 'not allowed';
  end if;
  if p_account_id is null then
    raise exception 'account_id is required';
  end if;

  select *
  into v_existing
  from public.chart_of_accounts coa
  where coa.id = p_account_id
  for update;
  if not found then
    raise exception 'account not found';
  end if;

  select exists(select 1 from public.journal_lines jl where jl.account_id = p_account_id)
  into v_used;

  v_next_code := btrim(coalesce(p_code, v_existing.code));
  v_next_name := btrim(coalesce(p_name, v_existing.name));
  v_next_type := coalesce(p_account_type, v_existing.account_type);
  v_next_balance := coalesce(p_normal_balance, v_existing.normal_balance);

  if v_next_code = '' then
    raise exception 'code is required';
  end if;
  if v_next_code !~ '^[0-9]{3,10}$' then
    raise exception 'invalid code';
  end if;
  if v_next_name = '' then
    raise exception 'name is required';
  end if;
  if coalesce(v_next_type,'') not in ('asset','liability','equity','income','expense') then
    raise exception 'invalid account_type';
  end if;
  if coalesce(v_next_balance,'') not in ('debit','credit') then
    raise exception 'invalid normal_balance';
  end if;

  if v_used then
    if v_next_code is distinct from v_existing.code
      or v_next_type is distinct from v_existing.account_type
      or v_next_balance is distinct from v_existing.normal_balance
    then
      raise exception 'account is used and cannot change code/type/balance';
    end if;
  end if;

  update public.chart_of_accounts
  set code = v_next_code,
      name = v_next_name,
      account_type = v_next_type,
      normal_balance = v_next_balance
  where id = p_account_id;
end;
$_$;


ALTER FUNCTION "public"."update_chart_account"("p_account_id" "uuid", "p_code" "text", "p_name" "text", "p_account_type" "text", "p_normal_balance" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_updated_at_column"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
begin
  new.updated_at = now();
  return new;
end;
$$;


ALTER FUNCTION "public"."update_updated_at_column"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."upsert_promotion"("p_promotion" "jsonb", "p_items" "jsonb", "p_activate" boolean DEFAULT false) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_actor uuid;
  v_promo_id uuid;
  v_name text;
  v_start_at timestamptz;
  v_end_at timestamptz;
  v_is_active boolean;
  v_discount_mode text;
  v_fixed_total numeric;
  v_percent_off numeric;
  v_display_original_total numeric;
  v_max_uses int;
  v_exclusive_with_coupon boolean;
  v_item jsonb;
  v_item_id text;
  v_qty numeric;
  v_sort int;
  v_snapshot jsonb;
  v_promo_expense numeric;
  v_requires_approval boolean;
  v_req_id uuid;
begin
  v_actor := auth.uid();
  if v_actor is null then
    raise exception 'not authenticated';
  end if;
  if not public.is_admin() then
    raise exception 'not allowed';
  end if;

  if p_promotion is null then
    raise exception 'p_promotion is required';
  end if;
  if p_items is null or jsonb_typeof(p_items) <> 'array' then
    raise exception 'p_items must be a json array';
  end if;

  v_promo_id := public._uuid_or_null(p_promotion->>'id');
  v_name := nullif(btrim(coalesce(p_promotion->>'name','')), '');
  v_start_at := nullif(p_promotion->>'startAt','')::timestamptz;
  v_end_at := nullif(p_promotion->>'endAt','')::timestamptz;
  v_discount_mode := nullif(btrim(coalesce(p_promotion->>'discountMode','')), '');
  v_fixed_total := nullif((p_promotion->>'fixedTotal')::numeric, null);
  v_percent_off := nullif((p_promotion->>'percentOff')::numeric, null);
  v_display_original_total := nullif((p_promotion->>'displayOriginalTotal')::numeric, null);
  v_max_uses := nullif((p_promotion->>'maxUses')::int, null);
  v_exclusive_with_coupon := coalesce((p_promotion->>'exclusiveWithCoupon')::boolean, true);

  if v_name is null then
    raise exception 'name is required';
  end if;
  if v_start_at is null or v_end_at is null then
    raise exception 'startAt/endAt are required';
  end if;
  if v_start_at >= v_end_at then
    raise exception 'startAt must be before endAt';
  end if;
  if v_discount_mode not in ('fixed_total','percent_off') then
    raise exception 'invalid discountMode';
  end if;
  if v_discount_mode = 'fixed_total' then
    if v_fixed_total is null or v_fixed_total <= 0 then
      raise exception 'fixedTotal must be positive';
    end if;
    v_percent_off := null;
  else
    if v_percent_off is null or v_percent_off <= 0 or v_percent_off > 100 then
      raise exception 'percentOff must be between 0 and 100';
    end if;
    v_fixed_total := null;
  end if;

  if v_promo_id is null then
    insert into public.promotions(
      name, start_at, end_at, is_active,
      discount_mode, fixed_total, percent_off,
      display_original_total, max_uses, exclusive_with_coupon,
      created_by, data
    )
    values (
      v_name, v_start_at, v_end_at, false,
      v_discount_mode, v_fixed_total, v_percent_off,
      v_display_original_total, v_max_uses, v_exclusive_with_coupon,
      v_actor, coalesce(p_promotion->'data', '{}'::jsonb)
    )
    returning id into v_promo_id;
  else
    update public.promotions
    set
      name = v_name,
      start_at = v_start_at,
      end_at = v_end_at,
      discount_mode = v_discount_mode,
      fixed_total = v_fixed_total,
      percent_off = v_percent_off,
      display_original_total = v_display_original_total,
      max_uses = v_max_uses,
      exclusive_with_coupon = v_exclusive_with_coupon,
      data = coalesce(p_promotion->'data', data),
      updated_at = now()
    where id = v_promo_id;

    if not found then
      raise exception 'promotion_not_found';
    end if;
  end if;

  delete from public.promotion_items where promotion_id = v_promo_id;

  for v_item in select value from jsonb_array_elements(p_items)
  loop
    v_item_id := nullif(btrim(coalesce(v_item->>'itemId','')), '');
    v_qty := coalesce(nullif((v_item->>'quantity')::numeric, null), 0);
    v_sort := coalesce(nullif((v_item->>'sortOrder')::int, null), 0);
    if v_item_id is null then
      raise exception 'itemId is required';
    end if;
    if v_qty <= 0 then
      raise exception 'quantity must be positive';
    end if;

    insert into public.promotion_items(promotion_id, item_id, quantity, sort_order)
    values (v_promo_id, v_item_id, v_qty, v_sort);
  end loop;

  if coalesce(p_activate, false) then
    v_snapshot := public._compute_promotion_snapshot(v_promo_id, null, null, 1, null, false);
    v_promo_expense := coalesce(nullif((v_snapshot->>'promotionExpense')::numeric, null), 0);
    v_requires_approval := public.approval_required('discount', v_promo_expense);

    if v_requires_approval then
      v_req_id := public.create_approval_request(
        'promotions',
        v_promo_id::text,
        'discount',
        v_promo_expense,
        jsonb_build_object(
          'promotionId', v_promo_id::text,
          'name', v_name,
          'promotionExpense', v_promo_expense,
          'snapshot', v_snapshot
        )
      );

      update public.promotions
      set
        requires_approval = true,
        approval_status = 'pending',
        approval_request_id = v_req_id,
        is_active = false,
        updated_at = now()
      where id = v_promo_id;
    else
      update public.promotions
      set
        requires_approval = false,
        approval_status = 'approved',
        approval_request_id = null,
        is_active = true,
        updated_at = now()
      where id = v_promo_id;
    end if;
  end if;

  return jsonb_build_object(
    'promotionId', v_promo_id::text,
    'approvalRequestId', case when v_req_id is null then null else v_req_id::text end,
    'approvalStatus', (select p.approval_status from public.promotions p where p.id = v_promo_id),
    'isActive', (select p.is_active from public.promotions p where p.id = v_promo_id)
  );
end;
$$;


ALTER FUNCTION "public"."upsert_promotion"("p_promotion" "jsonb", "p_items" "jsonb", "p_activate" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."uuid_from_text"("p_text" "text") RETURNS "uuid"
    LANGUAGE "sql" IMMUTABLE
    AS $$
  select (
    substr(md5(coalesce(p_text,'')), 1, 8) || '-' ||
    substr(md5(coalesce(p_text,'')), 9, 4) || '-' ||
    substr(md5(coalesce(p_text,'')), 13, 4) || '-' ||
    substr(md5(coalesce(p_text,'')), 17, 4) || '-' ||
    substr(md5(coalesce(p_text,'')), 21, 12)
  )::uuid;
$$;


ALTER FUNCTION "public"."uuid_from_text"("p_text" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."void_delivered_order"("p_order_id" "uuid", "p_reason" "text" DEFAULT NULL::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_order record;
  v_delivered_entry_id uuid;
  v_void_entry_id uuid;
  v_line record;
  v_ar_id uuid;
  v_ar_amount numeric := 0;
  v_sale record;
  v_ret_batch_id uuid;
  v_source_batch record;
  v_movement_id uuid;
  v_wh uuid;
  v_data jsonb;
begin
  perform public._require_staff('void_delivered_order');
  if not (auth.role() = 'service_role' or public.has_admin_permission('accounting.void')) then
    raise exception 'not authorized';
  end if;
  if p_order_id is null then
    raise exception 'p_order_id is required';
  end if;

  select * into v_order from public.orders o where o.id = p_order_id for update;
  if not found then
    raise exception 'order not found';
  end if;
  if coalesce(v_order.status,'') <> 'delivered' then
    raise exception 'only delivered orders can be voided';
  end if;

  if coalesce(v_order.data->>'voidedAt','') <> '' then
    raise exception 'order already voided';
  end if;

  select je.id
  into v_delivered_entry_id
  from public.journal_entries je
  where je.source_table = 'orders'
    and je.source_id = p_order_id::text
    and je.source_event = 'delivered'
  limit 1;
  if not found then
    raise exception 'delivered journal entry not found';
  end if;

  select je.id
  into v_void_entry_id
  from public.journal_entries je
  where je.source_table = 'order_voids'
    and je.source_id = p_order_id::text
    and je.source_event = 'voided'
  limit 1;

  if v_void_entry_id is null then
    insert into public.journal_entries(entry_date, memo, source_table, source_id, source_event, created_by, status)
    values (
      now(),
      concat('Void delivered order ', p_order_id::text),
      'order_voids',
      p_order_id::text,
      'voided',
      auth.uid(),
      'posted'
    )
    returning id into v_void_entry_id;
  else
    update public.journal_entries
    set entry_date = now(),
        memo = concat('Void delivered order ', p_order_id::text)
    where id = v_void_entry_id;
  end if;

  delete from public.journal_lines jl where jl.journal_entry_id = v_void_entry_id;

  for v_line in
    select account_id, debit, credit, line_memo
    from public.journal_lines
    where journal_entry_id = v_delivered_entry_id
  loop
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo)
    values (
      v_void_entry_id,
      v_line.account_id,
      coalesce(v_line.credit,0),
      coalesce(v_line.debit,0),
      coalesce(v_line.line_memo,'')
    );
  end loop;

  v_ar_id := public.get_account_id_by_code('1200');
  if v_ar_id is not null then
    select coalesce(sum(jl.debit), 0) - coalesce(sum(jl.credit), 0)
    into v_ar_amount
    from public.journal_lines jl
    where jl.journal_entry_id = v_delivered_entry_id
      and jl.account_id = v_ar_id;
    v_ar_amount := greatest(0, coalesce(v_ar_amount, 0));
  end if;

  for v_sale in
    select im.id, im.item_id, im.quantity, im.unit_cost, im.batch_id, im.warehouse_id, im.occurred_at
    from public.inventory_movements im
    where im.reference_table = 'orders'
      and im.reference_id = p_order_id::text
      and im.movement_type = 'sale_out'
    order by im.occurred_at asc, im.id asc
  loop
    select b.expiry_date, b.production_date, b.unit_cost
    into v_source_batch
    from public.batches b
    where b.id = v_sale.batch_id;

    v_wh := v_sale.warehouse_id;
    if v_wh is null then
      v_wh := coalesce(v_order.warehouse_id, public._resolve_default_admin_warehouse_id());
    end if;
    if v_wh is null then
      raise exception 'warehouse_id is required';
    end if;

    v_ret_batch_id := gen_random_uuid();
    insert into public.batches(
      id,
      item_id,
      receipt_item_id,
      receipt_id,
      warehouse_id,
      batch_code,
      production_date,
      expiry_date,
      quantity_received,
      quantity_consumed,
      unit_cost,
      qc_status,
      data
    )
    values (
      v_ret_batch_id,
      v_sale.item_id::text,
      null,
      null,
      v_wh,
      null,
      v_source_batch.production_date,
      v_source_batch.expiry_date,
      v_sale.quantity,
      0,
      coalesce(v_sale.unit_cost, v_source_batch.unit_cost, 0),
      'released',
      jsonb_build_object(
        'source', 'orders',
        'event', 'voided',
        'orderId', p_order_id::text,
        'sourceBatchId', v_sale.batch_id::text,
        'sourceMovementId', v_sale.id::text
      )
    );

    insert into public.inventory_movements(
      item_id, movement_type, quantity, unit_cost, total_cost,
      reference_table, reference_id, occurred_at, created_by, data, batch_id, warehouse_id
    )
    values (
      v_sale.item_id::text,
      'return_in',
      v_sale.quantity,
      coalesce(v_sale.unit_cost, v_source_batch.unit_cost, 0),
      v_sale.quantity * coalesce(v_sale.unit_cost, v_source_batch.unit_cost, 0),
      'orders',
      p_order_id::text,
      now(),
      auth.uid(),
      jsonb_build_object(
        'orderId', p_order_id::text,
        'warehouseId', v_wh::text,
        'event', 'voided',
        'sourceBatchId', v_sale.batch_id::text,
        'sourceMovementId', v_sale.id::text
      ),
      v_ret_batch_id,
      v_wh
    )
    returning id into v_movement_id;

    perform public.post_inventory_movement(v_movement_id);
    perform public.recompute_stock_for_item(v_sale.item_id::text, v_wh);
  end loop;

  v_data := coalesce(v_order.data, '{}'::jsonb);
  v_data := jsonb_set(v_data, '{voidedAt}', to_jsonb(now()::text), true);
  if nullif(trim(coalesce(p_reason,'')),'') is not null then
    v_data := jsonb_set(v_data, '{voidReason}', to_jsonb(p_reason), true);
  end if;
  v_data := jsonb_set(v_data, '{voidedBy}', to_jsonb(auth.uid()::text), true);

  update public.orders
  set data = v_data,
      updated_at = now()
  where id = p_order_id;

  perform public._apply_ar_open_item_credit(p_order_id, v_ar_amount);
end;
$$;


ALTER FUNCTION "public"."void_delivered_order"("p_order_id" "uuid", "p_reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."void_journal_entry"("p_entry_id" "uuid", "p_reason" "text") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  v_entry public.journal_entries%rowtype;
  v_new_entry_id uuid;
  v_line record;
  v_reason text;
begin
  if not public.has_admin_permission('accounting.void') then
    raise exception 'not allowed';
  end if;
  if p_entry_id is null then
    raise exception 'p_entry_id is required';
  end if;
  select * into v_entry from public.journal_entries where id = p_entry_id;
  if not found then
    raise exception 'journal entry not found';
  end if;
  if v_entry.source_table = 'manual' and v_entry.status = 'draft' then
    raise exception 'not allowed';
  end if;
  v_reason := nullif(trim(coalesce(p_reason,'')),'');
  if v_reason is null then
    raise exception 'reason required';
  end if;
  perform public.set_audit_reason(v_reason);

  perform set_config('app.accounting_bypass', '1', true);
  update public.journal_entries
  set status = 'voided',
      voided_by = auth.uid(),
      voided_at = now(),
      void_reason = v_reason
  where id = p_entry_id;

  insert into public.journal_entries(entry_date, memo, source_table, source_id, source_event, created_by)
  values (now(), concat('Void ', p_entry_id::text, ' ', coalesce(v_entry.memo,'')), 'journal_entries', p_entry_id::text, 'void', auth.uid())
  returning id into v_new_entry_id;

  for v_line in
    select account_id, debit, credit, line_memo, cost_center_id from public.journal_lines where journal_entry_id = p_entry_id
  loop
    insert into public.journal_lines(journal_entry_id, account_id, debit, credit, line_memo, cost_center_id)
    values (v_new_entry_id, v_line.account_id, v_line.credit, v_line.debit, coalesce(v_line.line_memo,'') || ' (reversal)', v_line.cost_center_id);
  end loop;

  insert into public.system_audit_logs(action, module, details, performed_by, performed_at, metadata, risk_level, reason_code)
  values ('journal_entries.void', 'accounting', p_entry_id::text, auth.uid(), now(),
          jsonb_build_object('voidOf', p_entry_id::text, 'newEntryId', v_new_entry_id::text),
          'HIGH', v_reason);
  return v_new_entry_id;
end;
$$;


ALTER FUNCTION "public"."void_journal_entry"("p_entry_id" "uuid", "p_reason" "text") OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."accounting_documents" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "document_type" "text" NOT NULL,
    "source_table" "text" NOT NULL,
    "source_id" "text" NOT NULL,
    "branch_id" "uuid" NOT NULL,
    "company_id" "uuid" NOT NULL,
    "status" "text" NOT NULL,
    "memo" "text",
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "reversed_document_id" "uuid",
    CONSTRAINT "accounting_documents_document_type_check" CHECK (("document_type" = ANY (ARRAY['po'::"text", 'grn'::"text", 'invoice'::"text", 'payment'::"text", 'writeoff'::"text", 'manual'::"text", 'movement'::"text"]))),
    CONSTRAINT "accounting_documents_status_check" CHECK (("status" = ANY (ARRAY['posted'::"text", 'reversed'::"text"])))
);


ALTER TABLE "public"."accounting_documents" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."accounting_light_entries" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "entry_type" "text" NOT NULL,
    "item_id" "text" NOT NULL,
    "warehouse_id" "uuid",
    "batch_id" "uuid",
    "quantity" numeric NOT NULL,
    "unit" "text",
    "unit_cost" numeric DEFAULT 0 NOT NULL,
    "total_cost" numeric DEFAULT 0 NOT NULL,
    "occurred_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "debit_account" "text" DEFAULT 'shrinkage'::"text" NOT NULL,
    "credit_account" "text" DEFAULT 'inventory'::"text" NOT NULL,
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "notes" "text",
    "source_ref" "text",
    CONSTRAINT "accounting_light_entries_entry_type_check" CHECK (("entry_type" = ANY (ARRAY['wastage'::"text", 'expiry'::"text"]))),
    CONSTRAINT "accounting_light_entries_quantity_check" CHECK (("quantity" > (0)::numeric))
);


ALTER TABLE "public"."accounting_light_entries" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."accounting_period_snapshots" (
    "period_id" "uuid" NOT NULL,
    "account_id" "uuid" NOT NULL,
    "closing_balance" numeric NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_by" "uuid"
);

ALTER TABLE ONLY "public"."accounting_period_snapshots" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."accounting_period_snapshots" OWNER TO "postgres";


COMMENT ON TABLE "public"."accounting_period_snapshots" IS 'Purpose: immutable account closing balances captured at period close. Source of truth: journal_entries/journal_lines up to period end at close time. Used by balances_as_of() to avoid recalculating closed periods.';



CREATE TABLE IF NOT EXISTS "public"."accounting_periods" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "start_date" "date" NOT NULL,
    "end_date" "date" NOT NULL,
    "status" "text" DEFAULT 'open'::"text" NOT NULL,
    "closed_at" timestamp with time zone,
    "closed_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "accounting_periods_check" CHECK (("start_date" <= "end_date")),
    CONSTRAINT "accounting_periods_status_check" CHECK (("status" = ANY (ARRAY['open'::"text", 'closed'::"text"])))
);

ALTER TABLE ONLY "public"."accounting_periods" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."accounting_periods" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."addons" (
    "id" "uuid" NOT NULL,
    "name" "text",
    "is_active" boolean DEFAULT true NOT NULL,
    "data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."addons" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."admin_users" (
    "auth_user_id" "uuid" NOT NULL,
    "username" "text" NOT NULL,
    "full_name" "text",
    "email" "text",
    "phone_number" "text",
    "avatar_url" "text",
    "role" "text" NOT NULL,
    "permissions" "text"[],
    "is_active" boolean DEFAULT true NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "company_id" "uuid",
    "branch_id" "uuid",
    "warehouse_id" "uuid",
    CONSTRAINT "admin_users_role_check" CHECK (("role" = ANY (ARRAY['owner'::"text", 'manager'::"text", 'employee'::"text", 'cashier'::"text", 'delivery'::"text", 'accountant'::"text"])))
);


ALTER TABLE "public"."admin_users" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ads" (
    "id" "text" NOT NULL,
    "status" "text",
    "display_order" integer,
    "data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."ads" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."app_settings" (
    "id" "text" DEFAULT 'singleton'::"text" NOT NULL,
    "data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."app_settings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."approval_policies" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "request_type" "text" NOT NULL,
    "min_amount" numeric NOT NULL,
    "max_amount" numeric,
    "steps_count" integer NOT NULL,
    "is_active" boolean DEFAULT true NOT NULL
);


ALTER TABLE "public"."approval_policies" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."approval_policy_steps" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "policy_id" "uuid" NOT NULL,
    "step_no" integer NOT NULL,
    "approver_role" "text" NOT NULL
);


ALTER TABLE "public"."approval_policy_steps" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."approval_requests" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "target_table" "text" NOT NULL,
    "target_id" "text" NOT NULL,
    "request_type" "text" NOT NULL,
    "status" "text" NOT NULL,
    "requested_by" "uuid" NOT NULL,
    "approved_by" "uuid",
    "approved_at" timestamp with time zone,
    "rejected_by" "uuid",
    "rejected_at" timestamp with time zone,
    "payload_hash" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "branch_id" "uuid",
    "company_id" "uuid",
    CONSTRAINT "approval_requests_request_type_check" CHECK (("request_type" = ANY (ARRAY['po'::"text", 'receipt'::"text", 'discount'::"text", 'transfer'::"text", 'writeoff'::"text", 'offline_reconciliation'::"text"]))),
    CONSTRAINT "approval_requests_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'rejected'::"text"])))
);


ALTER TABLE "public"."approval_requests" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."approval_steps" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "request_id" "uuid" NOT NULL,
    "step_no" integer NOT NULL,
    "approver_role" "text" NOT NULL,
    "status" "text" NOT NULL,
    "action_by" "uuid",
    "action_at" timestamp with time zone,
    CONSTRAINT "approval_steps_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'rejected'::"text"])))
);


ALTER TABLE "public"."approval_steps" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ar_allocations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "open_item_id" "uuid" NOT NULL,
    "payment_id" "uuid" NOT NULL,
    "amount" numeric NOT NULL,
    "occurred_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "ar_allocations_amount_check" CHECK (("amount" > (0)::numeric))
);

ALTER TABLE ONLY "public"."ar_allocations" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."ar_allocations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ar_open_items" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "invoice_id" "uuid" NOT NULL,
    "order_id" "uuid",
    "journal_entry_id" "uuid" NOT NULL,
    "original_amount" numeric NOT NULL,
    "open_balance" numeric NOT NULL,
    "status" "text" NOT NULL,
    "currency" "text" DEFAULT 'YER'::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "closed_at" timestamp with time zone,
    CONSTRAINT "ar_open_items_open_balance_check" CHECK (("open_balance" >= (0)::numeric)),
    CONSTRAINT "ar_open_items_original_amount_check" CHECK (("original_amount" > (0)::numeric)),
    CONSTRAINT "ar_open_items_status_check" CHECK (("status" = ANY (ARRAY['open'::"text", 'closed'::"text"])))
);

ALTER TABLE ONLY "public"."ar_open_items" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."ar_open_items" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ar_payment_status" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "payment_id" "uuid" NOT NULL,
    "order_id" "uuid" NOT NULL,
    "eligible" boolean DEFAULT false NOT NULL,
    "allocated" boolean DEFAULT false NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."ar_payment_status" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."ar_payment_status" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."chart_of_accounts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "code" "text" NOT NULL,
    "name" "text" NOT NULL,
    "account_type" "text" NOT NULL,
    "normal_balance" "text" NOT NULL,
    "is_active" boolean DEFAULT true NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "ifrs_statement" "text",
    "ifrs_category" "text",
    "ifrs_line" "text",
    CONSTRAINT "chart_of_accounts_account_type_check" CHECK (("account_type" = ANY (ARRAY['asset'::"text", 'liability'::"text", 'equity'::"text", 'income'::"text", 'expense'::"text"]))),
    CONSTRAINT "chart_of_accounts_ifrs_statement_check" CHECK (("ifrs_statement" = ANY (ARRAY['BS'::"text", 'PL'::"text", 'EQ'::"text"]))),
    CONSTRAINT "chart_of_accounts_normal_balance_check" CHECK (("normal_balance" = ANY (ARRAY['debit'::"text", 'credit'::"text"])))
);


ALTER TABLE "public"."chart_of_accounts" OWNER TO "postgres";


COMMENT ON COLUMN "public"."chart_of_accounts"."ifrs_statement" IS 'Purpose: statement placement for IFRS export. Values: BS/PL/EQ. Source of truth: maintained on chart_of_accounts.';



COMMENT ON COLUMN "public"."chart_of_accounts"."ifrs_category" IS 'Purpose: IFRS category/grouping for disclosures and exports. Source of truth: maintained on chart_of_accounts.';



COMMENT ON COLUMN "public"."chart_of_accounts"."ifrs_line" IS 'Purpose: human-readable IFRS line label used by notes/exports. Source of truth: maintained on chart_of_accounts.';



CREATE TABLE IF NOT EXISTS "public"."journal_entries" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "entry_date" timestamp with time zone DEFAULT "now"() NOT NULL,
    "memo" "text",
    "source_table" "text",
    "source_id" "text",
    "source_event" "text",
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "status" "text" DEFAULT 'posted'::"text" NOT NULL,
    "approved_by" "uuid",
    "approved_at" timestamp with time zone,
    "voided_by" "uuid",
    "voided_at" timestamp with time zone,
    "void_reason" "text",
    "document_id" "uuid",
    "branch_id" "uuid",
    "company_id" "uuid",
    CONSTRAINT "journal_entries_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'posted'::"text", 'voided'::"text"])))
);

ALTER TABLE ONLY "public"."journal_entries" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."journal_entries" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."journal_lines" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "journal_entry_id" "uuid" NOT NULL,
    "account_id" "uuid" NOT NULL,
    "debit" numeric DEFAULT 0 NOT NULL,
    "credit" numeric DEFAULT 0 NOT NULL,
    "line_memo" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "cost_center_id" "uuid",
    CONSTRAINT "journal_lines_check" CHECK ((NOT (("debit" > (0)::numeric) AND ("credit" > (0)::numeric)))),
    CONSTRAINT "journal_lines_credit_check" CHECK (("credit" >= (0)::numeric)),
    CONSTRAINT "journal_lines_debit_check" CHECK (("debit" >= (0)::numeric))
);

ALTER TABLE ONLY "public"."journal_lines" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."journal_lines" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."audit_general_ledger" WITH ("security_invoker"='true') AS
 SELECT "je"."entry_date",
    "je"."id" AS "journal_entry_id",
    "je"."source_table",
    "je"."source_id",
    "je"."source_event",
    "coa"."code" AS "account_code",
    "coa"."name" AS "account_name",
    "coa"."account_type",
    "coa"."normal_balance",
    "coa"."ifrs_statement",
    "coa"."ifrs_category",
    "coa"."ifrs_line",
    "jl"."debit",
    "jl"."credit",
    "jl"."line_memo",
    "je"."memo" AS "entry_memo",
    "je"."created_by",
    "je"."created_at"
   FROM (("public"."journal_entries" "je"
     JOIN "public"."journal_lines" "jl" ON (("jl"."journal_entry_id" = "je"."id")))
     JOIN "public"."chart_of_accounts" "coa" ON (("coa"."id" = "jl"."account_id")))
  ORDER BY "je"."entry_date", "je"."id", "coa"."code", "jl"."id";


ALTER VIEW "public"."audit_general_ledger" OWNER TO "postgres";


COMMENT ON VIEW "public"."audit_general_ledger" IS 'Purpose: export-ready General Ledger (flat). Source of truth: journal_entries + journal_lines + chart_of_accounts. Output: deterministic ordering by entry_date/entry_id/account_code/line_id.';



CREATE OR REPLACE VIEW "public"."audit_journal_entries_with_source" WITH ("security_invoker"='true') AS
 WITH "totals" AS (
         SELECT "je_1"."id" AS "journal_entry_id",
            COALESCE("sum"("jl"."debit"), (0)::numeric) AS "total_debits",
            COALESCE("sum"("jl"."credit"), (0)::numeric) AS "total_credits"
           FROM ("public"."journal_entries" "je_1"
             LEFT JOIN "public"."journal_lines" "jl" ON (("jl"."journal_entry_id" = "je_1"."id")))
          GROUP BY "je_1"."id"
        )
 SELECT "je"."entry_date",
    "je"."id" AS "journal_entry_id",
    "je"."source_table",
    "je"."source_id",
    "je"."source_event",
    "je"."memo",
    "je"."created_by",
    "je"."created_at",
    "t"."total_debits",
    "t"."total_credits",
    ("t"."total_debits" - "t"."total_credits") AS "discrepancy"
   FROM ("public"."journal_entries" "je"
     JOIN "totals" "t" ON (("t"."journal_entry_id" = "je"."id")))
  ORDER BY "je"."entry_date", "je"."id";


ALTER VIEW "public"."audit_journal_entries_with_source" OWNER TO "postgres";


COMMENT ON VIEW "public"."audit_journal_entries_with_source" IS 'Purpose: export-ready Journal Entries with source and control totals. Source of truth: journal_entries + journal_lines. Output: per-entry totals and discrepancy.';



CREATE OR REPLACE VIEW "public"."audit_period_snapshots" WITH ("security_invoker"='true') AS
 SELECT "ap"."id" AS "period_id",
    "ap"."name" AS "period_name",
    "ap"."start_date",
    "ap"."end_date",
    "ap"."status",
    "aps"."account_id",
    "coa"."code" AS "account_code",
    "coa"."name" AS "account_name",
    "coa"."account_type",
    "coa"."normal_balance",
    "coa"."ifrs_statement",
    "coa"."ifrs_category",
    "coa"."ifrs_line",
    "aps"."closing_balance",
    "aps"."created_at",
    "aps"."created_by"
   FROM (("public"."accounting_period_snapshots" "aps"
     JOIN "public"."accounting_periods" "ap" ON (("ap"."id" = "aps"."period_id")))
     JOIN "public"."chart_of_accounts" "coa" ON (("coa"."id" = "aps"."account_id")))
  ORDER BY "ap"."end_date", "ap"."id", "coa"."code";


ALTER VIEW "public"."audit_period_snapshots" OWNER TO "postgres";


COMMENT ON VIEW "public"."audit_period_snapshots" IS 'Purpose: export-ready period snapshot balances. Source of truth: accounting_period_snapshots created at period close. Output: flat deterministic dataset per period/account.';



CREATE OR REPLACE VIEW "public"."audit_trial_balance_all_time" WITH ("security_invoker"='true') AS
 WITH "b" AS (
         SELECT "balances_as_of"."account_id",
            "balances_as_of"."balance"
           FROM "public"."balances_as_of"("now"()) "balances_as_of"("account_id", "balance")
        )
 SELECT "coa"."code" AS "account_code",
    "coa"."name" AS "account_name",
    "coa"."account_type",
    "coa"."normal_balance",
    "coa"."ifrs_statement",
    "coa"."ifrs_category",
    "coa"."ifrs_line",
    "b"."balance" AS "closing_balance"
   FROM ("public"."chart_of_accounts" "coa"
     JOIN "b" ON (("b"."account_id" = "coa"."id")))
  WHERE ("coa"."is_active" = true)
  ORDER BY "coa"."code";


ALTER VIEW "public"."audit_trial_balance_all_time" OWNER TO "postgres";


COMMENT ON VIEW "public"."audit_trial_balance_all_time" IS 'Purpose: export-ready Trial Balance (closing balances as-of now). Source of truth: balances_as_of(now()) + chart_of_accounts mapping.';



CREATE TABLE IF NOT EXISTS "public"."banks" (
    "id" "text" NOT NULL,
    "data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."banks" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."batch_balances" (
    "item_id" "text" NOT NULL,
    "batch_id" "uuid" NOT NULL,
    "warehouse_id" "uuid" NOT NULL,
    "quantity" numeric DEFAULT 0 NOT NULL,
    "expiry_date" "date",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "batch_balances_quantity_check" CHECK (("quantity" >= (0)::numeric))
);


ALTER TABLE "public"."batch_balances" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."batch_recalls" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "batch_id" "uuid" NOT NULL,
    "recall_reason" "text" NOT NULL,
    "initiated_by" "uuid" NOT NULL,
    "initiated_at" timestamp with time zone DEFAULT "now"(),
    "status" "text" NOT NULL,
    CONSTRAINT "batch_recalls_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'closed'::"text"])))
);


ALTER TABLE "public"."batch_recalls" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."batch_reservations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "order_id" "uuid" NOT NULL,
    "item_id" "text" NOT NULL,
    "batch_id" "uuid" NOT NULL,
    "warehouse_id" "uuid" NOT NULL,
    "quantity" numeric NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "batch_reservations_quantity_check" CHECK (("quantity" > (0)::numeric))
);


ALTER TABLE "public"."batch_reservations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."batch_sales_trace" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "batch_id" "uuid" NOT NULL,
    "order_id" "uuid" NOT NULL,
    "order_item_id" "uuid",
    "quantity" numeric NOT NULL,
    "sold_at" timestamp with time zone NOT NULL
);


ALTER TABLE "public"."batch_sales_trace" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."batches" (
    "id" "uuid" NOT NULL,
    "item_id" "text" NOT NULL,
    "receipt_item_id" "uuid",
    "receipt_id" "uuid",
    "warehouse_id" "uuid",
    "batch_code" "text",
    "production_date" "date",
    "expiry_date" "date",
    "quantity_received" numeric NOT NULL,
    "quantity_consumed" numeric DEFAULT 0 NOT NULL,
    "unit_cost" numeric DEFAULT 0 NOT NULL,
    "data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "quantity_transferred" numeric DEFAULT 0 NOT NULL,
    "qc_status" "text" DEFAULT 'released'::"text",
    "status" "text" DEFAULT 'active'::"text" NOT NULL,
    "locked_at" timestamp with time zone,
    "cost_per_unit" numeric DEFAULT 0 NOT NULL,
    "min_margin_pct" numeric DEFAULT 0 NOT NULL,
    "min_selling_price" numeric DEFAULT 0 NOT NULL,
    CONSTRAINT "batches_dates_consistency" CHECK ((("production_date" IS NULL) OR ("expiry_date" IS NULL) OR ("expiry_date" >= "production_date"))),
    CONSTRAINT "batches_min_margin_pct_check" CHECK (("min_margin_pct" >= (0)::numeric)),
    CONSTRAINT "batches_min_selling_price_check" CHECK (("min_selling_price" >= (0)::numeric)),
    CONSTRAINT "batches_qty_consistency" CHECK (("quantity_consumed" <= "quantity_received")),
    CONSTRAINT "batches_qty_transferred_le_received" CHECK (("quantity_transferred" <= "quantity_received")),
    CONSTRAINT "batches_quantity_consumed_check" CHECK (("quantity_consumed" >= (0)::numeric)),
    CONSTRAINT "batches_quantity_received_check" CHECK (("quantity_received" >= (0)::numeric))
);


ALTER TABLE "public"."batches" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."branches" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "code" "text" NOT NULL,
    "name" "text" NOT NULL,
    "is_active" boolean DEFAULT true NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."branches" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."challenges" (
    "id" "uuid" NOT NULL,
    "status" "text",
    "end_date" "date",
    "data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."challenges" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."cod_settlement_orders" (
    "settlement_id" "uuid" NOT NULL,
    "order_id" "uuid" NOT NULL,
    "amount" numeric NOT NULL,
    CONSTRAINT "cod_settlement_orders_amount_check" CHECK (("amount" > (0)::numeric))
);

ALTER TABLE ONLY "public"."cod_settlement_orders" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."cod_settlement_orders" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."cod_settlements" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "driver_id" "uuid" NOT NULL,
    "shift_id" "uuid" NOT NULL,
    "total_amount" numeric NOT NULL,
    "occurred_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_by" "uuid",
    "data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "cod_settlements_total_amount_check" CHECK (("total_amount" > (0)::numeric))
);

ALTER TABLE ONLY "public"."cod_settlements" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."cod_settlements" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."companies" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "is_active" boolean DEFAULT true NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."companies" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."cost_centers" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "code" "text",
    "description" "text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."cost_centers" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."coupons" (
    "id" "uuid" NOT NULL,
    "code" "text" NOT NULL,
    "is_active" boolean DEFAULT true NOT NULL,
    "data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."coupons" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."currencies" (
    "code" "text" NOT NULL,
    "name" "text" NOT NULL,
    "is_base" boolean DEFAULT false NOT NULL,
    "is_high_inflation" boolean DEFAULT false NOT NULL
);


ALTER TABLE "public"."currencies" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."customer_special_prices" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "customer_id" "uuid" NOT NULL,
    "item_id" "text" NOT NULL,
    "special_price" numeric NOT NULL,
    "valid_from" "date" NOT NULL,
    "valid_to" "date",
    "notes" "text",
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "customer_special_prices_special_price_check" CHECK (("special_price" >= (0)::numeric))
);


ALTER TABLE "public"."customer_special_prices" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."customer_tax_profiles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "customer_id" "uuid" NOT NULL,
    "jurisdiction_id" "uuid" NOT NULL
);


ALTER TABLE "public"."customer_tax_profiles" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."customers" (
    "auth_user_id" "uuid" NOT NULL,
    "full_name" "text",
    "phone_number" "text",
    "email" "text",
    "auth_provider" "text",
    "password_salt" "text",
    "password_hash" "text",
    "referral_code" "text",
    "referred_by" "text",
    "loyalty_points" integer DEFAULT 0 NOT NULL,
    "loyalty_tier" "text",
    "total_spent" numeric DEFAULT 0 NOT NULL,
    "first_order_discount_applied" boolean DEFAULT false NOT NULL,
    "avatar_url" "text",
    "data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "phone_encrypted" "bytea",
    "address_encrypted" "bytea",
    "customer_type" "text" DEFAULT 'retail'::"text",
    "credit_limit" numeric DEFAULT 0,
    "current_balance" numeric DEFAULT 0,
    "payment_terms" "text" DEFAULT 'cash'::"text",
    "tax_number" "text",
    "business_name" "text",
    "preferred_currency" "text",
    CONSTRAINT "customers_credit_limit_check" CHECK (("credit_limit" >= (0)::numeric)),
    CONSTRAINT "customers_customer_type_check" CHECK (("customer_type" = ANY (ARRAY['retail'::"text", 'wholesale'::"text", 'distributor'::"text", 'vip'::"text"]))),
    CONSTRAINT "customers_payment_terms_check" CHECK (("payment_terms" = ANY (ARRAY['cash'::"text", 'net_7'::"text", 'net_15'::"text", 'net_30'::"text", 'net_60'::"text", 'net_90'::"text"])))
);


ALTER TABLE "public"."customers" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."customers_decrypted" WITH ("security_invoker"='true') AS
 SELECT "auth_user_id",
    "full_name",
    "phone_number",
    "public"."decrypt_text"("phone_encrypted") AS "phone_decrypted",
    "email",
    "auth_provider",
    "password_salt",
    "password_hash",
    "referral_code",
    "referred_by",
    "loyalty_points",
    "loyalty_tier",
    "total_spent",
    "first_order_discount_applied",
    "avatar_url",
    ("data" || "jsonb_build_object"('address_decrypted', "public"."decrypt_text"("address_encrypted"), 'address_encrypted',
        CASE
            WHEN ("address_encrypted" IS NOT NULL) THEN true
            ELSE false
        END)) AS "data_with_decrypted",
    "created_at",
    "updated_at"
   FROM "public"."customers" "c"
  WHERE "public"."is_admin"();


ALTER VIEW "public"."customers_decrypted" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."delivery_zones" (
    "id" "uuid" NOT NULL,
    "name" "text",
    "is_active" boolean DEFAULT true NOT NULL,
    "delivery_fee" numeric DEFAULT 0 NOT NULL,
    "data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."delivery_zones" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."driver_ledger" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "driver_id" "uuid" NOT NULL,
    "reference_type" "text" NOT NULL,
    "reference_id" "text" NOT NULL,
    "debit" numeric DEFAULT 0 NOT NULL,
    "credit" numeric DEFAULT 0 NOT NULL,
    "balance_after" numeric NOT NULL,
    "occurred_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "driver_ledger_check" CHECK (((("debit" > (0)::numeric) AND ("credit" = (0)::numeric)) OR (("credit" > (0)::numeric) AND ("debit" = (0)::numeric)))),
    CONSTRAINT "driver_ledger_credit_check" CHECK (("credit" >= (0)::numeric)),
    CONSTRAINT "driver_ledger_debit_check" CHECK (("debit" >= (0)::numeric)),
    CONSTRAINT "driver_ledger_reference_type_check" CHECK (("reference_type" = ANY (ARRAY['order'::"text", 'settlement'::"text"])))
);

ALTER TABLE ONLY "public"."driver_ledger" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."driver_ledger" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."expenses" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "title" "text" NOT NULL,
    "amount" numeric NOT NULL,
    "category" "text" NOT NULL,
    "date" "date" DEFAULT CURRENT_DATE NOT NULL,
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "cost_center_id" "uuid",
    CONSTRAINT "expenses_amount_check" CHECK (("amount" > (0)::numeric))
);


ALTER TABLE "public"."expenses" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."freshness_levels" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "key" "text" NOT NULL,
    "is_active" boolean DEFAULT true NOT NULL,
    "data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."freshness_levels" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."fx_rates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "currency_code" "text" NOT NULL,
    "rate" numeric NOT NULL,
    "rate_date" "date" NOT NULL,
    "rate_type" "text" NOT NULL,
    CONSTRAINT "fx_rates_rate_type_check" CHECK (("rate_type" = ANY (ARRAY['operational'::"text", 'accounting'::"text"])))
);


ALTER TABLE "public"."fx_rates" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."fx_revaluation_audit" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "period_end" "date" NOT NULL,
    "entity_type" "text" NOT NULL,
    "entity_id" "uuid" NOT NULL,
    "currency" "text" NOT NULL,
    "original_base" numeric NOT NULL,
    "revalued_base" numeric NOT NULL,
    "diff" numeric NOT NULL,
    "journal_entry_id" "uuid" NOT NULL,
    "reversal_journal_entry_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "fx_revaluation_audit_entity_type_check" CHECK (("entity_type" = ANY (ARRAY['AR'::"text", 'AP'::"text"])))
);


ALTER TABLE "public"."fx_revaluation_audit" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."import_expenses" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "shipment_id" "uuid" NOT NULL,
    "expense_type" "text" NOT NULL,
    "amount" numeric NOT NULL,
    "currency" "text" DEFAULT 'YER'::"text",
    "exchange_rate" numeric DEFAULT 1,
    "description" "text",
    "invoice_number" "text",
    "paid_at" "date",
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "payment_method" "text" DEFAULT 'cash'::"text",
    "base_amount" numeric GENERATED ALWAYS AS ((COALESCE("amount", (0)::numeric) * COALESCE("exchange_rate", (1)::numeric))) STORED,
    CONSTRAINT "import_expenses_amount_check" CHECK (("amount" >= (0)::numeric)),
    CONSTRAINT "import_expenses_currency_check" CHECK (("currency" IS NOT NULL)),
    CONSTRAINT "import_expenses_exchange_rate_check" CHECK (("exchange_rate" IS NOT NULL)),
    CONSTRAINT "import_expenses_expense_type_check" CHECK (("expense_type" = ANY (ARRAY['shipping'::"text", 'customs'::"text", 'insurance'::"text", 'clearance'::"text", 'transport'::"text", 'other'::"text"]))),
    CONSTRAINT "import_expenses_payment_method_check" CHECK (("payment_method" = ANY (ARRAY['cash'::"text", 'bank'::"text"])))
);


ALTER TABLE "public"."import_expenses" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."import_shipments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "reference_number" "text" NOT NULL,
    "supplier_id" "uuid",
    "status" "text" NOT NULL,
    "origin_country" "text",
    "destination_warehouse_id" "uuid",
    "shipping_carrier" "text",
    "tracking_number" "text",
    "departure_date" "date",
    "expected_arrival_date" "date",
    "actual_arrival_date" "date",
    "total_weight_kg" numeric DEFAULT 0,
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    CONSTRAINT "import_shipments_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'ordered'::"text", 'shipped'::"text", 'at_customs'::"text", 'cleared'::"text", 'delivered'::"text", 'closed'::"text", 'cancelled'::"text"]))),
    CONSTRAINT "import_shipments_total_weight_kg_check" CHECK (("total_weight_kg" >= (0)::numeric))
);


ALTER TABLE "public"."import_shipments" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."import_shipments_items" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "shipment_id" "uuid" NOT NULL,
    "item_id" "text" NOT NULL,
    "quantity" numeric NOT NULL,
    "unit_price_fob" numeric DEFAULT 0 NOT NULL,
    "currency" "text" DEFAULT 'USD'::"text",
    "expiry_date" "date",
    "landing_cost_per_unit" numeric DEFAULT 0,
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "import_shipments_items_quantity_check" CHECK (("quantity" > (0)::numeric)),
    CONSTRAINT "import_shipments_items_unit_price_fob_check" CHECK (("unit_price_fob" >= (0)::numeric))
);


ALTER TABLE "public"."import_shipments_items" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."inventory_movements" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "item_id" "text" NOT NULL,
    "movement_type" "text" NOT NULL,
    "quantity" numeric NOT NULL,
    "unit_cost" numeric DEFAULT 0 NOT NULL,
    "total_cost" numeric DEFAULT 0 NOT NULL,
    "reference_table" "text",
    "reference_id" "text",
    "occurred_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_by" "uuid",
    "data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "batch_id" "uuid" NOT NULL,
    "warehouse_id" "uuid",
    "approval_status" "text" DEFAULT 'pending'::"text",
    "approval_request_id" "uuid",
    "requires_approval" boolean DEFAULT false,
    "uom_id" "uuid",
    "qty_base" numeric,
    "branch_id" "uuid",
    "company_id" "uuid",
    CONSTRAINT "inventory_movements_movement_type_check" CHECK (("movement_type" = ANY (ARRAY['purchase_in'::"text", 'sale_out'::"text", 'expired_out'::"text", 'wastage_out'::"text", 'transfer_out'::"text", 'transfer_in'::"text", 'adjust_in'::"text", 'adjust_out'::"text", 'return_in'::"text", 'return_out'::"text"]))),
    CONSTRAINT "inventory_movements_quantity_check" CHECK (("quantity" > (0)::numeric))
);


ALTER TABLE "public"."inventory_movements" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."inventory_transfer_items" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "transfer_id" "uuid" NOT NULL,
    "item_id" "text" NOT NULL,
    "source_batch_id" "uuid" NOT NULL,
    "quantity" numeric NOT NULL,
    "unit_cost" numeric DEFAULT 0 NOT NULL,
    "total_cost" numeric DEFAULT 0 NOT NULL,
    "dispatched_qty" numeric DEFAULT 0 NOT NULL,
    "received_qty" numeric DEFAULT 0 NOT NULL,
    "received_batch_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "uom_id" "uuid",
    "qty_base" numeric,
    CONSTRAINT "inventory_transfer_items_quantity_check" CHECK (("quantity" > (0)::numeric))
);


ALTER TABLE "public"."inventory_transfer_items" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."inventory_transfers" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "transfer_number" "text" NOT NULL,
    "from_warehouse_id" "uuid" NOT NULL,
    "to_warehouse_id" "uuid" NOT NULL,
    "transfer_date" "date" DEFAULT CURRENT_DATE NOT NULL,
    "state" "text" NOT NULL,
    "notes" "text",
    "payload" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_by" "uuid",
    "dispatched_by" "uuid",
    "received_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "dispatched_at" timestamp with time zone,
    "received_at" timestamp with time zone,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "create_idempotency_key" "text",
    "dispatch_idempotency_key" "text",
    "receive_idempotency_key" "text",
    "approval_status" "text" DEFAULT 'pending'::"text",
    "approval_request_id" "uuid",
    "requires_approval" boolean DEFAULT false,
    "branch_id" "uuid",
    "company_id" "uuid",
    CONSTRAINT "inventory_transfers_state_check" CHECK (("state" = ANY (ARRAY['CREATED'::"text", 'IN_TRANSIT'::"text", 'RECEIVED'::"text", 'CANCELLED'::"text"])))
);


ALTER TABLE "public"."inventory_transfers" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."invoice_seq"
    START WITH 1000
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."invoice_seq" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."invoice_tolerances" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "supplier_id" "uuid",
    "item_id" "text",
    "qty_tolerance" numeric DEFAULT 0 NOT NULL,
    "price_tolerance" numeric DEFAULT 0 NOT NULL,
    "is_active" boolean DEFAULT true NOT NULL
);


ALTER TABLE "public"."invoice_tolerances" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."item_categories" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "key" "text" NOT NULL,
    "is_active" boolean DEFAULT true NOT NULL,
    "data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."item_categories" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."item_groups" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "category_key" "text" NOT NULL,
    "key" "text" NOT NULL,
    "is_active" boolean DEFAULT true NOT NULL,
    "data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."item_groups" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."item_tax_profiles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "item_id" "text" NOT NULL,
    "tax_code" "text" NOT NULL
);


ALTER TABLE "public"."item_tax_profiles" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."item_uom" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "item_id" "text" NOT NULL,
    "base_uom_id" "uuid" NOT NULL,
    "purchase_uom_id" "uuid",
    "sales_uom_id" "uuid"
);


ALTER TABLE "public"."item_uom" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."job_runs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "job_name" "text" NOT NULL,
    "started_at" timestamp with time zone NOT NULL,
    "finished_at" timestamp with time zone,
    "status" "text" NOT NULL,
    "error" "text",
    CONSTRAINT "job_runs_status_check" CHECK (("status" = ANY (ARRAY['running'::"text", 'success'::"text", 'failed'::"text"])))
);


ALTER TABLE "public"."job_runs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."job_schedules" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "job_name" "text" NOT NULL,
    "cron_expr" "text" NOT NULL,
    "is_active" boolean DEFAULT true NOT NULL
);


ALTER TABLE "public"."job_schedules" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."landed_cost_audit" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "shipment_id" "uuid" NOT NULL,
    "total_expenses_base" numeric NOT NULL,
    "allocated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "journal_entry_id" "uuid" NOT NULL
);


ALTER TABLE "public"."landed_cost_audit" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ledger_audit_log" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "actor_user_id" "uuid",
    "actor_role" "text",
    "action" "text" NOT NULL,
    "table_name" "text" NOT NULL,
    "record_id" "text",
    "context" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."ledger_audit_log" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."ledger_audit_log" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ledger_entries" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "entry_type" "text" NOT NULL,
    "reference_type" "text" NOT NULL,
    "reference_id" "text" NOT NULL,
    "occurred_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_by" "uuid",
    "data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "ledger_entries_entry_type_check" CHECK (("entry_type" = ANY (ARRAY['delivery'::"text", 'settlement'::"text"]))),
    CONSTRAINT "ledger_entries_reference_type_check" CHECK (("reference_type" = ANY (ARRAY['order'::"text", 'settlement'::"text"])))
);

ALTER TABLE ONLY "public"."ledger_entries" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."ledger_entries" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ledger_lines" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "entry_id" "uuid" NOT NULL,
    "account" "public"."ledger_account_code" NOT NULL,
    "debit" numeric DEFAULT 0 NOT NULL,
    "credit" numeric DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "ledger_lines_check" CHECK (((("debit" > (0)::numeric) AND ("credit" = (0)::numeric)) OR (("credit" > (0)::numeric) AND ("debit" = (0)::numeric)))),
    CONSTRAINT "ledger_lines_credit_check" CHECK (("credit" >= (0)::numeric)),
    CONSTRAINT "ledger_lines_debit_check" CHECK (("debit" >= (0)::numeric))
);

ALTER TABLE ONLY "public"."ledger_lines" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."ledger_lines" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."menu_items" (
    "id" "text" NOT NULL,
    "category" "text",
    "is_featured" boolean DEFAULT false NOT NULL,
    "unit_type" "text",
    "freshness_level" "text",
    "status" "text",
    "data" "jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "cost_price" numeric DEFAULT 0 NOT NULL,
    "buying_price" numeric DEFAULT 0,
    "transport_cost" numeric DEFAULT 0,
    "supply_tax_cost" numeric DEFAULT 0,
    "name" "jsonb" NOT NULL,
    "barcode" "text",
    "price" numeric DEFAULT 0 NOT NULL,
    "base_unit" "text" DEFAULT 'piece'::"text" NOT NULL,
    "is_food" boolean DEFAULT false NOT NULL,
    "expiry_required" boolean DEFAULT false NOT NULL,
    "sellable" boolean DEFAULT true NOT NULL,
    "group_key" "text" GENERATED ALWAYS AS ("upper"(NULLIF("btrim"(COALESCE(("data" ->> 'group'::"text"), ''::"text")), ''::"text"))) STORED,
    CONSTRAINT "menu_items_expiry_requires_food_check" CHECK ((("expiry_required" = false) OR ("is_food" = true))),
    CONSTRAINT "menu_items_name_required_check" CHECK ((("jsonb_typeof"("name") = 'object'::"text") AND ("btrim"(COALESCE(("name" ->> 'ar'::"text"), ''::"text")) <> ''::"text"))),
    CONSTRAINT "menu_items_price_non_negative_check" CHECK (("price" >= (0)::numeric))
);


ALTER TABLE "public"."menu_items" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."notifications" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "title" "text" NOT NULL,
    "message" "text" NOT NULL,
    "type" "text" DEFAULT 'info'::"text",
    "link" "text",
    "is_read" boolean DEFAULT false NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "notifications_type_check" CHECK (("type" = ANY (ARRAY['info'::"text", 'success'::"text", 'warning'::"text", 'error'::"text", 'order_update'::"text", 'promo'::"text"])))
);


ALTER TABLE "public"."notifications" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."order_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "order_id" "uuid" NOT NULL,
    "action" "text" NOT NULL,
    "actor_type" "text" NOT NULL,
    "actor_id" "uuid",
    "from_status" "text",
    "to_status" "text",
    "payload" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."order_events" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."order_item_cogs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "order_id" "uuid" NOT NULL,
    "item_id" "text" NOT NULL,
    "quantity" numeric NOT NULL,
    "unit_cost" numeric DEFAULT 0 NOT NULL,
    "total_cost" numeric DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "order_item_cogs_quantity_check" CHECK (("quantity" > (0)::numeric))
);


ALTER TABLE "public"."order_item_cogs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."order_item_reservations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "order_id" "uuid" NOT NULL,
    "item_id" "text" NOT NULL,
    "warehouse_id" "uuid" NOT NULL,
    "quantity" numeric NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "batch_id" "uuid" NOT NULL,
    CONSTRAINT "order_item_reservations_quantity_check" CHECK (("quantity" > (0)::numeric))
);


ALTER TABLE "public"."order_item_reservations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."order_line_items" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "order_id" "uuid" NOT NULL,
    "item_id" "text",
    "quantity" numeric NOT NULL,
    "unit_price" numeric NOT NULL,
    "total" numeric NOT NULL,
    "data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL
);


ALTER TABLE "public"."order_line_items" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."order_tax_lines" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "order_id" "uuid" NOT NULL,
    "tax_code" "text" NOT NULL,
    "tax_rate" numeric NOT NULL,
    "tax_amount" numeric NOT NULL
);


ALTER TABLE "public"."order_tax_lines" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."orders" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "customer_auth_user_id" "uuid",
    "status" "text" NOT NULL,
    "invoice_number" "text",
    "data" "jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "tax_amount" numeric DEFAULT 0,
    "tax_rate" numeric DEFAULT 0,
    "delivery_zone_id" "uuid",
    "assigned_delivery_user_id" "uuid",
    "customer_name" "text",
    "phone_number" "text",
    "total" numeric DEFAULT 0,
    "subtotal" numeric DEFAULT 0,
    "tax" numeric DEFAULT 0,
    "delivery_fee" numeric DEFAULT 0,
    "discount" numeric DEFAULT 0,
    "items" "jsonb" DEFAULT '[]'::"jsonb",
    "payment_method" "text",
    "notes" "text",
    "address" "text",
    "location" "jsonb",
    "is_scheduled" boolean DEFAULT false,
    "scheduled_at" timestamp with time zone,
    "delivery_pin" "text",
    "points_redeemed_value" numeric DEFAULT 0,
    "points_earned" numeric DEFAULT 0,
    "discount_requires_approval" boolean DEFAULT false,
    "discount_approval_status" "text" DEFAULT 'approved'::"text",
    "discount_approval_request_id" "uuid",
    "currency" "text",
    "fx_rate" numeric,
    "base_total" numeric,
    "warehouse_id" "uuid",
    "branch_id" "uuid",
    "company_id" "uuid",
    "invoice_terms" "text" DEFAULT 'cash'::"text" NOT NULL,
    "net_days" integer DEFAULT 0 NOT NULL,
    "due_date" "date",
    "fx_locked" boolean DEFAULT true,
    CONSTRAINT "orders_currency_check" CHECK (("currency" IS NOT NULL)),
    CONSTRAINT "orders_invoice_terms_check" CHECK (("invoice_terms" = ANY (ARRAY['cash'::"text", 'credit'::"text"]))),
    CONSTRAINT "orders_net_days_check" CHECK (("net_days" >= 0))
);


ALTER TABLE "public"."orders" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."payments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "direction" "text" NOT NULL,
    "method" "text" NOT NULL,
    "amount" numeric NOT NULL,
    "currency" "text" DEFAULT 'YER'::"text" NOT NULL,
    "reference_table" "text",
    "reference_id" "text",
    "occurred_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_by" "uuid",
    "data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "idempotency_key" "text",
    "shift_id" "uuid",
    "fx_rate" numeric,
    "base_amount" numeric,
    "branch_id" "uuid",
    "company_id" "uuid",
    "fx_locked" boolean DEFAULT true,
    CONSTRAINT "payments_amount_check" CHECK (("amount" > (0)::numeric)),
    CONSTRAINT "payments_currency_check" CHECK (("currency" IS NOT NULL)),
    CONSTRAINT "payments_direction_check" CHECK (("direction" = ANY (ARRAY['in'::"text", 'out'::"text"])))
);


ALTER TABLE "public"."payments" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."pos_offline_sales" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "offline_id" "text" NOT NULL,
    "order_id" "uuid" NOT NULL,
    "warehouse_id" "uuid",
    "state" "text" NOT NULL,
    "last_error" "text",
    "payload" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "reconciliation_status" "text" DEFAULT 'NONE'::"text" NOT NULL,
    "reconciliation_approval_request_id" "uuid",
    "reconciled_by" "uuid",
    "reconciled_at" timestamp with time zone,
    "reconciliation_note" "text",
    CONSTRAINT "pos_offline_sales_reconciliation_status_check" CHECK (("reconciliation_status" = ANY (ARRAY['NONE'::"text", 'PENDING'::"text", 'APPROVED'::"text", 'REJECTED'::"text"]))),
    CONSTRAINT "pos_offline_sales_state_check" CHECK (("state" = ANY (ARRAY['CREATED_OFFLINE'::"text", 'SYNCED'::"text", 'DELIVERED'::"text", 'FAILED'::"text", 'CONFLICT'::"text"])))
);


ALTER TABLE "public"."pos_offline_sales" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."price_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "item_id" "text" NOT NULL,
    "date" "date" NOT NULL,
    "data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."price_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."price_tiers" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "item_id" "text" NOT NULL,
    "customer_type" "text" NOT NULL,
    "min_quantity" numeric NOT NULL,
    "max_quantity" numeric,
    "price" numeric NOT NULL,
    "discount_percentage" numeric,
    "is_active" boolean DEFAULT true,
    "valid_from" "date",
    "valid_to" "date",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "price_tiers_check" CHECK ((("max_quantity" IS NULL) OR ("max_quantity" >= "min_quantity"))),
    CONSTRAINT "price_tiers_customer_type_check" CHECK (("customer_type" = ANY (ARRAY['retail'::"text", 'wholesale'::"text", 'distributor'::"text", 'vip'::"text"]))),
    CONSTRAINT "price_tiers_discount_percentage_check" CHECK ((("discount_percentage" >= (0)::numeric) AND ("discount_percentage" <= (100)::numeric))),
    CONSTRAINT "price_tiers_min_quantity_check" CHECK (("min_quantity" >= (0)::numeric)),
    CONSTRAINT "price_tiers_price_check" CHECK (("price" >= (0)::numeric))
);


ALTER TABLE "public"."price_tiers" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."product_audit_log" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "item_id" "text" NOT NULL,
    "field" "text" NOT NULL,
    "old_value" "text",
    "new_value" "text",
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."product_audit_log" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."production_order_inputs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "order_id" "uuid" NOT NULL,
    "item_id" "text" NOT NULL,
    "quantity" numeric NOT NULL,
    "unit_cost" numeric DEFAULT 0 NOT NULL,
    "total_cost" numeric DEFAULT 0 NOT NULL,
    CONSTRAINT "production_order_inputs_quantity_check" CHECK (("quantity" > (0)::numeric))
);


ALTER TABLE "public"."production_order_inputs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."production_order_outputs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "order_id" "uuid" NOT NULL,
    "item_id" "text" NOT NULL,
    "quantity" numeric NOT NULL,
    "unit_cost" numeric DEFAULT 0 NOT NULL,
    "total_cost" numeric DEFAULT 0 NOT NULL,
    CONSTRAINT "production_order_outputs_quantity_check" CHECK (("quantity" > (0)::numeric))
);


ALTER TABLE "public"."production_order_outputs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."production_orders" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "occurred_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_by" "uuid",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."production_orders" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."promotion_items" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "promotion_id" "uuid" NOT NULL,
    "item_id" "text" NOT NULL,
    "quantity" numeric NOT NULL,
    "sort_order" integer DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "promotion_items_quantity_check" CHECK (("quantity" > (0)::numeric))
);


ALTER TABLE "public"."promotion_items" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."promotion_usage" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "promotion_id" "uuid" NOT NULL,
    "promotion_line_id" "uuid" NOT NULL,
    "order_id" "uuid",
    "bundle_qty" numeric DEFAULT 1 NOT NULL,
    "channel" "text" NOT NULL,
    "warehouse_id" "uuid",
    "snapshot" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "promotion_usage_bundle_qty_check" CHECK (("bundle_qty" > (0)::numeric)),
    CONSTRAINT "promotion_usage_channel_check" CHECK (("channel" = ANY (ARRAY['online'::"text", 'in_store'::"text", 'pos_offline_sync'::"text"])))
);


ALTER TABLE "public"."promotion_usage" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."promotions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "start_at" timestamp with time zone NOT NULL,
    "end_at" timestamp with time zone NOT NULL,
    "is_active" boolean DEFAULT false NOT NULL,
    "discount_mode" "text" NOT NULL,
    "fixed_total" numeric,
    "percent_off" numeric,
    "display_original_total" numeric,
    "max_uses" integer,
    "stack_policy" "text" DEFAULT 'exclusive'::"text" NOT NULL,
    "exclusive_with_coupon" boolean DEFAULT true NOT NULL,
    "requires_approval" boolean DEFAULT false NOT NULL,
    "approval_status" "text" DEFAULT 'approved'::"text" NOT NULL,
    "approval_request_id" "uuid",
    "data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "promotions_approval_status_check" CHECK (("approval_status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'rejected'::"text"]))),
    CONSTRAINT "promotions_discount_check" CHECK (((("discount_mode" = 'fixed_total'::"text") AND ("fixed_total" IS NOT NULL) AND ("fixed_total" > (0)::numeric) AND ("percent_off" IS NULL)) OR (("discount_mode" = 'percent_off'::"text") AND ("percent_off" IS NOT NULL) AND ("percent_off" > (0)::numeric) AND ("percent_off" <= (100)::numeric) AND ("fixed_total" IS NULL)))),
    CONSTRAINT "promotions_discount_mode_check" CHECK (("discount_mode" = ANY (ARRAY['fixed_total'::"text", 'percent_off'::"text"]))),
    CONSTRAINT "promotions_display_original_total_check" CHECK ((("display_original_total" IS NULL) OR ("display_original_total" > (0)::numeric))),
    CONSTRAINT "promotions_max_uses_check" CHECK ((("max_uses" IS NULL) OR ("max_uses" > 0))),
    CONSTRAINT "promotions_stack_policy_check" CHECK (("stack_policy" = 'exclusive'::"text")),
    CONSTRAINT "promotions_time_check" CHECK (("start_at" < "end_at"))
);


ALTER TABLE "public"."promotions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."purchase_items" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "purchase_order_id" "uuid",
    "item_id" "text",
    "quantity" numeric NOT NULL,
    "unit_cost" numeric DEFAULT 0 NOT NULL,
    "total_cost" numeric DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "received_quantity" numeric DEFAULT 0 NOT NULL,
    "uom_id" "uuid",
    "qty_base" numeric,
    "unit_cost_foreign" numeric,
    "unit_cost_base" numeric,
    CONSTRAINT "purchase_items_quantity_check" CHECK (("quantity" > (0)::numeric)),
    CONSTRAINT "purchase_items_received_quantity_check" CHECK (((COALESCE("received_quantity", (0)::numeric) >= (0)::numeric) AND (COALESCE("received_quantity", (0)::numeric) <= (COALESCE("quantity", (0)::numeric) + 0.000000001))))
);


ALTER TABLE "public"."purchase_items" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."purchase_order_number_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."purchase_order_number_seq" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."purchase_orders" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "supplier_id" "uuid",
    "status" "text" DEFAULT 'draft'::"text" NOT NULL,
    "reference_number" "text",
    "total_amount" numeric DEFAULT 0,
    "paid_amount" numeric DEFAULT 0,
    "purchase_date" "date" DEFAULT CURRENT_DATE,
    "items_count" integer DEFAULT 0,
    "notes" "text",
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "deleted_at" timestamp with time zone,
    "approval_status" "text" DEFAULT 'pending'::"text",
    "approval_request_id" "uuid",
    "requires_approval" boolean DEFAULT false,
    "warehouse_id" "uuid",
    "branch_id" "uuid",
    "company_id" "uuid",
    "payment_terms" "text" DEFAULT 'cash'::"text" NOT NULL,
    "net_days" integer DEFAULT 0 NOT NULL,
    "due_date" "date",
    "po_number" "text" NOT NULL,
    "currency" "text",
    "fx_rate" numeric,
    "base_total" numeric DEFAULT 0,
    "fx_locked" boolean DEFAULT false,
    CONSTRAINT "po_currency_check" CHECK (("currency" IS NOT NULL)),
    CONSTRAINT "purchase_orders_amounts_check" CHECK (((COALESCE("total_amount", (0)::numeric) >= (0)::numeric) AND (COALESCE("paid_amount", (0)::numeric) >= (0)::numeric) AND (COALESCE("paid_amount", (0)::numeric) <= (COALESCE("total_amount", (0)::numeric) + 0.000000001)))),
    CONSTRAINT "purchase_orders_net_days_check" CHECK (("net_days" >= 0)),
    CONSTRAINT "purchase_orders_payment_terms_check" CHECK (("payment_terms" = ANY (ARRAY['cash'::"text", 'credit'::"text"]))),
    CONSTRAINT "purchase_orders_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'partial'::"text", 'completed'::"text", 'cancelled'::"text"])))
);


ALTER TABLE "public"."purchase_orders" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."purchase_receipt_items" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "receipt_id" "uuid" NOT NULL,
    "item_id" "text" NOT NULL,
    "quantity" numeric NOT NULL,
    "unit_cost" numeric DEFAULT 0 NOT NULL,
    "total_cost" numeric DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "uom_id" "uuid",
    "qty_base" numeric,
    "transport_cost" numeric DEFAULT 0 NOT NULL,
    "supply_tax_cost" numeric DEFAULT 0 NOT NULL,
    CONSTRAINT "purchase_receipt_items_quantity_check" CHECK (("quantity" > (0)::numeric))
);


ALTER TABLE "public"."purchase_receipt_items" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."purchase_receipts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "purchase_order_id" "uuid" NOT NULL,
    "received_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_by" "uuid",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "approval_status" "text" DEFAULT 'pending'::"text",
    "approval_request_id" "uuid",
    "requires_approval" boolean DEFAULT false,
    "warehouse_id" "uuid",
    "branch_id" "uuid",
    "company_id" "uuid",
    "import_shipment_id" "uuid",
    "idempotency_key" "text"
);


ALTER TABLE "public"."purchase_receipts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."purchase_return_items" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "return_id" "uuid" NOT NULL,
    "item_id" "text" NOT NULL,
    "quantity" numeric NOT NULL,
    "unit_cost" numeric DEFAULT 0 NOT NULL,
    "total_cost" numeric DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "purchase_return_items_quantity_check" CHECK (("quantity" > (0)::numeric))
);


ALTER TABLE "public"."purchase_return_items" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."purchase_returns" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "purchase_order_id" "uuid" NOT NULL,
    "returned_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_by" "uuid",
    "reason" "text",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."purchase_returns" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."qc_checks" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "batch_id" "uuid" NOT NULL,
    "check_type" "text" NOT NULL,
    "result" "text" NOT NULL,
    "checked_by" "uuid" NOT NULL,
    "checked_at" timestamp with time zone DEFAULT "now"(),
    "notes" "text",
    CONSTRAINT "qc_checks_result_check" CHECK (("result" = ANY (ARRAY['pass'::"text", 'fail'::"text"])))
);


ALTER TABLE "public"."qc_checks" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."reviews" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "menu_item_id" "text" NOT NULL,
    "customer_auth_user_id" "uuid" NOT NULL,
    "rating" integer NOT NULL,
    "data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "reviews_rating_check" CHECK ((("rating" >= 1) AND ("rating" <= 5)))
);


ALTER TABLE "public"."reviews" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."sales_returns" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "order_id" "uuid" NOT NULL,
    "return_date" timestamp with time zone DEFAULT "now"() NOT NULL,
    "reason" "text",
    "refund_method" "text" DEFAULT 'cash'::"text" NOT NULL,
    "total_refund_amount" numeric DEFAULT 0 NOT NULL,
    "items" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "status" "text" DEFAULT 'draft'::"text" NOT NULL,
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "sales_returns_refund_method_check" CHECK (("refund_method" = ANY (ARRAY['cash'::"text", 'network'::"text", 'kuraimi'::"text", 'ar'::"text", 'store_credit'::"text"]))),
    CONSTRAINT "sales_returns_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'completed'::"text", 'cancelled'::"text"])))
);


ALTER TABLE "public"."sales_returns" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."stock_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "item_id" "text" NOT NULL,
    "date" "date" NOT NULL,
    "data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "quantity" numeric,
    "unit" "text",
    "reason" "text"
);


ALTER TABLE "public"."stock_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."stock_management" (
    "item_id" "text" NOT NULL,
    "available_quantity" numeric DEFAULT 0 NOT NULL,
    "reserved_quantity" numeric DEFAULT 0 NOT NULL,
    "unit" "text" DEFAULT 'piece'::"text" NOT NULL,
    "low_stock_threshold" numeric DEFAULT 5 NOT NULL,
    "last_updated" timestamp with time zone DEFAULT "now"() NOT NULL,
    "data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "avg_cost" numeric DEFAULT 0 NOT NULL,
    "last_batch_id" "uuid",
    "warehouse_id" "uuid",
    "qc_hold_quantity" numeric DEFAULT 0 NOT NULL
);


ALTER TABLE "public"."stock_management" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."stock_wastage" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "item_id" "text" NOT NULL,
    "quantity" numeric NOT NULL,
    "unit_type" "text",
    "cost_at_time" numeric NOT NULL,
    "reason" "text",
    "notes" "text",
    "reported_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "batch_id" "uuid",
    "warehouse_id" "uuid"
);


ALTER TABLE "public"."stock_wastage" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."supplier_contracts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "supplier_id" "uuid" NOT NULL,
    "contract_number" "text",
    "start_date" "date" NOT NULL,
    "end_date" "date" NOT NULL,
    "payment_terms" "text",
    "payment_terms_custom" "text",
    "delivery_lead_time_days" integer,
    "minimum_order_amount" numeric DEFAULT 0,
    "document_url" "text",
    "status" "text" DEFAULT 'active'::"text",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    CONSTRAINT "supplier_contracts_payment_terms_check" CHECK (("payment_terms" = ANY (ARRAY['cash'::"text", 'net15'::"text", 'net30'::"text", 'net45'::"text", 'net60'::"text", 'custom'::"text"]))),
    CONSTRAINT "supplier_contracts_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'expired'::"text", 'terminated'::"text", 'draft'::"text"])))
);


ALTER TABLE "public"."supplier_contracts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."supplier_credit_note_allocations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "credit_note_id" "uuid" NOT NULL,
    "root_batch_id" "uuid" NOT NULL,
    "affected_batch_id" "uuid",
    "receipt_id" "uuid" NOT NULL,
    "amount_total" numeric DEFAULT 0 NOT NULL,
    "amount_to_inventory" numeric DEFAULT 0 NOT NULL,
    "amount_to_cogs" numeric DEFAULT 0 NOT NULL,
    "batch_qty_received" numeric DEFAULT 0 NOT NULL,
    "batch_qty_onhand" numeric DEFAULT 0 NOT NULL,
    "batch_qty_sold" numeric DEFAULT 0 NOT NULL,
    "unit_cost_before" numeric DEFAULT 0 NOT NULL,
    "unit_cost_after" numeric DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."supplier_credit_note_allocations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."supplier_credit_notes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "supplier_id" "uuid" NOT NULL,
    "reference_purchase_receipt_id" "uuid" NOT NULL,
    "amount" numeric NOT NULL,
    "reason" "text",
    "status" "text" DEFAULT 'draft'::"text" NOT NULL,
    "created_by" "uuid",
    "applied_at" timestamp with time zone,
    "journal_entry_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "supplier_credit_notes_amount_check" CHECK (("amount" > (0)::numeric)),
    CONSTRAINT "supplier_credit_notes_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'applied'::"text", 'cancelled'::"text"])))
);


ALTER TABLE "public"."supplier_credit_notes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."supplier_evaluations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "supplier_id" "uuid" NOT NULL,
    "evaluation_date" "date" DEFAULT CURRENT_DATE NOT NULL,
    "period_start" "date",
    "period_end" "date",
    "quality_score" integer,
    "timeliness_score" integer,
    "pricing_score" integer,
    "communication_score" integer,
    "overall_score" numeric GENERATED ALWAYS AS (((((("quality_score" + "timeliness_score") + "pricing_score") + "communication_score"))::numeric / 4.0)) STORED,
    "notes" "text",
    "recommendation" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    CONSTRAINT "supplier_evaluations_communication_score_check" CHECK ((("communication_score" >= 1) AND ("communication_score" <= 5))),
    CONSTRAINT "supplier_evaluations_pricing_score_check" CHECK ((("pricing_score" >= 1) AND ("pricing_score" <= 5))),
    CONSTRAINT "supplier_evaluations_quality_score_check" CHECK ((("quality_score" >= 1) AND ("quality_score" <= 5))),
    CONSTRAINT "supplier_evaluations_recommendation_check" CHECK (("recommendation" = ANY (ARRAY['maintain'::"text", 'improve'::"text", 'terminate'::"text"]))),
    CONSTRAINT "supplier_evaluations_timeliness_score_check" CHECK ((("timeliness_score" >= 1) AND ("timeliness_score" <= 5)))
);


ALTER TABLE "public"."supplier_evaluations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."supplier_invoice_lines" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "invoice_id" "uuid" NOT NULL,
    "item_id" "text" NOT NULL,
    "quantity" numeric NOT NULL,
    "unit_price" numeric NOT NULL,
    "line_total" numeric NOT NULL,
    "po_id" "uuid",
    "receipt_id" "uuid"
);


ALTER TABLE "public"."supplier_invoice_lines" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."supplier_invoices" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "supplier_id" "uuid" NOT NULL,
    "invoice_number" "text" NOT NULL,
    "invoice_date" "date" NOT NULL,
    "currency" "text" NOT NULL,
    "fx_rate" numeric,
    "base_total" numeric,
    "total_amount" numeric NOT NULL,
    "status" "text" NOT NULL,
    "created_by" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "branch_id" "uuid",
    "company_id" "uuid",
    CONSTRAINT "supplier_invoices_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'matched'::"text", 'exception'::"text", 'approved'::"text", 'rejected'::"text", 'posted'::"text"])))
);


ALTER TABLE "public"."supplier_invoices" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."suppliers" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "contact_person" "text",
    "phone" "text",
    "email" "text",
    "tax_number" "text",
    "address" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "preferred_currency" "text"
);


ALTER TABLE "public"."suppliers" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."system_audit_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "action" "text" NOT NULL,
    "module" "text" NOT NULL,
    "details" "text",
    "metadata" "jsonb",
    "performed_by" "uuid",
    "performed_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "ip_address" "text",
    "risk_level" "text" DEFAULT 'LOW'::"text",
    "reason_code" "text",
    CONSTRAINT "system_audit_logs_risk_level_check" CHECK (("risk_level" = ANY (ARRAY['LOW'::"text", 'MEDIUM'::"text", 'HIGH'::"text"])))
);

ALTER TABLE ONLY "public"."system_audit_logs" FORCE ROW LEVEL SECURITY;


ALTER TABLE "public"."system_audit_logs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."tax_jurisdictions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "code" "text" NOT NULL,
    "name" "text" NOT NULL
);


ALTER TABLE "public"."tax_jurisdictions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."tax_rates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "jurisdiction_id" "uuid" NOT NULL,
    "tax_code" "text" NOT NULL,
    "rate" numeric NOT NULL,
    "effective_from" "date" NOT NULL,
    "effective_to" "date"
);


ALTER TABLE "public"."tax_rates" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."three_way_match_results" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "invoice_id" "uuid" NOT NULL,
    "po_id" "uuid",
    "receipt_id" "uuid",
    "item_id" "text" NOT NULL,
    "qty_po" numeric NOT NULL,
    "qty_grn" numeric NOT NULL,
    "qty_inv" numeric NOT NULL,
    "price_po" numeric NOT NULL,
    "price_inv" numeric NOT NULL,
    "status" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "three_way_match_results_status_check" CHECK (("status" = ANY (ARRAY['matched'::"text", 'qty_variance'::"text", 'price_variance'::"text"])))
);


ALTER TABLE "public"."three_way_match_results" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."transfer_recipients" (
    "id" "text" NOT NULL,
    "data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."transfer_recipients" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."unit_types" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "key" "text" NOT NULL,
    "is_active" boolean DEFAULT true NOT NULL,
    "is_weight_based" boolean DEFAULT false NOT NULL,
    "data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."unit_types" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."uom" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "code" "text" NOT NULL,
    "name" "text" NOT NULL
);


ALTER TABLE "public"."uom" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."uom_conversions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "from_uom_id" "uuid" NOT NULL,
    "to_uom_id" "uuid" NOT NULL,
    "numerator" bigint NOT NULL,
    "denominator" bigint NOT NULL
);


ALTER TABLE "public"."uom_conversions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_challenge_progress" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "customer_auth_user_id" "uuid" NOT NULL,
    "challenge_id" "uuid" NOT NULL,
    "is_completed" boolean DEFAULT false NOT NULL,
    "data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."user_challenge_progress" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_balance_sheet" WITH ("security_invoker"='true') AS
 WITH "b" AS (
         SELECT "balances_as_of"."account_id",
            "balances_as_of"."balance"
           FROM "public"."balances_as_of"("now"()) "balances_as_of"("account_id", "balance")
        ), "rows" AS (
         SELECT "coa"."account_type",
            "coa"."code" AS "account_code",
            "coa"."name" AS "account_name",
            "b"."balance"
           FROM ("public"."chart_of_accounts" "coa"
             JOIN "b" ON (("b"."account_id" = "coa"."id")))
          WHERE ("coa"."account_type" = ANY (ARRAY['asset'::"text", 'liability'::"text", 'equity'::"text"]))
        )
 SELECT "account_type",
    "account_code",
    "account_name",
    "balance",
    "sum"(
        CASE
            WHEN ("account_type" = 'asset'::"text") THEN "balance"
            ELSE (0)::numeric
        END) OVER () AS "total_assets",
    "sum"(
        CASE
            WHEN ("account_type" = ANY (ARRAY['liability'::"text", 'equity'::"text"])) THEN "balance"
            ELSE (0)::numeric
        END) OVER () AS "total_liabilities_equity",
    ("sum"(
        CASE
            WHEN ("account_type" = 'asset'::"text") THEN "balance"
            ELSE (0)::numeric
        END) OVER () - "sum"(
        CASE
            WHEN ("account_type" = ANY (ARRAY['liability'::"text", 'equity'::"text"])) THEN "balance"
            ELSE (0)::numeric
        END) OVER ()) AS "discrepancy"
   FROM "rows" "r"
  ORDER BY
        CASE "account_type"
            WHEN 'asset'::"text" THEN 1
            WHEN 'liability'::"text" THEN 2
            ELSE 3
        END, "account_code";


ALTER VIEW "public"."v_balance_sheet" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_balance_sheet" IS 'Purpose: Balance Sheet as-of now. Source of truth: balances_as_of(now()) which uses accounting_period_snapshots for closed periods and journal_entries/journal_lines only for post-snapshot deltas. Output: one row per BS account plus totals and discrepancy.';



CREATE OR REPLACE VIEW "public"."v_batch_balances" AS
 SELECT "item_id",
    "id" AS "batch_id",
    "warehouse_id",
    "expiry_date",
    GREATEST(((COALESCE("quantity_received", (0)::numeric) - COALESCE("quantity_consumed", (0)::numeric)) - COALESCE("quantity_transferred", (0)::numeric)), (0)::numeric) AS "remaining_qty"
   FROM "public"."batches" "b";


ALTER VIEW "public"."v_batch_balances" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_cash_in_transit_balance" AS
 SELECT COALESCE("sum"(
        CASE
            WHEN ("account" = 'Cash_In_Transit'::"public"."ledger_account_code") THEN ("debit" - "credit")
            ELSE (0)::numeric
        END), (0)::numeric) AS "cash_in_transit_balance"
   FROM "public"."ledger_lines" "ll";


ALTER VIEW "public"."v_cash_in_transit_balance" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_driver_ledger_balances" AS
 SELECT "driver_id",
    "max"("occurred_at") AS "last_occurred_at",
    ("array_agg"("balance_after" ORDER BY "occurred_at" DESC, "created_at" DESC, "id" DESC))[1] AS "balance_after"
   FROM "public"."driver_ledger" "dl"
  GROUP BY "driver_id";


ALTER VIEW "public"."v_driver_ledger_balances" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_cod_reconciliation_check" AS
 SELECT ( SELECT "v_cash_in_transit_balance"."cash_in_transit_balance"
           FROM "public"."v_cash_in_transit_balance") AS "cash_in_transit_balance",
    COALESCE(( SELECT "sum"("v_driver_ledger_balances"."balance_after") AS "sum"
           FROM "public"."v_driver_ledger_balances"), (0)::numeric) AS "sum_driver_balances",
    (( SELECT "v_cash_in_transit_balance"."cash_in_transit_balance"
           FROM "public"."v_cash_in_transit_balance") - COALESCE(( SELECT "sum"("v_driver_ledger_balances"."balance_after") AS "sum"
           FROM "public"."v_driver_ledger_balances"), (0)::numeric)) AS "diff";


ALTER VIEW "public"."v_cod_reconciliation_check" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_cod_unsettled_orders" AS
 SELECT "id" AS "order_id",
    (NULLIF(COALESCE(("data" ->> 'deliveredBy'::"text"), ("data" ->> 'assignedDeliveryUserId'::"text"), ''::"text"), ''::"text"))::"uuid" AS "driver_id",
    COALESCE(NULLIF((("data" ->> 'total'::"text"))::numeric, NULL::numeric), (0)::numeric) AS "amount",
    COALESCE(( SELECT "sum"("p"."amount") AS "sum"
           FROM "public"."payments" "p"
          WHERE (("p"."reference_table" = 'orders'::"text") AND ("p"."reference_id" = ("o"."id")::"text") AND ("p"."direction" = 'in'::"text"))), (0)::numeric) AS "paid_amount",
    GREATEST((COALESCE(NULLIF((("data" ->> 'total'::"text"))::numeric, NULL::numeric), (0)::numeric) - COALESCE(( SELECT "sum"("p"."amount") AS "sum"
           FROM "public"."payments" "p"
          WHERE (("p"."reference_table" = 'orders'::"text") AND ("p"."reference_id" = ("o"."id")::"text") AND ("p"."direction" = 'in'::"text"))), (0)::numeric)), (0)::numeric) AS "remaining_amount",
    (NULLIF(("data" ->> 'deliveredAt'::"text"), ''::"text"))::timestamp with time zone AS "delivered_at",
    "created_at"
   FROM "public"."orders" "o"
  WHERE (("status" = 'delivered'::"text") AND (NULLIF(("data" ->> 'paidAt'::"text"), ''::"text") IS NULL) AND (COALESCE(NULLIF(("data" ->> 'paymentMethod'::"text"), ''::"text"), ''::"text") = 'cash'::"text") AND (COALESCE(NULLIF(("data" ->> 'orderSource'::"text"), ''::"text"), ''::"text") <> 'in_store'::"text") AND ("delivery_zone_id" IS NOT NULL) AND (GREATEST((COALESCE(NULLIF((("data" ->> 'total'::"text"))::numeric, NULL::numeric), (0)::numeric) - COALESCE(( SELECT "sum"("p"."amount") AS "sum"
           FROM "public"."payments" "p"
          WHERE (("p"."reference_table" = 'orders'::"text") AND ("p"."reference_id" = ("o"."id")::"text") AND ("p"."direction" = 'in'::"text"))), (0)::numeric)), (0)::numeric) > (0)::numeric));


ALTER VIEW "public"."v_cod_unsettled_orders" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_cogs_movements" AS
 SELECT "id",
    "item_id",
    "movement_type",
    "quantity",
    "unit_cost",
    "total_cost",
    "reference_table",
    "reference_id",
    "occurred_at",
    "created_by",
    "data",
    "created_at",
    "batch_id",
    "warehouse_id"
   FROM "public"."inventory_movements" "im"
  WHERE ("movement_type" = ANY (ARRAY['sale_out'::"text", 'expired_out'::"text", 'wastage_out'::"text"]));


ALTER VIEW "public"."v_cogs_movements" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_cogs_reconciliation" WITH ("security_invoker"='true') AS
 SELECT "item_id",
    "expected_cogs",
    "actual_cogs",
    "delta"
   FROM "public"."cogs_reconciliation_by_range"(("date_trunc"('month'::"text", "now"()))::"date", ((("date_trunc"('month'::"text", "now"()))::"date" + '1 mon -1 days'::interval))::"date") "cogs_reconciliation_by_range"("item_id", "expected_cogs", "actual_cogs", "delta");


ALTER VIEW "public"."v_cogs_reconciliation" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_cogs_reconciliation" IS 'Purpose: COGS reconciliation for current month. Source of truth: inventory_movements (sale_out/wastage_out/expired_out) vs journal_entries/journal_lines posted to COGS account 5010 for the same movement source. Output: expected, actual, delta per item_id.';



CREATE OR REPLACE VIEW "public"."v_food_batch_balances" AS
 SELECT "item_id",
    "id" AS "batch_id",
    "warehouse_id",
    "expiry_date",
    COALESCE("quantity_received", (0)::numeric) AS "received_qty",
    COALESCE("quantity_consumed", (0)::numeric) AS "consumed_qty",
    GREATEST(((COALESCE("quantity_received", (0)::numeric) - COALESCE("quantity_consumed", (0)::numeric)) - COALESCE("quantity_transferred", (0)::numeric)), (0)::numeric) AS "remaining_qty"
   FROM "public"."batches" "b"
  WHERE ("id" IS NOT NULL);


ALTER VIEW "public"."v_food_batch_balances" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_note_expenses" WITH ("security_invoker"='true') AS
 SELECT "ap"."id" AS "period_id",
    "ap"."name" AS "period_name",
    "coa"."code" AS "account_code",
    "coa"."name" AS "account_name",
    COALESCE("sum"(("jl"."debit" - "jl"."credit")), (0)::numeric) AS "expense_amount"
   FROM ((("public"."journal_entries" "je"
     JOIN "public"."journal_lines" "jl" ON (("jl"."journal_entry_id" = "je"."id")))
     JOIN "public"."chart_of_accounts" "coa" ON (("coa"."id" = "jl"."account_id")))
     JOIN "public"."accounting_periods" "ap" ON (((("je"."entry_date")::"date" >= "ap"."start_date") AND (("je"."entry_date")::"date" <= "ap"."end_date"))))
  WHERE ("coa"."account_type" = 'expense'::"text")
  GROUP BY "ap"."id", "ap"."name", "coa"."code", "coa"."name"
 HAVING ("abs"(COALESCE("sum"(("jl"."debit" - "jl"."credit")), (0)::numeric)) > 0.000000001)
  ORDER BY "ap"."name", "coa"."code";


ALTER VIEW "public"."v_note_expenses" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_note_expenses" IS 'Purpose: Expense note (breakdown by expense accounts) per period. Source of truth: journal_entries/journal_lines grouped by accounting_periods.';



CREATE OR REPLACE VIEW "public"."v_note_inventory" WITH ("security_invoker"='true') AS
 WITH "inv" AS (
         SELECT "coa"."id"
           FROM "public"."chart_of_accounts" "coa"
          WHERE ("coa"."code" = '1410'::"text")
         LIMIT 1
        ), "lines" AS (
         SELECT "ap"."id" AS "period_id",
            "ap"."name" AS "period_name",
            "je"."source_event",
            COALESCE("sum"("jl"."debit"), (0)::numeric) AS "total_debit",
            COALESCE("sum"("jl"."credit"), (0)::numeric) AS "total_credit"
           FROM ((("public"."journal_entries" "je"
             JOIN "public"."journal_lines" "jl" ON (("jl"."journal_entry_id" = "je"."id")))
             JOIN "inv" ON (("inv"."id" = "jl"."account_id")))
             JOIN "public"."accounting_periods" "ap" ON (((("je"."entry_date")::"date" >= "ap"."start_date") AND (("je"."entry_date")::"date" <= "ap"."end_date"))))
          GROUP BY "ap"."id", "ap"."name", "je"."source_event"
        )
 SELECT "period_id",
    "period_name",
    "source_event",
    "total_debit",
    "total_credit"
   FROM "lines"
  ORDER BY "period_name", "source_event";


ALTER VIEW "public"."v_note_inventory" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_note_inventory" IS 'Purpose: Inventory note by period and source_event. Source of truth: journal_entries/journal_lines for Inventory account 1410 grouped by accounting_periods.';



CREATE OR REPLACE VIEW "public"."v_note_revenue" WITH ("security_invoker"='true') AS
 SELECT "ap"."id" AS "period_id",
    "ap"."name" AS "period_name",
    "coa"."code" AS "account_code",
    "coa"."name" AS "account_name",
    COALESCE("sum"(("jl"."credit" - "jl"."debit")), (0)::numeric) AS "revenue_amount"
   FROM ((("public"."journal_entries" "je"
     JOIN "public"."journal_lines" "jl" ON (("jl"."journal_entry_id" = "je"."id")))
     JOIN "public"."chart_of_accounts" "coa" ON (("coa"."id" = "jl"."account_id")))
     JOIN "public"."accounting_periods" "ap" ON (((("je"."entry_date")::"date" >= "ap"."start_date") AND (("je"."entry_date")::"date" <= "ap"."end_date"))))
  WHERE ("coa"."account_type" = 'income'::"text")
  GROUP BY "ap"."id", "ap"."name", "coa"."code", "coa"."name"
 HAVING ("abs"(COALESCE("sum"(("jl"."credit" - "jl"."debit")), (0)::numeric)) > 0.000000001)
  ORDER BY "ap"."name", "coa"."code";


ALTER VIEW "public"."v_note_revenue" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_note_revenue" IS 'Purpose: Revenue note (breakdown by income accounts) per period. Source of truth: journal_entries/journal_lines grouped by accounting_periods.';



CREATE OR REPLACE VIEW "public"."v_note_vat" WITH ("security_invoker"='true') AS
 SELECT "ap"."id" AS "period_id",
    "ap"."name" AS "period_name",
    "coa"."code" AS "vat_account_code",
    "coa"."name" AS "vat_account_name",
    COALESCE("sum"("jl"."debit"), (0)::numeric) AS "total_debit",
    COALESCE("sum"("jl"."credit"), (0)::numeric) AS "total_credit",
    COALESCE("sum"(
        CASE
            WHEN ("coa"."normal_balance" = 'debit'::"text") THEN ("jl"."debit" - "jl"."credit")
            ELSE ("jl"."credit" - "jl"."debit")
        END), (0)::numeric) AS "net_balance"
   FROM ((("public"."journal_entries" "je"
     JOIN "public"."journal_lines" "jl" ON (("jl"."journal_entry_id" = "je"."id")))
     JOIN "public"."chart_of_accounts" "coa" ON (("coa"."id" = "jl"."account_id")))
     JOIN "public"."accounting_periods" "ap" ON (((("je"."entry_date")::"date" >= "ap"."start_date") AND (("je"."entry_date")::"date" <= "ap"."end_date"))))
  WHERE ("coa"."code" = ANY (ARRAY['1420'::"text", '2020'::"text"]))
  GROUP BY "ap"."id", "ap"."name", "coa"."code", "coa"."name", "coa"."normal_balance"
  ORDER BY "ap"."name", "coa"."code";


ALTER VIEW "public"."v_note_vat" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_note_vat" IS 'Purpose: VAT disclosure by period for VAT receivable (1420) and VAT payable (2020). Source of truth: journal_entries/journal_lines grouped by accounting_periods.';



CREATE OR REPLACE VIEW "public"."v_profit_and_loss" WITH ("security_invoker"='true') AS
 SELECT "statement_section",
    "account_code",
    "account_name",
    "amount"
   FROM "public"."profit_and_loss_by_range"(("date_trunc"('month'::"text", "now"()))::"date", ((("date_trunc"('month'::"text", "now"()))::"date" + '1 mon -1 days'::interval))::"date") "profit_and_loss_by_range"("statement_section", "account_code", "account_name", "amount");


ALTER VIEW "public"."v_profit_and_loss" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_profit_and_loss" IS 'Purpose: Profit & Loss for current month. Source of truth: journal_entries/journal_lines filtered by entry_date::date range; closed periods are protected by Phase 10 period lock. Output: account rows grouped into Revenue/COGS/Operating Expenses.';



CREATE OR REPLACE VIEW "public"."v_sellable_products" WITH ("security_invoker"='false') AS
 WITH "stock" AS (
         SELECT "sm"."item_id",
            "sum"(COALESCE("sm"."available_quantity", (0)::numeric)) AS "available_quantity"
           FROM "public"."stock_management" "sm"
          GROUP BY "sm"."item_id"
        ), "valid_batches" AS (
         SELECT "b"."item_id",
            "bool_or"(((GREATEST(((COALESCE("b"."quantity_received", (0)::numeric) - COALESCE("b"."quantity_consumed", (0)::numeric)) - COALESCE("b"."quantity_transferred", (0)::numeric)), (0)::numeric) > (0)::numeric) AND (COALESCE("b"."status", 'active'::"text") = 'active'::"text") AND (COALESCE("b"."qc_status", ''::"text") = 'released'::"text") AND (NOT (EXISTS ( SELECT 1
                   FROM "public"."batch_recalls" "br"
                  WHERE (("br"."batch_id" = "b"."id") AND ("br"."status" = 'active'::"text"))))) AND (("b"."expiry_date" IS NULL) OR ("b"."expiry_date" >= CURRENT_DATE)))) AS "has_valid_batch"
           FROM "public"."batches" "b"
          GROUP BY "b"."item_id"
        )
 SELECT "mi"."id",
    "mi"."name",
    "mi"."barcode",
    "mi"."price",
    "mi"."base_unit",
    "mi"."is_food",
    "mi"."expiry_required",
    "mi"."sellable",
    "mi"."status",
    COALESCE("s"."available_quantity", (0)::numeric) AS "available_quantity",
    "mi"."category",
    "mi"."group_key",
    "mi"."is_featured",
    "mi"."freshness_level",
    "mi"."data"
   FROM (("public"."menu_items" "mi"
     LEFT JOIN "stock" "s" ON (("s"."item_id" = "mi"."id")))
     LEFT JOIN "valid_batches" "vb" ON (("vb"."item_id" = "mi"."id")))
  WHERE (("mi"."status" = 'active'::"text") AND ("mi"."sellable" = true) AND (COALESCE("s"."available_quantity", (0)::numeric) > (0)::numeric) AND (("mi"."expiry_required" = false) OR (COALESCE("vb"."has_valid_batch", false) = true)));


ALTER VIEW "public"."v_sellable_products" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_trial_balance" WITH ("security_invoker"='true') AS
 SELECT "account_code",
    "account_name",
    "account_type",
    "normal_balance",
    "opening_balance",
    "total_debits",
    "total_credits",
    "closing_balance"
   FROM "public"."trial_balance_by_range"(("date_trunc"('month'::"text", "now"()))::"date", ((("date_trunc"('month'::"text", "now"()))::"date" + '1 mon -1 days'::interval))::"date") "trial_balance_by_range"("account_code", "account_name", "account_type", "normal_balance", "opening_balance", "total_debits", "total_credits", "closing_balance");


ALTER VIEW "public"."v_trial_balance" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_trial_balance" IS 'Purpose: Trial balance for current month with opening/period/closing. Source of truth: journal_entries/journal_lines with signed balances by normal_balance. Output: one row per account.';



CREATE OR REPLACE VIEW "public"."v_trial_balance_totals" WITH ("security_invoker"='true') AS
 WITH "tb" AS (
         SELECT "v_trial_balance"."account_code",
            "v_trial_balance"."account_name",
            "v_trial_balance"."account_type",
            "v_trial_balance"."normal_balance",
            "v_trial_balance"."opening_balance",
            "v_trial_balance"."total_debits",
            "v_trial_balance"."total_credits",
            "v_trial_balance"."closing_balance"
           FROM "public"."v_trial_balance"
        )
 SELECT COALESCE("sum"("total_debits"), (0)::numeric) AS "sum_debits",
    COALESCE("sum"("total_credits"), (0)::numeric) AS "sum_credits",
    (COALESCE("sum"("total_debits"), (0)::numeric) - COALESCE("sum"("total_credits"), (0)::numeric)) AS "discrepancy"
   FROM "tb";


ALTER VIEW "public"."v_trial_balance_totals" OWNER TO "postgres";


COMMENT ON VIEW "public"."v_trial_balance_totals" IS 'Purpose: Trial balance control totals for current month. Source of truth: v_trial_balance. Output: sum_debits, sum_credits, discrepancy.';



CREATE TABLE IF NOT EXISTS "public"."warehouse_transfer_items" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "transfer_id" "uuid" NOT NULL,
    "item_id" "text" NOT NULL,
    "quantity" numeric NOT NULL,
    "transferred_quantity" numeric DEFAULT 0,
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "batch_id" "uuid",
    CONSTRAINT "warehouse_transfer_items_quantity_check" CHECK (("quantity" > (0)::numeric)),
    CONSTRAINT "warehouse_transfer_items_transferred_quantity_check" CHECK (("transferred_quantity" >= (0)::numeric))
);


ALTER TABLE "public"."warehouse_transfer_items" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."warehouse_transfers" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "transfer_number" "text" NOT NULL,
    "from_warehouse_id" "uuid" NOT NULL,
    "to_warehouse_id" "uuid" NOT NULL,
    "transfer_date" "date" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "notes" "text",
    "created_by" "uuid",
    "approved_by" "uuid",
    "completed_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "warehouse_transfers_check" CHECK (("from_warehouse_id" <> "to_warehouse_id")),
    CONSTRAINT "warehouse_transfers_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'in_transit'::"text", 'completed'::"text", 'cancelled'::"text"])))
);


ALTER TABLE "public"."warehouse_transfers" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."warehouses" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "code" "text" NOT NULL,
    "name" "text" NOT NULL,
    "type" "text" NOT NULL,
    "location" "text",
    "address" "text",
    "manager_id" "uuid",
    "phone" "text",
    "is_active" boolean DEFAULT true,
    "capacity_limit" numeric,
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "company_id" "uuid",
    "branch_id" "uuid",
    "pricing" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    CONSTRAINT "warehouses_type_check" CHECK (("type" = ANY (ARRAY['main'::"text", 'branch'::"text", 'incoming'::"text", 'cold_storage'::"text"])))
);


ALTER TABLE "public"."warehouses" OWNER TO "postgres";


ALTER TABLE ONLY "public"."accounting_documents"
    ADD CONSTRAINT "accounting_documents_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."accounting_light_entries"
    ADD CONSTRAINT "accounting_light_entries_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."accounting_period_snapshots"
    ADD CONSTRAINT "accounting_period_snapshots_pkey" PRIMARY KEY ("period_id", "account_id");



ALTER TABLE ONLY "public"."accounting_periods"
    ADD CONSTRAINT "accounting_periods_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."addons"
    ADD CONSTRAINT "addons_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."admin_users"
    ADD CONSTRAINT "admin_users_pkey" PRIMARY KEY ("auth_user_id");



ALTER TABLE ONLY "public"."admin_users"
    ADD CONSTRAINT "admin_users_username_key" UNIQUE ("username");



ALTER TABLE ONLY "public"."ads"
    ADD CONSTRAINT "ads_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."app_settings"
    ADD CONSTRAINT "app_settings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."approval_policies"
    ADD CONSTRAINT "approval_policies_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."approval_policy_steps"
    ADD CONSTRAINT "approval_policy_steps_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."approval_requests"
    ADD CONSTRAINT "approval_requests_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."approval_steps"
    ADD CONSTRAINT "approval_steps_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ar_allocations"
    ADD CONSTRAINT "ar_allocations_open_item_id_payment_id_key" UNIQUE ("open_item_id", "payment_id");



ALTER TABLE ONLY "public"."ar_allocations"
    ADD CONSTRAINT "ar_allocations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ar_open_items"
    ADD CONSTRAINT "ar_open_items_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ar_payment_status"
    ADD CONSTRAINT "ar_payment_status_payment_id_key" UNIQUE ("payment_id");



ALTER TABLE ONLY "public"."ar_payment_status"
    ADD CONSTRAINT "ar_payment_status_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."banks"
    ADD CONSTRAINT "banks_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."batch_balances"
    ADD CONSTRAINT "batch_balances_pkey" PRIMARY KEY ("item_id", "batch_id", "warehouse_id");



ALTER TABLE ONLY "public"."batch_recalls"
    ADD CONSTRAINT "batch_recalls_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."batch_reservations"
    ADD CONSTRAINT "batch_reservations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."batch_sales_trace"
    ADD CONSTRAINT "batch_sales_trace_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."batches"
    ADD CONSTRAINT "batches_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."branches"
    ADD CONSTRAINT "branches_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."cash_shifts"
    ADD CONSTRAINT "cash_shifts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."challenges"
    ADD CONSTRAINT "challenges_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."chart_of_accounts"
    ADD CONSTRAINT "chart_of_accounts_code_key" UNIQUE ("code");



ALTER TABLE ONLY "public"."chart_of_accounts"
    ADD CONSTRAINT "chart_of_accounts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."cod_settlement_orders"
    ADD CONSTRAINT "cod_settlement_orders_pkey" PRIMARY KEY ("settlement_id", "order_id");



ALTER TABLE ONLY "public"."cod_settlements"
    ADD CONSTRAINT "cod_settlements_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."companies"
    ADD CONSTRAINT "companies_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."cost_centers"
    ADD CONSTRAINT "cost_centers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."coupons"
    ADD CONSTRAINT "coupons_code_key" UNIQUE ("code");



ALTER TABLE ONLY "public"."coupons"
    ADD CONSTRAINT "coupons_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."currencies"
    ADD CONSTRAINT "currencies_pkey" PRIMARY KEY ("code");



ALTER TABLE ONLY "public"."customer_special_prices"
    ADD CONSTRAINT "customer_special_prices_customer_id_item_id_key" UNIQUE ("customer_id", "item_id");



ALTER TABLE ONLY "public"."customer_special_prices"
    ADD CONSTRAINT "customer_special_prices_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."customer_tax_profiles"
    ADD CONSTRAINT "customer_tax_profiles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."customers"
    ADD CONSTRAINT "customers_email_key" UNIQUE ("email");



ALTER TABLE ONLY "public"."customers"
    ADD CONSTRAINT "customers_phone_number_key" UNIQUE ("phone_number");



ALTER TABLE ONLY "public"."customers"
    ADD CONSTRAINT "customers_pkey" PRIMARY KEY ("auth_user_id");



ALTER TABLE ONLY "public"."customers"
    ADD CONSTRAINT "customers_referral_code_key" UNIQUE ("referral_code");



ALTER TABLE ONLY "public"."delivery_zones"
    ADD CONSTRAINT "delivery_zones_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."driver_ledger"
    ADD CONSTRAINT "driver_ledger_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."expenses"
    ADD CONSTRAINT "expenses_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."freshness_levels"
    ADD CONSTRAINT "freshness_levels_key_key" UNIQUE ("key");



ALTER TABLE ONLY "public"."freshness_levels"
    ADD CONSTRAINT "freshness_levels_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."fx_rates"
    ADD CONSTRAINT "fx_rates_currency_code_rate_date_rate_type_key" UNIQUE ("currency_code", "rate_date", "rate_type");



ALTER TABLE ONLY "public"."fx_rates"
    ADD CONSTRAINT "fx_rates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."fx_revaluation_audit"
    ADD CONSTRAINT "fx_revaluation_audit_period_end_entity_type_entity_id_key" UNIQUE ("period_end", "entity_type", "entity_id");



ALTER TABLE ONLY "public"."fx_revaluation_audit"
    ADD CONSTRAINT "fx_revaluation_audit_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."import_expenses"
    ADD CONSTRAINT "import_expenses_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."import_shipments_items"
    ADD CONSTRAINT "import_shipments_items_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."import_shipments"
    ADD CONSTRAINT "import_shipments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."import_shipments"
    ADD CONSTRAINT "import_shipments_reference_number_key" UNIQUE ("reference_number");



ALTER TABLE ONLY "public"."inventory_movements"
    ADD CONSTRAINT "inventory_movements_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."inventory_transfer_items"
    ADD CONSTRAINT "inventory_transfer_items_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."inventory_transfers"
    ADD CONSTRAINT "inventory_transfers_create_idempotency_key_key" UNIQUE ("create_idempotency_key");



ALTER TABLE ONLY "public"."inventory_transfers"
    ADD CONSTRAINT "inventory_transfers_dispatch_idempotency_key_key" UNIQUE ("dispatch_idempotency_key");



ALTER TABLE ONLY "public"."inventory_transfers"
    ADD CONSTRAINT "inventory_transfers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."inventory_transfers"
    ADD CONSTRAINT "inventory_transfers_receive_idempotency_key_key" UNIQUE ("receive_idempotency_key");



ALTER TABLE ONLY "public"."inventory_transfers"
    ADD CONSTRAINT "inventory_transfers_transfer_number_key" UNIQUE ("transfer_number");



ALTER TABLE ONLY "public"."invoice_tolerances"
    ADD CONSTRAINT "invoice_tolerances_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."item_categories"
    ADD CONSTRAINT "item_categories_key_key" UNIQUE ("key");



ALTER TABLE ONLY "public"."item_categories"
    ADD CONSTRAINT "item_categories_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."item_groups"
    ADD CONSTRAINT "item_groups_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."item_tax_profiles"
    ADD CONSTRAINT "item_tax_profiles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."item_uom"
    ADD CONSTRAINT "item_uom_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."job_runs"
    ADD CONSTRAINT "job_runs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."job_schedules"
    ADD CONSTRAINT "job_schedules_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."journal_entries"
    ADD CONSTRAINT "journal_entries_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."journal_lines"
    ADD CONSTRAINT "journal_lines_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."landed_cost_audit"
    ADD CONSTRAINT "landed_cost_audit_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."landed_cost_audit"
    ADD CONSTRAINT "landed_cost_audit_shipment_id_key" UNIQUE ("shipment_id");



ALTER TABLE ONLY "public"."ledger_audit_log"
    ADD CONSTRAINT "ledger_audit_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ledger_entries"
    ADD CONSTRAINT "ledger_entries_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ledger_lines"
    ADD CONSTRAINT "ledger_lines_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."menu_items"
    ADD CONSTRAINT "menu_items_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."notifications"
    ADD CONSTRAINT "notifications_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."order_events"
    ADD CONSTRAINT "order_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."order_item_cogs"
    ADD CONSTRAINT "order_item_cogs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."order_item_reservations"
    ADD CONSTRAINT "order_item_reservations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."order_line_items"
    ADD CONSTRAINT "order_line_items_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."order_tax_lines"
    ADD CONSTRAINT "order_tax_lines_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."orders"
    ADD CONSTRAINT "orders_pkey" PRIMARY KEY ("id");



ALTER TABLE "public"."payments"
    ADD CONSTRAINT "payments_cash_requires_shift" CHECK ((("method" <> 'cash'::"text") OR ("shift_id" IS NOT NULL))) NOT VALID;



ALTER TABLE ONLY "public"."payments"
    ADD CONSTRAINT "payments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."pos_offline_sales"
    ADD CONSTRAINT "pos_offline_sales_offline_id_key" UNIQUE ("offline_id");



ALTER TABLE ONLY "public"."pos_offline_sales"
    ADD CONSTRAINT "pos_offline_sales_order_id_key" UNIQUE ("order_id");



ALTER TABLE ONLY "public"."pos_offline_sales"
    ADD CONSTRAINT "pos_offline_sales_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."price_history"
    ADD CONSTRAINT "price_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."price_tiers"
    ADD CONSTRAINT "price_tiers_item_id_customer_type_min_quantity_key" UNIQUE ("item_id", "customer_type", "min_quantity");



ALTER TABLE ONLY "public"."price_tiers"
    ADD CONSTRAINT "price_tiers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."product_audit_log"
    ADD CONSTRAINT "product_audit_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."production_order_inputs"
    ADD CONSTRAINT "production_order_inputs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."production_order_outputs"
    ADD CONSTRAINT "production_order_outputs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."production_orders"
    ADD CONSTRAINT "production_orders_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."promotion_items"
    ADD CONSTRAINT "promotion_items_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."promotion_items"
    ADD CONSTRAINT "promotion_items_promotion_id_item_id_key" UNIQUE ("promotion_id", "item_id");



ALTER TABLE ONLY "public"."promotion_usage"
    ADD CONSTRAINT "promotion_usage_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."promotion_usage"
    ADD CONSTRAINT "promotion_usage_promotion_line_id_key" UNIQUE ("promotion_line_id");



ALTER TABLE ONLY "public"."promotions"
    ADD CONSTRAINT "promotions_pkey" PRIMARY KEY ("id");



ALTER TABLE "public"."inventory_movements"
    ADD CONSTRAINT "purchase_in_requires_batch" CHECK ((("movement_type" <> 'purchase_in'::"text") OR ("batch_id" IS NOT NULL))) NOT VALID;



ALTER TABLE ONLY "public"."purchase_items"
    ADD CONSTRAINT "purchase_items_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."purchase_orders"
    ADD CONSTRAINT "purchase_orders_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."purchase_receipt_items"
    ADD CONSTRAINT "purchase_receipt_items_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."purchase_receipts"
    ADD CONSTRAINT "purchase_receipts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."purchase_return_items"
    ADD CONSTRAINT "purchase_return_items_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."purchase_returns"
    ADD CONSTRAINT "purchase_returns_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."qc_checks"
    ADD CONSTRAINT "qc_checks_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."reviews"
    ADD CONSTRAINT "reviews_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."sales_returns"
    ADD CONSTRAINT "sales_returns_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."stock_history"
    ADD CONSTRAINT "stock_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."stock_management"
    ADD CONSTRAINT "stock_management_pkey" PRIMARY KEY ("item_id");



ALTER TABLE ONLY "public"."stock_wastage"
    ADD CONSTRAINT "stock_wastage_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."supplier_contracts"
    ADD CONSTRAINT "supplier_contracts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."supplier_credit_note_allocations"
    ADD CONSTRAINT "supplier_credit_note_allocations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."supplier_credit_notes"
    ADD CONSTRAINT "supplier_credit_notes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."supplier_evaluations"
    ADD CONSTRAINT "supplier_evaluations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."supplier_invoice_lines"
    ADD CONSTRAINT "supplier_invoice_lines_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."supplier_invoices"
    ADD CONSTRAINT "supplier_invoices_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."suppliers"
    ADD CONSTRAINT "suppliers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."system_audit_logs"
    ADD CONSTRAINT "system_audit_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."tax_jurisdictions"
    ADD CONSTRAINT "tax_jurisdictions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."tax_rates"
    ADD CONSTRAINT "tax_rates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."three_way_match_results"
    ADD CONSTRAINT "three_way_match_results_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."transfer_recipients"
    ADD CONSTRAINT "transfer_recipients_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."unit_types"
    ADD CONSTRAINT "unit_types_key_key" UNIQUE ("key");



ALTER TABLE ONLY "public"."unit_types"
    ADD CONSTRAINT "unit_types_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."uom_conversions"
    ADD CONSTRAINT "uom_conversions_from_uom_id_to_uom_id_key" UNIQUE ("from_uom_id", "to_uom_id");



ALTER TABLE ONLY "public"."uom_conversions"
    ADD CONSTRAINT "uom_conversions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."uom"
    ADD CONSTRAINT "uom_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_challenge_progress"
    ADD CONSTRAINT "user_challenge_progress_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."warehouse_transfer_items"
    ADD CONSTRAINT "warehouse_transfer_items_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."warehouse_transfers"
    ADD CONSTRAINT "warehouse_transfers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."warehouse_transfers"
    ADD CONSTRAINT "warehouse_transfers_transfer_number_key" UNIQUE ("transfer_number");



ALTER TABLE ONLY "public"."warehouses"
    ADD CONSTRAINT "warehouses_code_key" UNIQUE ("code");



ALTER TABLE ONLY "public"."warehouses"
    ADD CONSTRAINT "warehouses_pkey" PRIMARY KEY ("id");



CREATE UNIQUE INDEX "idx_accounting_documents_source" ON "public"."accounting_documents" USING "btree" ("source_table", "source_id");



CREATE INDEX "idx_accounting_light_entries_batch" ON "public"."accounting_light_entries" USING "btree" ("batch_id");



CREATE INDEX "idx_accounting_light_entries_date" ON "public"."accounting_light_entries" USING "btree" ("occurred_at");



CREATE INDEX "idx_accounting_light_entries_item" ON "public"."accounting_light_entries" USING "btree" ("item_id");



CREATE INDEX "idx_accounting_light_entries_wh" ON "public"."accounting_light_entries" USING "btree" ("warehouse_id");



CREATE INDEX "idx_addons_name" ON "public"."addons" USING "btree" ("name");



CREATE INDEX "idx_ads_display_order" ON "public"."ads" USING "btree" ("display_order");



CREATE INDEX "idx_ads_status" ON "public"."ads" USING "btree" ("status");



CREATE INDEX "idx_approval_policies_type" ON "public"."approval_policies" USING "btree" ("request_type", "is_active");



CREATE UNIQUE INDEX "idx_approval_policy_steps_policy_step" ON "public"."approval_policy_steps" USING "btree" ("policy_id", "step_no");



CREATE INDEX "idx_approval_requests_status" ON "public"."approval_requests" USING "btree" ("status");



CREATE INDEX "idx_approval_requests_target" ON "public"."approval_requests" USING "btree" ("target_table", "target_id");



CREATE UNIQUE INDEX "idx_approval_steps_request_step" ON "public"."approval_steps" USING "btree" ("request_id", "step_no");



CREATE INDEX "idx_batch_balances_expiry" ON "public"."batch_balances" USING "btree" ("warehouse_id", "expiry_date");



CREATE INDEX "idx_batch_balances_item" ON "public"."batch_balances" USING "btree" ("item_id", "warehouse_id");



CREATE INDEX "idx_batch_balances_item_wh" ON "public"."batch_balances" USING "btree" ("item_id", "warehouse_id");



CREATE INDEX "idx_batch_reservations_item_wh" ON "public"."batch_reservations" USING "btree" ("item_id", "warehouse_id");



CREATE INDEX "idx_batch_reservations_order" ON "public"."batch_reservations" USING "btree" ("order_id");



CREATE INDEX "idx_batch_sales_trace_batch" ON "public"."batch_sales_trace" USING "btree" ("batch_id");



CREATE INDEX "idx_batches_fefo" ON "public"."batches" USING "btree" ("item_id", "warehouse_id", "expiry_date", "created_at");



CREATE INDEX "idx_batches_item_expiry" ON "public"."batches" USING "btree" ("item_id", "expiry_date");



CREATE INDEX "idx_batches_remaining" ON "public"."batches" USING "btree" ((("quantity_received" - "quantity_consumed")));



CREATE INDEX "idx_batches_wh_item" ON "public"."batches" USING "btree" ("warehouse_id", "item_id");



CREATE UNIQUE INDEX "idx_branches_code" ON "public"."branches" USING "btree" ("company_id", "code");



CREATE INDEX "idx_cash_shifts_cashier_id" ON "public"."cash_shifts" USING "btree" ("cashier_id");



CREATE INDEX "idx_cash_shifts_opened_at" ON "public"."cash_shifts" USING "btree" ("opened_at");



CREATE INDEX "idx_cash_shifts_status" ON "public"."cash_shifts" USING "btree" ("status");



CREATE INDEX "idx_challenges_end_date" ON "public"."challenges" USING "btree" ("end_date");



CREATE INDEX "idx_challenges_status" ON "public"."challenges" USING "btree" ("status");



CREATE INDEX "idx_coa_code_active" ON "public"."chart_of_accounts" USING "btree" ("code", "is_active");



CREATE INDEX "idx_cod_settlement_orders_order_id" ON "public"."cod_settlement_orders" USING "btree" ("order_id");



CREATE INDEX "idx_cod_settlements_driver_time" ON "public"."cod_settlements" USING "btree" ("driver_id", "occurred_at" DESC);



CREATE INDEX "idx_coupons_active" ON "public"."coupons" USING "btree" ("is_active");



CREATE INDEX "idx_coupons_code" ON "public"."coupons" USING "btree" ("code");



CREATE INDEX "idx_customers_preferred_currency" ON "public"."customers" USING "btree" ("preferred_currency");



CREATE INDEX "idx_customers_type" ON "public"."customers" USING "btree" ("customer_type");



CREATE INDEX "idx_delivery_zones_active" ON "public"."delivery_zones" USING "btree" ("is_active");



CREATE INDEX "idx_driver_ledger_driver_time" ON "public"."driver_ledger" USING "btree" ("driver_id", "occurred_at" DESC);



CREATE INDEX "idx_import_expenses_shipment" ON "public"."import_expenses" USING "btree" ("shipment_id");



CREATE INDEX "idx_import_items_shipment" ON "public"."import_shipments_items" USING "btree" ("shipment_id");



CREATE INDEX "idx_import_shipments_status" ON "public"."import_shipments" USING "btree" ("status");



CREATE INDEX "idx_import_shipments_supplier" ON "public"."import_shipments" USING "btree" ("supplier_id");



CREATE INDEX "idx_inventory_movements_batch" ON "public"."inventory_movements" USING "btree" ("batch_id");



CREATE INDEX "idx_inventory_movements_item_date" ON "public"."inventory_movements" USING "btree" ("item_id", "occurred_at" DESC);



CREATE INDEX "idx_inventory_movements_ref" ON "public"."inventory_movements" USING "btree" ("reference_table", "reference_id");



CREATE INDEX "idx_inventory_movements_warehouse" ON "public"."inventory_movements" USING "btree" ("warehouse_id");



CREATE INDEX "idx_inventory_movements_warehouse_batch" ON "public"."inventory_movements" USING "btree" ("warehouse_id", "batch_id");



CREATE INDEX "idx_inventory_movements_warehouse_item_date" ON "public"."inventory_movements" USING "btree" ("warehouse_id", "item_id", "occurred_at" DESC);



CREATE INDEX "idx_inventory_transfer_items_received_batch" ON "public"."inventory_transfer_items" USING "btree" ("received_batch_id");



CREATE INDEX "idx_inventory_transfer_items_source_batch" ON "public"."inventory_transfer_items" USING "btree" ("source_batch_id");



CREATE INDEX "idx_inventory_transfer_items_transfer" ON "public"."inventory_transfer_items" USING "btree" ("transfer_id");



CREATE INDEX "idx_inventory_transfers_from_to" ON "public"."inventory_transfers" USING "btree" ("from_warehouse_id", "to_warehouse_id", "created_at" DESC);



CREATE INDEX "idx_inventory_transfers_state_date" ON "public"."inventory_transfers" USING "btree" ("state", "transfer_date" DESC);



CREATE INDEX "idx_item_groups_category_key" ON "public"."item_groups" USING "btree" ("category_key");



CREATE UNIQUE INDEX "idx_item_groups_category_key_key" ON "public"."item_groups" USING "btree" ("category_key", "key");



CREATE UNIQUE INDEX "idx_item_uom_item" ON "public"."item_uom" USING "btree" ("item_id");



CREATE INDEX "idx_journal_entries_entry_date" ON "public"."journal_entries" USING "btree" ("entry_date");



CREATE INDEX "idx_journal_entries_source_table_entry_date" ON "public"."journal_entries" USING "btree" ("source_table", "entry_date");



CREATE INDEX "idx_journal_lines_account" ON "public"."journal_lines" USING "btree" ("account_id");



CREATE INDEX "idx_journal_lines_entry" ON "public"."journal_lines" USING "btree" ("journal_entry_id");



CREATE INDEX "idx_ledger_audit_log_created_at" ON "public"."ledger_audit_log" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_ledger_audit_log_table_record" ON "public"."ledger_audit_log" USING "btree" ("table_name", "record_id");



CREATE INDEX "idx_ledger_entries_ref" ON "public"."ledger_entries" USING "btree" ("reference_type", "reference_id");



CREATE INDEX "idx_ledger_lines_account" ON "public"."ledger_lines" USING "btree" ("account");



CREATE INDEX "idx_ledger_lines_entry_id" ON "public"."ledger_lines" USING "btree" ("entry_id");



CREATE INDEX "idx_menu_items_category" ON "public"."menu_items" USING "btree" ("category");



CREATE INDEX "idx_menu_items_featured" ON "public"."menu_items" USING "btree" ("is_featured");



CREATE INDEX "idx_menu_items_freshness_level" ON "public"."menu_items" USING "btree" ("freshness_level");



CREATE INDEX "idx_menu_items_group_key" ON "public"."menu_items" USING "btree" ("group_key");



CREATE INDEX "idx_menu_items_unit_type" ON "public"."menu_items" USING "btree" ("unit_type");



CREATE INDEX "idx_notifications_user_unread" ON "public"."notifications" USING "btree" ("user_id") WHERE ("is_read" = false);



CREATE INDEX "idx_order_events_action" ON "public"."order_events" USING "btree" ("action");



CREATE INDEX "idx_order_events_order_created" ON "public"."order_events" USING "btree" ("order_id", "created_at" DESC);



CREATE INDEX "idx_order_item_cogs_created_at" ON "public"."order_item_cogs" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_order_item_cogs_item" ON "public"."order_item_cogs" USING "btree" ("item_id");



CREATE INDEX "idx_order_item_cogs_order" ON "public"."order_item_cogs" USING "btree" ("order_id");



CREATE INDEX "idx_order_item_reservations_item_wh" ON "public"."order_item_reservations" USING "btree" ("item_id", "warehouse_id");



CREATE INDEX "idx_order_item_reservations_order" ON "public"."order_item_reservations" USING "btree" ("order_id");



CREATE INDEX "idx_order_line_items_order" ON "public"."order_line_items" USING "btree" ("order_id");



CREATE INDEX "idx_orders_customer_created" ON "public"."orders" USING "btree" ("customer_auth_user_id", "created_at" DESC);



CREATE INDEX "idx_orders_delivery_zone_id" ON "public"."orders" USING "btree" ("delivery_zone_id");



CREATE INDEX "idx_orders_status" ON "public"."orders" USING "btree" ("status");



CREATE INDEX "idx_orders_status_updated_at" ON "public"."orders" USING "btree" ("status", "updated_at");



CREATE INDEX "idx_payments_method" ON "public"."payments" USING "btree" ("method");



CREATE INDEX "idx_payments_occurred_at" ON "public"."payments" USING "btree" ("occurred_at" DESC);



CREATE INDEX "idx_payments_ref_dir" ON "public"."payments" USING "btree" ("reference_table", "reference_id", "direction");



CREATE INDEX "idx_payments_ref_dir_occurred_at" ON "public"."payments" USING "btree" ("reference_table", "direction", "occurred_at");



CREATE INDEX "idx_payments_reference" ON "public"."payments" USING "btree" ("reference_table", "reference_id");



CREATE INDEX "idx_payments_shift_id" ON "public"."payments" USING "btree" ("shift_id");



CREATE INDEX "idx_pos_offline_sales_order" ON "public"."pos_offline_sales" USING "btree" ("order_id");



CREATE INDEX "idx_pos_offline_sales_state_created" ON "public"."pos_offline_sales" USING "btree" ("state", "created_at" DESC);



CREATE INDEX "idx_price_history_item_date" ON "public"."price_history" USING "btree" ("item_id", "date" DESC);



CREATE INDEX "idx_price_tiers_active" ON "public"."price_tiers" USING "btree" ("is_active");



CREATE INDEX "idx_price_tiers_customer_type" ON "public"."price_tiers" USING "btree" ("customer_type");



CREATE INDEX "idx_price_tiers_item" ON "public"."price_tiers" USING "btree" ("item_id");



CREATE INDEX "idx_prod_inputs_order" ON "public"."production_order_inputs" USING "btree" ("order_id");



CREATE INDEX "idx_prod_outputs_order" ON "public"."production_order_outputs" USING "btree" ("order_id");



CREATE INDEX "idx_product_audit_log_item_id" ON "public"."product_audit_log" USING "btree" ("item_id");



CREATE INDEX "idx_product_audit_log_updated_at" ON "public"."product_audit_log" USING "btree" ("updated_at");



CREATE INDEX "idx_production_orders_date" ON "public"."production_orders" USING "btree" ("occurred_at" DESC);



CREATE INDEX "idx_promotion_items_item" ON "public"."promotion_items" USING "btree" ("item_id");



CREATE INDEX "idx_promotion_items_promotion" ON "public"."promotion_items" USING "btree" ("promotion_id", "sort_order", "created_at");



CREATE INDEX "idx_promotion_usage_order" ON "public"."promotion_usage" USING "btree" ("order_id");



CREATE INDEX "idx_promotion_usage_promotion_created" ON "public"."promotion_usage" USING "btree" ("promotion_id", "created_at" DESC);



CREATE INDEX "idx_promotions_active_window" ON "public"."promotions" USING "btree" ("is_active", "start_at", "end_at");



CREATE INDEX "idx_promotions_approval_status" ON "public"."promotions" USING "btree" ("approval_status");



CREATE INDEX "idx_purchase_items_item" ON "public"."purchase_items" USING "btree" ("item_id");



CREATE INDEX "idx_purchase_items_order" ON "public"."purchase_items" USING "btree" ("purchase_order_id");



CREATE UNIQUE INDEX "idx_purchase_orders_po_number_unique" ON "public"."purchase_orders" USING "btree" ("po_number");



CREATE UNIQUE INDEX "idx_purchase_orders_reference_number_unique" ON "public"."purchase_orders" USING "btree" ("reference_number") WHERE ("reference_number" IS NOT NULL);



CREATE INDEX "idx_purchase_orders_supplier" ON "public"."purchase_orders" USING "btree" ("supplier_id");



CREATE INDEX "idx_purchase_receipt_items_item" ON "public"."purchase_receipt_items" USING "btree" ("item_id");



CREATE INDEX "idx_purchase_receipt_items_receipt" ON "public"."purchase_receipt_items" USING "btree" ("receipt_id");



CREATE INDEX "idx_purchase_receipts_import_shipment" ON "public"."purchase_receipts" USING "btree" ("import_shipment_id");



CREATE INDEX "idx_purchase_receipts_po" ON "public"."purchase_receipts" USING "btree" ("purchase_order_id", "received_at" DESC);



CREATE INDEX "idx_purchase_return_items_item" ON "public"."purchase_return_items" USING "btree" ("item_id");



CREATE INDEX "idx_purchase_return_items_return" ON "public"."purchase_return_items" USING "btree" ("return_id");



CREATE INDEX "idx_purchase_returns_po" ON "public"."purchase_returns" USING "btree" ("purchase_order_id", "returned_at" DESC);



CREATE INDEX "idx_reviews_item_created" ON "public"."reviews" USING "btree" ("menu_item_id", "created_at" DESC);



CREATE INDEX "idx_reviews_user_created" ON "public"."reviews" USING "btree" ("customer_auth_user_id", "created_at" DESC);



CREATE INDEX "idx_sales_returns_order" ON "public"."sales_returns" USING "btree" ("order_id", "return_date" DESC);



CREATE INDEX "idx_special_prices_customer" ON "public"."customer_special_prices" USING "btree" ("customer_id");



CREATE INDEX "idx_special_prices_item" ON "public"."customer_special_prices" USING "btree" ("item_id");



CREATE INDEX "idx_stock_history_item_date" ON "public"."stock_history" USING "btree" ("item_id", "date" DESC);



CREATE UNIQUE INDEX "idx_stock_item_warehouse" ON "public"."stock_management" USING "btree" ("item_id", "warehouse_id");



CREATE INDEX "idx_stock_management_item" ON "public"."stock_management" USING "btree" ("item_id", "warehouse_id");



CREATE INDEX "idx_stock_management_last_updated" ON "public"."stock_management" USING "btree" ("last_updated" DESC);



CREATE INDEX "idx_stock_wastage_batch_date" ON "public"."stock_wastage" USING "btree" ("batch_id", "created_at" DESC);



CREATE INDEX "idx_stock_wastage_warehouse_date" ON "public"."stock_wastage" USING "btree" ("warehouse_id", "created_at" DESC);



CREATE INDEX "idx_supplier_credit_note_allocations_batch" ON "public"."supplier_credit_note_allocations" USING "btree" ("affected_batch_id");



CREATE INDEX "idx_supplier_credit_note_allocations_note" ON "public"."supplier_credit_note_allocations" USING "btree" ("credit_note_id", "created_at" DESC);



CREATE INDEX "idx_supplier_credit_notes_receipt" ON "public"."supplier_credit_notes" USING "btree" ("reference_purchase_receipt_id", "created_at" DESC);



CREATE INDEX "idx_supplier_credit_notes_supplier" ON "public"."supplier_credit_notes" USING "btree" ("supplier_id", "created_at" DESC);



CREATE INDEX "idx_supplier_invoice_lines_invoice" ON "public"."supplier_invoice_lines" USING "btree" ("invoice_id");



CREATE UNIQUE INDEX "idx_supplier_invoice_unique" ON "public"."supplier_invoices" USING "btree" ("supplier_id", "invoice_number");



CREATE UNIQUE INDEX "idx_suppliers_email" ON "public"."suppliers" USING "btree" ("email") WHERE ("email" IS NOT NULL);



CREATE UNIQUE INDEX "idx_suppliers_phone" ON "public"."suppliers" USING "btree" ("phone") WHERE ("phone" IS NOT NULL);



CREATE INDEX "idx_suppliers_preferred_currency" ON "public"."suppliers" USING "btree" ("preferred_currency");



CREATE UNIQUE INDEX "idx_suppliers_tax" ON "public"."suppliers" USING "btree" ("tax_number") WHERE ("tax_number" IS NOT NULL);



CREATE INDEX "idx_system_audit_logs_action_date" ON "public"."system_audit_logs" USING "btree" ("action", "performed_at" DESC);



CREATE INDEX "idx_system_audit_logs_module_date" ON "public"."system_audit_logs" USING "btree" ("module", "performed_at" DESC);



CREATE INDEX "idx_system_audit_logs_performed_at_desc" ON "public"."system_audit_logs" USING "btree" ("performed_at" DESC);



CREATE INDEX "idx_system_audit_logs_performed_by" ON "public"."system_audit_logs" USING "btree" ("performed_by", "performed_at" DESC);



CREATE INDEX "idx_three_way_match_invoice" ON "public"."three_way_match_results" USING "btree" ("invoice_id");



CREATE INDEX "idx_transfer_items_transfer" ON "public"."warehouse_transfer_items" USING "btree" ("transfer_id");



CREATE INDEX "idx_transfers_date" ON "public"."warehouse_transfers" USING "btree" ("transfer_date");



CREATE INDEX "idx_transfers_status" ON "public"."warehouse_transfers" USING "btree" ("status");



CREATE INDEX "idx_ucp_completed" ON "public"."user_challenge_progress" USING "btree" ("is_completed");



CREATE INDEX "idx_ucp_user_challenge" ON "public"."user_challenge_progress" USING "btree" ("customer_auth_user_id", "challenge_id");



CREATE UNIQUE INDEX "idx_uom_code" ON "public"."uom" USING "btree" ("code");



CREATE INDEX "idx_warehouses_active" ON "public"."warehouses" USING "btree" ("is_active");



CREATE INDEX "idx_warehouses_type" ON "public"."warehouses" USING "btree" ("type");



CREATE INDEX "idx_wastage_created_at" ON "public"."stock_wastage" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_wastage_item_date" ON "public"."stock_wastage" USING "btree" ("item_id", "created_at" DESC);



CREATE UNIQUE INDEX "menu_items_active_barcode_uniq" ON "public"."menu_items" USING "btree" ("lower"("btrim"("barcode"))) WHERE (("status" = 'active'::"text") AND ("barcode" IS NOT NULL) AND ("btrim"("barcode") <> ''::"text"));



CREATE UNIQUE INDEX "uniq_approval_requests_pending" ON "public"."approval_requests" USING "btree" ("target_table", "target_id", "request_type") WHERE ("status" = 'pending'::"text");



CREATE UNIQUE INDEX "uq_accounting_periods_range" ON "public"."accounting_periods" USING "btree" ("start_date", "end_date");



CREATE UNIQUE INDEX "uq_ar_open_item_invoice_open" ON "public"."ar_open_items" USING "btree" ("invoice_id") WHERE ("status" = 'open'::"text");



CREATE UNIQUE INDEX "uq_batch_reservation_order_item_batch_wh" ON "public"."batch_reservations" USING "btree" ("order_id", "item_id", "batch_id", "warehouse_id");



CREATE UNIQUE INDEX "uq_cash_shifts_open_per_cashier" ON "public"."cash_shifts" USING "btree" ("cashier_id") WHERE ("status" = 'open'::"text");



CREATE UNIQUE INDEX "uq_driver_ledger_ref" ON "public"."driver_ledger" USING "btree" ("driver_id", "reference_type", "reference_id");



CREATE UNIQUE INDEX "uq_inv_sale_out_order_item_batch_wh" ON "public"."inventory_movements" USING "btree" ("reference_table", "reference_id", "movement_type", "item_id", "batch_id", "warehouse_id") WHERE (("reference_table" = 'orders'::"text") AND ("movement_type" = 'sale_out'::"text"));



CREATE UNIQUE INDEX "uq_journal_entries_source" ON "public"."journal_entries" USING "btree" ("source_table", "source_id", "source_event");



CREATE UNIQUE INDEX "uq_journal_entries_source_strict" ON "public"."journal_entries" USING "btree" ("source_table", "source_id") WHERE (("source_table" IS NOT NULL) AND ("btrim"("source_table") <> ''::"text") AND ("source_table" <> 'manual'::"text") AND ("source_id" IS NOT NULL) AND ("btrim"("source_id") <> ''::"text"));



CREATE UNIQUE INDEX "uq_ledger_entries_ref" ON "public"."ledger_entries" USING "btree" ("entry_type", "reference_type", "reference_id");



CREATE UNIQUE INDEX "uq_order_item_reservations_order_item_wh_batch" ON "public"."order_item_reservations" USING "btree" ("order_id", "item_id", "warehouse_id", "batch_id");



CREATE UNIQUE INDEX "uq_payments_reference_idempotency" ON "public"."payments" USING "btree" ("reference_table", "reference_id", "direction", "idempotency_key");



CREATE UNIQUE INDEX "uq_purchase_receipts_idempotency" ON "public"."purchase_receipts" USING "btree" ("purchase_order_id", "idempotency_key") WHERE (("idempotency_key" IS NOT NULL) AND ("btrim"("idempotency_key") <> ''::"text"));



CREATE OR REPLACE TRIGGER "check_period_cash_shifts" BEFORE INSERT OR DELETE OR UPDATE ON "public"."cash_shifts" FOR EACH ROW EXECUTE FUNCTION "public"."trg_check_shift_closed_period"();



CREATE OR REPLACE TRIGGER "check_period_expenses" BEFORE INSERT OR DELETE OR UPDATE ON "public"."expenses" FOR EACH ROW EXECUTE FUNCTION "public"."trg_check_simple_date_closed_period"('date');



CREATE OR REPLACE TRIGGER "check_period_inventory_movements" BEFORE INSERT OR DELETE OR UPDATE ON "public"."inventory_movements" FOR EACH ROW EXECUTE FUNCTION "public"."trg_check_simple_date_closed_period"('occurred_at');



CREATE OR REPLACE TRIGGER "check_period_orders" BEFORE INSERT OR DELETE OR UPDATE ON "public"."orders" FOR EACH ROW EXECUTE FUNCTION "public"."trg_check_order_closed_period"();



CREATE OR REPLACE TRIGGER "check_period_payments" BEFORE INSERT OR DELETE OR UPDATE ON "public"."payments" FOR EACH ROW EXECUTE FUNCTION "public"."trg_check_simple_date_closed_period"('occurred_at');



CREATE OR REPLACE TRIGGER "check_period_purchase_orders" BEFORE INSERT OR DELETE OR UPDATE ON "public"."purchase_orders" FOR EACH ROW EXECUTE FUNCTION "public"."trg_check_po_closed_period"();



CREATE OR REPLACE TRIGGER "trg_accounting_documents_immutable" BEFORE DELETE OR UPDATE ON "public"."accounting_documents" FOR EACH ROW EXECUTE FUNCTION "public"."trg_immutable_block"();



CREATE OR REPLACE TRIGGER "trg_accounting_period_generate_snapshot_on_close" AFTER UPDATE ON "public"."accounting_periods" FOR EACH ROW EXECUTE FUNCTION "public"."trg_accounting_period_generate_snapshot_on_close"();



CREATE OR REPLACE TRIGGER "trg_accounting_period_snapshots_immutable" BEFORE DELETE OR UPDATE ON "public"."accounting_period_snapshots" FOR EACH ROW EXECUTE FUNCTION "public"."trg_accounting_period_snapshots_immutable"();



CREATE OR REPLACE TRIGGER "trg_addons_updated_at" BEFORE UPDATE ON "public"."addons" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_admin_single_owner" BEFORE INSERT OR UPDATE ON "public"."admin_users" FOR EACH ROW EXECUTE FUNCTION "public"."prevent_multiple_owners"();



CREATE OR REPLACE TRIGGER "trg_admin_users_audit" AFTER INSERT OR DELETE OR UPDATE ON "public"."admin_users" FOR EACH ROW EXECUTE FUNCTION "public"."log_admin_changes"();



CREATE OR REPLACE TRIGGER "trg_admin_users_guard" BEFORE UPDATE ON "public"."admin_users" FOR EACH ROW EXECUTE FUNCTION "public"."guard_admin_users_update"();



CREATE OR REPLACE TRIGGER "trg_admin_users_updated_at" BEFORE UPDATE ON "public"."admin_users" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_ads_updated_at" BEFORE UPDATE ON "public"."ads" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_app_settings_audit" AFTER UPDATE ON "public"."app_settings" FOR EACH ROW EXECUTE FUNCTION "public"."log_settings_changes"();



CREATE OR REPLACE TRIGGER "trg_app_settings_updated_at" BEFORE UPDATE ON "public"."app_settings" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_audit_accounting_periods" AFTER INSERT OR UPDATE ON "public"."accounting_periods" FOR EACH ROW EXECUTE FUNCTION "public"."audit_row_change"();



CREATE OR REPLACE TRIGGER "trg_audit_addons" AFTER INSERT OR DELETE OR UPDATE ON "public"."addons" FOR EACH ROW EXECUTE FUNCTION "public"."audit_row_change"();



CREATE OR REPLACE TRIGGER "trg_audit_admin_users" AFTER INSERT OR DELETE OR UPDATE ON "public"."admin_users" FOR EACH ROW EXECUTE FUNCTION "public"."audit_row_change"();



CREATE OR REPLACE TRIGGER "trg_audit_ads" AFTER INSERT OR DELETE OR UPDATE ON "public"."ads" FOR EACH ROW EXECUTE FUNCTION "public"."audit_row_change"();



CREATE OR REPLACE TRIGGER "trg_audit_app_settings" AFTER INSERT OR DELETE OR UPDATE ON "public"."app_settings" FOR EACH ROW EXECUTE FUNCTION "public"."audit_row_change"();



CREATE OR REPLACE TRIGGER "trg_audit_banks" AFTER INSERT OR DELETE OR UPDATE ON "public"."banks" FOR EACH ROW EXECUTE FUNCTION "public"."audit_row_change"();



CREATE OR REPLACE TRIGGER "trg_audit_challenges" AFTER INSERT OR DELETE OR UPDATE ON "public"."challenges" FOR EACH ROW EXECUTE FUNCTION "public"."audit_row_change"();



CREATE OR REPLACE TRIGGER "trg_audit_coupons" AFTER INSERT OR DELETE OR UPDATE ON "public"."coupons" FOR EACH ROW EXECUTE FUNCTION "public"."audit_row_change"();



CREATE OR REPLACE TRIGGER "trg_audit_customers" AFTER INSERT OR DELETE OR UPDATE ON "public"."customers" FOR EACH ROW EXECUTE FUNCTION "public"."audit_row_change"();



CREATE OR REPLACE TRIGGER "trg_audit_delivery_zones" AFTER INSERT OR DELETE OR UPDATE ON "public"."delivery_zones" FOR EACH ROW EXECUTE FUNCTION "public"."audit_row_change"();



CREATE OR REPLACE TRIGGER "trg_audit_expenses" AFTER INSERT OR DELETE OR UPDATE ON "public"."expenses" FOR EACH ROW EXECUTE FUNCTION "public"."audit_row_change"();



CREATE OR REPLACE TRIGGER "trg_audit_freshness_levels" AFTER INSERT OR DELETE OR UPDATE ON "public"."freshness_levels" FOR EACH ROW EXECUTE FUNCTION "public"."audit_row_change"();



CREATE OR REPLACE TRIGGER "trg_audit_item_categories" AFTER INSERT OR DELETE OR UPDATE ON "public"."item_categories" FOR EACH ROW EXECUTE FUNCTION "public"."audit_row_change"();



CREATE OR REPLACE TRIGGER "trg_audit_journal_entries" AFTER INSERT OR DELETE OR UPDATE ON "public"."journal_entries" FOR EACH ROW EXECUTE FUNCTION "public"."audit_row_change"();



CREATE OR REPLACE TRIGGER "trg_audit_journal_entries_insert" AFTER INSERT ON "public"."journal_entries" FOR EACH ROW EXECUTE FUNCTION "public"."trg_audit_journal_entries_insert"();



CREATE OR REPLACE TRIGGER "trg_audit_journal_lines" AFTER INSERT OR DELETE OR UPDATE ON "public"."journal_lines" FOR EACH ROW EXECUTE FUNCTION "public"."audit_row_change"();



CREATE OR REPLACE TRIGGER "trg_audit_journal_lines_insert" AFTER INSERT ON "public"."journal_lines" FOR EACH ROW EXECUTE FUNCTION "public"."trg_audit_journal_lines_insert"();



CREATE OR REPLACE TRIGGER "trg_audit_menu_items" AFTER INSERT OR DELETE OR UPDATE ON "public"."menu_items" FOR EACH ROW EXECUTE FUNCTION "public"."audit_row_change"();



CREATE OR REPLACE TRIGGER "trg_audit_orders" AFTER INSERT OR DELETE OR UPDATE ON "public"."orders" FOR EACH ROW EXECUTE FUNCTION "public"."audit_row_change"();



CREATE OR REPLACE TRIGGER "trg_audit_payments" AFTER INSERT OR DELETE OR UPDATE ON "public"."payments" FOR EACH ROW EXECUTE FUNCTION "public"."audit_row_change"();



CREATE OR REPLACE TRIGGER "trg_audit_purchase_orders" AFTER INSERT OR DELETE OR UPDATE ON "public"."purchase_orders" FOR EACH ROW EXECUTE FUNCTION "public"."audit_row_change"();



CREATE OR REPLACE TRIGGER "trg_audit_reviews" AFTER INSERT OR DELETE OR UPDATE ON "public"."reviews" FOR EACH ROW EXECUTE FUNCTION "public"."audit_row_change"();



CREATE OR REPLACE TRIGGER "trg_audit_stock_management" AFTER INSERT OR DELETE OR UPDATE ON "public"."stock_management" FOR EACH ROW EXECUTE FUNCTION "public"."audit_row_change"();



CREATE OR REPLACE TRIGGER "trg_audit_transfer_recipients" AFTER INSERT OR DELETE OR UPDATE ON "public"."transfer_recipients" FOR EACH ROW EXECUTE FUNCTION "public"."audit_row_change"();



CREATE OR REPLACE TRIGGER "trg_audit_unit_types" AFTER INSERT OR DELETE OR UPDATE ON "public"."unit_types" FOR EACH ROW EXECUTE FUNCTION "public"."audit_row_change"();



CREATE OR REPLACE TRIGGER "trg_banks_updated_at" BEFORE UPDATE ON "public"."banks" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_batch_balances_expiry_immutable" BEFORE UPDATE OF "expiry_date" ON "public"."batch_balances" FOR EACH ROW EXECUTE FUNCTION "public"."trg_batch_balances_expiry_immutable"();



CREATE OR REPLACE TRIGGER "trg_batches_pricing_defaults" BEFORE INSERT OR UPDATE ON "public"."batches" FOR EACH ROW EXECUTE FUNCTION "public"."trg_batches_pricing_defaults"();



CREATE OR REPLACE TRIGGER "trg_batches_updated_at" BEFORE UPDATE ON "public"."batches" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_block_sale_below_cost" BEFORE INSERT OR UPDATE ON "public"."inventory_movements" FOR EACH ROW EXECUTE FUNCTION "public"."trg_block_sale_below_cost"();



CREATE OR REPLACE TRIGGER "trg_block_sale_on_qc" BEFORE INSERT ON "public"."inventory_movements" FOR EACH ROW EXECUTE FUNCTION "public"."trg_block_sale_on_qc"();



CREATE OR REPLACE TRIGGER "trg_challenges_updated_at" BEFORE UPDATE ON "public"."challenges" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_coa_audit" AFTER INSERT OR DELETE OR UPDATE ON "public"."chart_of_accounts" FOR EACH ROW EXECUTE FUNCTION "public"."log_coa_changes"();



CREATE OR REPLACE TRIGGER "trg_coa_require_ifrs_mapping" BEFORE INSERT OR UPDATE ON "public"."chart_of_accounts" FOR EACH ROW EXECUTE FUNCTION "public"."trg_coa_require_ifrs_mapping"();



CREATE OR REPLACE TRIGGER "trg_cod_settlement_orders_immutable" BEFORE DELETE OR UPDATE ON "public"."cod_settlement_orders" FOR EACH ROW EXECUTE FUNCTION "public"."trg_forbid_update_delete"();



CREATE OR REPLACE TRIGGER "trg_cod_settlements_immutable" BEFORE DELETE OR UPDATE ON "public"."cod_settlements" FOR EACH ROW EXECUTE FUNCTION "public"."trg_forbid_update_delete"();



CREATE OR REPLACE TRIGGER "trg_coupons_updated_at" BEFORE UPDATE ON "public"."coupons" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_currencies_audit" AFTER INSERT OR DELETE OR UPDATE ON "public"."currencies" FOR EACH ROW EXECUTE FUNCTION "public"."log_currencies_changes"();



CREATE OR REPLACE TRIGGER "trg_customers_audit" AFTER DELETE OR UPDATE ON "public"."customers" FOR EACH ROW EXECUTE FUNCTION "public"."log_customer_changes"();



CREATE OR REPLACE TRIGGER "trg_customers_block_writes_during_maintenance" BEFORE INSERT OR UPDATE ON "public"."customers" FOR EACH ROW EXECUTE FUNCTION "public"."block_writes_during_maintenance"();



CREATE OR REPLACE TRIGGER "trg_customers_updated_at" BEFORE UPDATE ON "public"."customers" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE CONSTRAINT TRIGGER "trg_delivered_order_requires_journal_entry" AFTER UPDATE ON "public"."orders" DEFERRABLE INITIALLY DEFERRED FOR EACH ROW EXECUTE FUNCTION "public"."trg_delivered_order_requires_journal_entry"();



CREATE OR REPLACE TRIGGER "trg_delivery_zones_updated_at" BEFORE UPDATE ON "public"."delivery_zones" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_driver_ledger_immutable" BEFORE DELETE OR UPDATE ON "public"."driver_ledger" FOR EACH ROW EXECUTE FUNCTION "public"."trg_forbid_update_delete"();



CREATE OR REPLACE TRIGGER "trg_encrypt_customer_data" BEFORE INSERT OR UPDATE ON "public"."customers" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_encrypt_customer_data"();



CREATE OR REPLACE TRIGGER "trg_enforce_approval_branch" BEFORE UPDATE ON "public"."approval_steps" FOR EACH ROW EXECUTE FUNCTION "public"."trg_enforce_approval_branch"();



CREATE OR REPLACE TRIGGER "trg_enforce_base_currency_singleton" BEFORE INSERT OR UPDATE ON "public"."currencies" FOR EACH ROW EXECUTE FUNCTION "public"."trg_enforce_base_currency_singleton"();



CREATE OR REPLACE TRIGGER "trg_enforce_discount_approval" BEFORE UPDATE ON "public"."orders" FOR EACH ROW EXECUTE FUNCTION "public"."trg_enforce_discount_approval"();



CREATE OR REPLACE TRIGGER "trg_enforce_po_approval" BEFORE UPDATE ON "public"."purchase_orders" FOR EACH ROW EXECUTE FUNCTION "public"."trg_enforce_po_approval"();



CREATE OR REPLACE TRIGGER "trg_enforce_receipt_approval" BEFORE INSERT OR UPDATE ON "public"."purchase_receipts" FOR EACH ROW EXECUTE FUNCTION "public"."trg_enforce_receipt_approval"();



CREATE OR REPLACE TRIGGER "trg_enforce_transfer_approval" BEFORE UPDATE ON "public"."inventory_transfers" FOR EACH ROW EXECUTE FUNCTION "public"."trg_enforce_transfer_approval"();



CREATE OR REPLACE TRIGGER "trg_enforce_writeoff_approval" BEFORE INSERT ON "public"."inventory_movements" FOR EACH ROW EXECUTE FUNCTION "public"."trg_enforce_writeoff_approval"();



CREATE OR REPLACE TRIGGER "trg_forbid_delete_batch" BEFORE DELETE ON "public"."batches" FOR EACH ROW EXECUTE FUNCTION "public"."trg_forbid_delete_batch"();



CREATE OR REPLACE TRIGGER "trg_forbid_disable_batch" BEFORE UPDATE ON "public"."batches" FOR EACH ROW EXECUTE FUNCTION "public"."trg_forbid_disable_batch"();



CREATE OR REPLACE TRIGGER "trg_freshness_levels_updated_at" BEFORE UPDATE ON "public"."freshness_levels" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_fx_rates_audit" AFTER INSERT OR DELETE OR UPDATE ON "public"."fx_rates" FOR EACH ROW EXECUTE FUNCTION "public"."log_fx_rates_changes"();



CREATE OR REPLACE TRIGGER "trg_import_expenses_post" AFTER INSERT OR UPDATE ON "public"."import_expenses" FOR EACH ROW EXECUTE FUNCTION "public"."trg_post_import_expense"();



CREATE OR REPLACE TRIGGER "trg_import_shipment_close" AFTER UPDATE ON "public"."import_shipments" FOR EACH ROW WHEN ((("new"."status" = 'closed'::"text") AND ("old"."status" IS DISTINCT FROM "new"."status"))) EXECUTE FUNCTION "public"."trg_close_import_shipment"();



CREATE OR REPLACE TRIGGER "trg_import_shipment_delivered_close" AFTER UPDATE ON "public"."import_shipments" FOR EACH ROW WHEN ((("new"."status" = 'delivered'::"text") AND ("old"."status" IS DISTINCT FROM "new"."status"))) EXECUTE FUNCTION "public"."trg_apply_import_shipment_landed_cost_on_delivered"();



CREATE CONSTRAINT TRIGGER "trg_inventory_movement_requires_journal_entry" AFTER INSERT ON "public"."inventory_movements" DEFERRABLE INITIALLY DEFERRED FOR EACH ROW EXECUTE FUNCTION "public"."trg_inventory_movement_requires_journal_entry"();



CREATE OR REPLACE TRIGGER "trg_inventory_movements_block_writes_during_maintenance" BEFORE INSERT OR UPDATE ON "public"."inventory_movements" FOR EACH ROW EXECUTE FUNCTION "public"."block_writes_during_maintenance"();



CREATE OR REPLACE TRIGGER "trg_inventory_movements_consume_order_item_reservation" AFTER INSERT ON "public"."inventory_movements" FOR EACH ROW EXECUTE FUNCTION "public"."trg_consume_order_item_reservation_on_sale_out"();



CREATE OR REPLACE TRIGGER "trg_inventory_movements_ensure_batch_exists" BEFORE INSERT ON "public"."inventory_movements" FOR EACH ROW WHEN ((("new"."movement_type" = 'purchase_in'::"text") AND ("new"."batch_id" IS NOT NULL))) EXECUTE FUNCTION "public"."trg_inventory_movements_ensure_batch_exists"();



CREATE OR REPLACE TRIGGER "trg_inventory_movements_post" AFTER INSERT ON "public"."inventory_movements" FOR EACH ROW EXECUTE FUNCTION "public"."trg_post_inventory_movement"();



CREATE OR REPLACE TRIGGER "trg_inventory_movements_purchase_in_defaults" BEFORE INSERT ON "public"."inventory_movements" FOR EACH ROW WHEN (("new"."movement_type" = 'purchase_in'::"text")) EXECUTE FUNCTION "public"."trg_inventory_movements_purchase_in_defaults"();



CREATE OR REPLACE TRIGGER "trg_inventory_movements_purchase_in_immutable" BEFORE UPDATE ON "public"."inventory_movements" FOR EACH ROW WHEN ((("old"."movement_type" = 'purchase_in'::"text") OR ("new"."movement_type" = 'purchase_in'::"text"))) EXECUTE FUNCTION "public"."trg_inventory_movements_purchase_in_immutable"();



CREATE OR REPLACE TRIGGER "trg_inventory_movements_purchase_in_no_delete" BEFORE DELETE ON "public"."inventory_movements" FOR EACH ROW WHEN (("old"."movement_type" = 'purchase_in'::"text")) EXECUTE FUNCTION "public"."trg_inventory_movements_purchase_in_no_delete"();



CREATE OR REPLACE TRIGGER "trg_inventory_movements_purchase_in_sync_batch_balances" AFTER INSERT ON "public"."inventory_movements" FOR EACH ROW WHEN (("new"."movement_type" = 'purchase_in'::"text")) EXECUTE FUNCTION "public"."trg_inventory_movements_purchase_in_sync_batch_balances"();



CREATE OR REPLACE TRIGGER "trg_inventory_movements_purchase_in_sync_batch_balances_ins" AFTER INSERT ON "public"."inventory_movements" FOR EACH ROW WHEN (("new"."movement_type" = 'purchase_in'::"text")) EXECUTE FUNCTION "public"."trg_inventory_movements_purchase_in_sync_batch_balances"();



CREATE OR REPLACE TRIGGER "trg_issue_invoice_on_delivery" BEFORE UPDATE ON "public"."orders" FOR EACH ROW EXECUTE FUNCTION "public"."issue_invoice_on_delivery"();



CREATE OR REPLACE TRIGGER "trg_item_categories_updated_at" BEFORE UPDATE ON "public"."item_categories" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_item_groups_updated_at" BEFORE UPDATE ON "public"."item_groups" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE CONSTRAINT TRIGGER "trg_journal_entries_balance" AFTER INSERT ON "public"."journal_entries" DEFERRABLE INITIALLY DEFERRED FOR EACH ROW EXECUTE FUNCTION "public"."trg_check_journal_entry_balance_on_entry"();



CREATE OR REPLACE TRIGGER "trg_journal_entries_block_closed_period" BEFORE INSERT OR UPDATE ON "public"."journal_entries" FOR EACH ROW EXECUTE FUNCTION "public"."trg_block_journal_entries_in_closed_period"();



CREATE OR REPLACE TRIGGER "trg_journal_entries_block_manual_changes" BEFORE DELETE OR UPDATE ON "public"."journal_entries" FOR EACH ROW EXECUTE FUNCTION "public"."trg_block_manual_entry_changes"();



CREATE OR REPLACE TRIGGER "trg_journal_entries_flag_payment" AFTER INSERT ON "public"."journal_entries" FOR EACH ROW EXECUTE FUNCTION "public"."trg_after_journal_entry_insert_flag_payment"();



CREATE OR REPLACE TRIGGER "trg_journal_entries_hard_rules" BEFORE INSERT ON "public"."journal_entries" FOR EACH ROW EXECUTE FUNCTION "public"."trg_journal_entries_hard_rules"();



CREATE OR REPLACE TRIGGER "trg_journal_entries_immutable" BEFORE DELETE OR UPDATE ON "public"."journal_entries" FOR EACH ROW EXECUTE FUNCTION "public"."trg_immutable_block"();



CREATE OR REPLACE TRIGGER "trg_journal_entries_set_document" BEFORE INSERT ON "public"."journal_entries" FOR EACH ROW EXECUTE FUNCTION "public"."trg_journal_entries_set_document"();



CREATE OR REPLACE TRIGGER "trg_journal_entries_set_status" BEFORE INSERT ON "public"."journal_entries" FOR EACH ROW EXECUTE FUNCTION "public"."trg_set_journal_entry_status"();



CREATE CONSTRAINT TRIGGER "trg_journal_lines_balance" AFTER INSERT ON "public"."journal_lines" DEFERRABLE INITIALLY DEFERRED FOR EACH ROW EXECUTE FUNCTION "public"."trg_check_journal_balance"();



CREATE OR REPLACE TRIGGER "trg_journal_lines_block_closed_period" BEFORE INSERT OR DELETE OR UPDATE ON "public"."journal_lines" FOR EACH ROW EXECUTE FUNCTION "public"."trg_block_journal_lines_in_closed_period"();



CREATE OR REPLACE TRIGGER "trg_journal_lines_block_manual_changes" BEFORE DELETE OR UPDATE ON "public"."journal_lines" FOR EACH ROW EXECUTE FUNCTION "public"."trg_block_manual_line_changes"();



CREATE OR REPLACE TRIGGER "trg_journal_lines_immutable" BEFORE DELETE OR UPDATE ON "public"."journal_lines" FOR EACH ROW EXECUTE FUNCTION "public"."trg_immutable_block"();



CREATE CONSTRAINT TRIGGER "trg_journal_lines_sync_ar_open_item" AFTER INSERT OR DELETE OR UPDATE ON "public"."journal_lines" DEFERRABLE INITIALLY DEFERRED FOR EACH ROW EXECUTE FUNCTION "public"."trg_journal_lines_sync_ar_open_item"();



CREATE OR REPLACE TRIGGER "trg_ledger_audit_log_immutable" BEFORE DELETE OR UPDATE ON "public"."ledger_audit_log" FOR EACH ROW EXECUTE FUNCTION "public"."trg_ledger_audit_log_immutable"();



CREATE OR REPLACE TRIGGER "trg_ledger_entries_immutable" BEFORE DELETE OR UPDATE ON "public"."ledger_entries" FOR EACH ROW EXECUTE FUNCTION "public"."trg_forbid_update_delete"();



CREATE OR REPLACE TRIGGER "trg_ledger_lines_immutable" BEFORE DELETE OR UPDATE ON "public"."ledger_lines" FOR EACH ROW EXECUTE FUNCTION "public"."trg_forbid_update_delete"();



CREATE OR REPLACE TRIGGER "trg_lock_approval_requests" BEFORE DELETE OR UPDATE ON "public"."approval_requests" FOR EACH ROW EXECUTE FUNCTION "public"."trg_lock_approval_requests"();



CREATE OR REPLACE TRIGGER "trg_lock_approval_steps" BEFORE DELETE OR UPDATE ON "public"."approval_steps" FOR EACH ROW EXECUTE FUNCTION "public"."trg_lock_approval_steps"();



CREATE OR REPLACE TRIGGER "trg_menu_items_audit" AFTER DELETE OR UPDATE ON "public"."menu_items" FOR EACH ROW EXECUTE FUNCTION "public"."log_menu_item_changes"();



CREATE OR REPLACE TRIGGER "trg_menu_items_lock_after_first_movement" BEFORE UPDATE ON "public"."menu_items" FOR EACH ROW EXECUTE FUNCTION "public"."trg_menu_items_lock_after_first_movement"();



CREATE OR REPLACE TRIGGER "trg_menu_items_sot_sync_validate" BEFORE INSERT OR UPDATE ON "public"."menu_items" FOR EACH ROW EXECUTE FUNCTION "public"."trg_menu_items_sot_sync_validate"();



CREATE OR REPLACE TRIGGER "trg_menu_items_updated_at" BEFORE UPDATE ON "public"."menu_items" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_notify_delivery_assignment_change" AFTER UPDATE ON "public"."orders" FOR EACH ROW EXECUTE FUNCTION "public"."notify_delivery_assignment_change"();



CREATE OR REPLACE TRIGGER "trg_notify_order_created" AFTER INSERT ON "public"."orders" FOR EACH ROW EXECUTE FUNCTION "public"."notify_order_created"();



CREATE OR REPLACE TRIGGER "trg_notify_order_status" AFTER UPDATE ON "public"."orders" FOR EACH ROW EXECUTE FUNCTION "public"."notify_order_status_change"();



CREATE OR REPLACE TRIGGER "trg_orders_block_writes_during_maintenance" BEFORE INSERT OR UPDATE ON "public"."orders" FOR EACH ROW EXECUTE FUNCTION "public"."block_writes_during_maintenance"();



CREATE OR REPLACE TRIGGER "trg_orders_post_delivery" AFTER UPDATE ON "public"."orders" FOR EACH ROW EXECUTE FUNCTION "public"."trg_post_order_delivery"();



CREATE OR REPLACE TRIGGER "trg_orders_promotion_guards" BEFORE INSERT OR UPDATE ON "public"."orders" FOR EACH ROW EXECUTE FUNCTION "public"."trg_orders_promotion_guards"();



CREATE OR REPLACE TRIGGER "trg_orders_require_sale_out_on_delivered" BEFORE UPDATE OF "status" ON "public"."orders" FOR EACH ROW EXECUTE FUNCTION "public"."trg_orders_require_sale_out_on_delivered"();



CREATE OR REPLACE TRIGGER "trg_orders_sync_terms" BEFORE INSERT OR UPDATE ON "public"."orders" FOR EACH ROW EXECUTE FUNCTION "public"."_sync_order_terms_columns"();



CREATE OR REPLACE TRIGGER "trg_orders_updated_at" BEFORE UPDATE ON "public"."orders" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_orders_validate_delivery_zone_radius" BEFORE INSERT OR UPDATE ON "public"."orders" FOR EACH ROW EXECUTE FUNCTION "public"."orders_validate_delivery_zone_radius"();



CREATE CONSTRAINT TRIGGER "trg_payment_requires_journal_entry" AFTER INSERT ON "public"."payments" DEFERRABLE INITIALLY DEFERRED FOR EACH ROW EXECUTE FUNCTION "public"."trg_payment_requires_journal_entry"();



CREATE OR REPLACE TRIGGER "trg_payments_block_writes_during_maintenance" BEFORE INSERT OR UPDATE ON "public"."payments" FOR EACH ROW EXECUTE FUNCTION "public"."block_writes_during_maintenance"();



CREATE OR REPLACE TRIGGER "trg_payments_post" AFTER INSERT OR UPDATE ON "public"."payments" FOR EACH ROW EXECUTE FUNCTION "public"."trg_post_payment"();



CREATE OR REPLACE TRIGGER "trg_payments_sync_purchase_orders" AFTER INSERT OR DELETE OR UPDATE ON "public"."payments" FOR EACH ROW EXECUTE FUNCTION "public"."trg_sync_purchase_order_paid_amount"();



CREATE OR REPLACE TRIGGER "trg_price_tiers_updated_at" BEFORE UPDATE ON "public"."price_tiers" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "trg_product_audit_log" AFTER UPDATE ON "public"."menu_items" FOR EACH ROW EXECUTE FUNCTION "public"."trg_product_audit_log"();



CREATE OR REPLACE TRIGGER "trg_promotion_items_lock_after_usage" BEFORE INSERT OR DELETE OR UPDATE ON "public"."promotion_items" FOR EACH ROW EXECUTE FUNCTION "public"."trg_promotion_items_lock_after_usage"();



CREATE OR REPLACE TRIGGER "trg_promotion_usage_enforce_valid" BEFORE INSERT ON "public"."promotion_usage" FOR EACH ROW EXECUTE FUNCTION "public"."trg_promotion_usage_enforce_valid"();



CREATE OR REPLACE TRIGGER "trg_promotions_enforce_active_window_and_approval" BEFORE INSERT OR UPDATE ON "public"."promotions" FOR EACH ROW EXECUTE FUNCTION "public"."trg_promotions_enforce_active_window_and_approval"();



CREATE OR REPLACE TRIGGER "trg_promotions_lock_after_usage" BEFORE DELETE OR UPDATE ON "public"."promotions" FOR EACH ROW EXECUTE FUNCTION "public"."trg_promotions_lock_after_usage"();



CREATE OR REPLACE TRIGGER "trg_protect_audit_logs" BEFORE DELETE OR UPDATE ON "public"."system_audit_logs" FOR EACH ROW EXECUTE FUNCTION "public"."prevent_audit_log_modification"();



CREATE OR REPLACE TRIGGER "trg_purchase_items_editability" BEFORE INSERT OR DELETE OR UPDATE ON "public"."purchase_items" FOR EACH ROW EXECUTE FUNCTION "public"."enforce_purchase_items_editability"();



CREATE OR REPLACE TRIGGER "trg_purchase_items_recalc" AFTER INSERT OR DELETE OR UPDATE ON "public"."purchase_items" FOR EACH ROW EXECUTE FUNCTION "public"."purchase_items_after_change"();



CREATE OR REPLACE TRIGGER "trg_purchase_items_set_costs" BEFORE INSERT OR UPDATE OF "unit_cost", "unit_cost_foreign", "purchase_order_id" ON "public"."purchase_items" FOR EACH ROW EXECUTE FUNCTION "public"."trg_purchase_items_set_costs"();



CREATE OR REPLACE TRIGGER "trg_purchase_items_total_cost" BEFORE INSERT OR UPDATE OF "quantity", "unit_cost" ON "public"."purchase_items" FOR EACH ROW EXECUTE FUNCTION "public"."purchase_items_set_total_cost"();



CREATE OR REPLACE TRIGGER "trg_purchase_orders_fx_lock" BEFORE INSERT OR UPDATE ON "public"."purchase_orders" FOR EACH ROW EXECUTE FUNCTION "public"."trg_purchase_orders_fx_lock"();



CREATE OR REPLACE TRIGGER "trg_purchase_orders_po_number" BEFORE INSERT OR UPDATE ON "public"."purchase_orders" FOR EACH ROW EXECUTE FUNCTION "public"."_trg_purchase_orders_po_number"();



CREATE OR REPLACE TRIGGER "trg_purchase_orders_recalc_after_insert" AFTER INSERT ON "public"."purchase_orders" FOR EACH ROW EXECUTE FUNCTION "public"."purchase_orders_recalc_after_insert"();



CREATE OR REPLACE TRIGGER "trg_purchase_orders_status_guard" BEFORE UPDATE OF "status" ON "public"."purchase_orders" FOR EACH ROW EXECUTE FUNCTION "public"."enforce_purchase_orders_status_transition"();



CREATE OR REPLACE TRIGGER "trg_purchase_receipt_items_total_cost" BEFORE INSERT OR UPDATE OF "quantity", "unit_cost" ON "public"."purchase_receipt_items" FOR EACH ROW EXECUTE FUNCTION "public"."purchase_receipt_items_set_total_cost"();



CREATE OR REPLACE TRIGGER "trg_purchase_return_items_recalc" AFTER INSERT OR DELETE OR UPDATE ON "public"."purchase_return_items" FOR EACH ROW EXECUTE FUNCTION "public"."purchase_return_items_after_change"();



CREATE OR REPLACE TRIGGER "trg_purchase_return_items_total_cost" BEFORE INSERT OR UPDATE OF "quantity", "unit_cost" ON "public"."purchase_return_items" FOR EACH ROW EXECUTE FUNCTION "public"."purchase_return_items_set_total_cost"();



CREATE OR REPLACE TRIGGER "trg_recall_batch_update" AFTER INSERT OR UPDATE ON "public"."batch_recalls" FOR EACH ROW EXECUTE FUNCTION "public"."trg_recall_batch_update"();



CREATE OR REPLACE TRIGGER "trg_reviews_block_writes_during_maintenance" BEFORE INSERT OR UPDATE ON "public"."reviews" FOR EACH ROW EXECUTE FUNCTION "public"."block_writes_during_maintenance"();



CREATE OR REPLACE TRIGGER "trg_reviews_updated_at" BEFORE UPDATE ON "public"."reviews" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_sale_out_require_batch" BEFORE INSERT OR UPDATE ON "public"."inventory_movements" FOR EACH ROW EXECUTE FUNCTION "public"."trg_sale_out_require_batch"();



CREATE OR REPLACE TRIGGER "trg_set_approval_request_scope" BEFORE INSERT ON "public"."approval_requests" FOR EACH ROW EXECUTE FUNCTION "public"."trg_set_approval_request_scope"();



CREATE OR REPLACE TRIGGER "trg_set_movement_branch_scope" BEFORE INSERT OR UPDATE ON "public"."inventory_movements" FOR EACH ROW EXECUTE FUNCTION "public"."trg_set_movement_branch_scope"();



CREATE OR REPLACE TRIGGER "trg_set_order_branch_scope" BEFORE INSERT OR UPDATE ON "public"."orders" FOR EACH ROW EXECUTE FUNCTION "public"."trg_set_order_branch_scope"();



CREATE OR REPLACE TRIGGER "trg_set_order_fx" BEFORE INSERT OR UPDATE ON "public"."orders" FOR EACH ROW EXECUTE FUNCTION "public"."trg_set_order_fx"();



CREATE OR REPLACE TRIGGER "trg_set_payment_branch_scope" BEFORE INSERT OR UPDATE ON "public"."payments" FOR EACH ROW EXECUTE FUNCTION "public"."trg_set_payment_branch_scope"();



CREATE OR REPLACE TRIGGER "trg_set_payment_fx" BEFORE INSERT OR UPDATE ON "public"."payments" FOR EACH ROW EXECUTE FUNCTION "public"."trg_set_payment_fx"();



CREATE OR REPLACE TRIGGER "trg_set_po_branch_scope" BEFORE INSERT OR UPDATE ON "public"."purchase_orders" FOR EACH ROW EXECUTE FUNCTION "public"."trg_set_po_branch_scope"();



CREATE OR REPLACE TRIGGER "trg_set_qty_base_inventory_movements" BEFORE INSERT OR UPDATE ON "public"."inventory_movements" FOR EACH ROW EXECUTE FUNCTION "public"."trg_set_qty_base_inventory_movements"();



CREATE OR REPLACE TRIGGER "trg_set_qty_base_purchase_items" BEFORE INSERT OR UPDATE ON "public"."purchase_items" FOR EACH ROW EXECUTE FUNCTION "public"."trg_set_qty_base_purchase_items"();



CREATE OR REPLACE TRIGGER "trg_set_qty_base_receipt_items" BEFORE INSERT OR UPDATE ON "public"."purchase_receipt_items" FOR EACH ROW EXECUTE FUNCTION "public"."trg_set_qty_base_receipt_items"();



CREATE OR REPLACE TRIGGER "trg_set_qty_base_transfer_items" BEFORE INSERT OR UPDATE ON "public"."inventory_transfer_items" FOR EACH ROW EXECUTE FUNCTION "public"."trg_set_qty_base_transfer_items"();



CREATE OR REPLACE TRIGGER "trg_set_receipt_branch_scope" BEFORE INSERT OR UPDATE ON "public"."purchase_receipts" FOR EACH ROW EXECUTE FUNCTION "public"."trg_set_receipt_branch_scope"();



CREATE OR REPLACE TRIGGER "trg_set_supplier_invoice_branch_scope" BEFORE INSERT OR UPDATE ON "public"."supplier_invoices" FOR EACH ROW EXECUTE FUNCTION "public"."trg_set_supplier_invoice_branch_scope"();



CREATE OR REPLACE TRIGGER "trg_set_transfer_branch_scope" BEFORE INSERT OR UPDATE ON "public"."inventory_transfers" FOR EACH ROW EXECUTE FUNCTION "public"."trg_set_transfer_branch_scope"();



CREATE OR REPLACE TRIGGER "trg_set_transfer_number" BEFORE INSERT ON "public"."warehouse_transfers" FOR EACH ROW EXECUTE FUNCTION "public"."set_transfer_number"();



CREATE OR REPLACE TRIGGER "trg_special_prices_updated_at" BEFORE UPDATE ON "public"."customer_special_prices" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "trg_stock_management_updated_at" BEFORE UPDATE ON "public"."stock_management" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_sync_batch_balances_from_batches" AFTER INSERT OR UPDATE OF "item_id", "warehouse_id", "quantity_received", "quantity_consumed", "quantity_transferred", "expiry_date", "status", "qc_status" ON "public"."batches" FOR EACH ROW EXECUTE FUNCTION "public"."trg_sync_batch_balances_from_batches"();



CREATE OR REPLACE TRIGGER "trg_sync_discount_approval_to_order" AFTER UPDATE ON "public"."approval_requests" FOR EACH ROW EXECUTE FUNCTION "public"."trg_sync_discount_approval_to_order"();



CREATE OR REPLACE TRIGGER "trg_sync_discount_approval_to_promotion" AFTER UPDATE ON "public"."approval_requests" FOR EACH ROW EXECUTE FUNCTION "public"."trg_sync_discount_approval_to_promotion"();



CREATE OR REPLACE TRIGGER "trg_sync_expense_cost_center" AFTER INSERT OR UPDATE OF "cost_center_id" ON "public"."expenses" FOR EACH ROW EXECUTE FUNCTION "public"."sync_expense_cost_center"();



CREATE OR REPLACE TRIGGER "trg_sync_offline_reconciliation_approval" AFTER UPDATE ON "public"."approval_requests" FOR EACH ROW EXECUTE FUNCTION "public"."trg_sync_offline_reconciliation_approval"();



CREATE OR REPLACE TRIGGER "trg_sync_order_line_items" AFTER INSERT OR UPDATE ON "public"."orders" FOR EACH ROW EXECUTE FUNCTION "public"."trg_sync_order_line_items"();



CREATE OR REPLACE TRIGGER "trg_sync_po_approval_to_purchase_order" AFTER UPDATE ON "public"."approval_requests" FOR EACH ROW EXECUTE FUNCTION "public"."trg_sync_po_approval_to_purchase_order"();



CREATE OR REPLACE TRIGGER "trg_trace_batch_sales" AFTER INSERT ON "public"."inventory_movements" FOR EACH ROW EXECUTE FUNCTION "public"."trg_trace_batch_sales"();



CREATE OR REPLACE TRIGGER "trg_transfer_recipients_updated_at" BEFORE UPDATE ON "public"."transfer_recipients" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_unit_types_updated_at" BEFORE UPDATE ON "public"."unit_types" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "trg_user_challenge_progress_updated_at" BEFORE UPDATE ON "public"."user_challenge_progress" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE CONSTRAINT TRIGGER "trg_validate_base_currency_config_app_settings" AFTER INSERT OR UPDATE ON "public"."app_settings" DEFERRABLE INITIALLY DEFERRED FOR EACH ROW EXECUTE FUNCTION "public"."trg_validate_base_currency_config"();



CREATE CONSTRAINT TRIGGER "trg_validate_base_currency_config_currencies" AFTER INSERT OR UPDATE ON "public"."currencies" DEFERRABLE INITIALLY DEFERRED FOR EACH ROW EXECUTE FUNCTION "public"."trg_validate_base_currency_config"();



CREATE OR REPLACE TRIGGER "trg_validate_reserved_batches" BEFORE UPDATE ON "public"."stock_management" FOR EACH ROW EXECUTE FUNCTION "public"."trg_validate_reserved_batches"();



ALTER TABLE ONLY "public"."accounting_documents"
    ADD CONSTRAINT "accounting_documents_branch_id_fkey" FOREIGN KEY ("branch_id") REFERENCES "public"."branches"("id");



ALTER TABLE ONLY "public"."accounting_documents"
    ADD CONSTRAINT "accounting_documents_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."accounting_documents"
    ADD CONSTRAINT "accounting_documents_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."accounting_documents"
    ADD CONSTRAINT "accounting_documents_reversed_document_id_fkey" FOREIGN KEY ("reversed_document_id") REFERENCES "public"."accounting_documents"("id");



ALTER TABLE ONLY "public"."accounting_light_entries"
    ADD CONSTRAINT "accounting_light_entries_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."accounting_period_snapshots"
    ADD CONSTRAINT "accounting_period_snapshots_account_id_fkey" FOREIGN KEY ("account_id") REFERENCES "public"."chart_of_accounts"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."accounting_period_snapshots"
    ADD CONSTRAINT "accounting_period_snapshots_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."accounting_period_snapshots"
    ADD CONSTRAINT "accounting_period_snapshots_period_id_fkey" FOREIGN KEY ("period_id") REFERENCES "public"."accounting_periods"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."accounting_periods"
    ADD CONSTRAINT "accounting_periods_closed_by_fkey" FOREIGN KEY ("closed_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."admin_users"
    ADD CONSTRAINT "admin_users_auth_user_id_fkey" FOREIGN KEY ("auth_user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."admin_users"
    ADD CONSTRAINT "admin_users_branch_id_fkey" FOREIGN KEY ("branch_id") REFERENCES "public"."branches"("id");



ALTER TABLE ONLY "public"."admin_users"
    ADD CONSTRAINT "admin_users_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."admin_users"
    ADD CONSTRAINT "admin_users_warehouse_id_fkey" FOREIGN KEY ("warehouse_id") REFERENCES "public"."warehouses"("id");



ALTER TABLE ONLY "public"."approval_policy_steps"
    ADD CONSTRAINT "approval_policy_steps_policy_id_fkey" FOREIGN KEY ("policy_id") REFERENCES "public"."approval_policies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."approval_requests"
    ADD CONSTRAINT "approval_requests_branch_id_fkey" FOREIGN KEY ("branch_id") REFERENCES "public"."branches"("id");



ALTER TABLE ONLY "public"."approval_requests"
    ADD CONSTRAINT "approval_requests_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."approval_steps"
    ADD CONSTRAINT "approval_steps_request_id_fkey" FOREIGN KEY ("request_id") REFERENCES "public"."approval_requests"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."ar_allocations"
    ADD CONSTRAINT "ar_allocations_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."ar_allocations"
    ADD CONSTRAINT "ar_allocations_open_item_id_fkey" FOREIGN KEY ("open_item_id") REFERENCES "public"."ar_open_items"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."ar_allocations"
    ADD CONSTRAINT "ar_allocations_payment_id_fkey" FOREIGN KEY ("payment_id") REFERENCES "public"."payments"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."ar_open_items"
    ADD CONSTRAINT "ar_open_items_invoice_id_fkey" FOREIGN KEY ("invoice_id") REFERENCES "public"."orders"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."ar_open_items"
    ADD CONSTRAINT "ar_open_items_journal_entry_id_fkey" FOREIGN KEY ("journal_entry_id") REFERENCES "public"."journal_entries"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."ar_open_items"
    ADD CONSTRAINT "ar_open_items_order_id_fkey" FOREIGN KEY ("order_id") REFERENCES "public"."orders"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."ar_payment_status"
    ADD CONSTRAINT "ar_payment_status_order_id_fkey" FOREIGN KEY ("order_id") REFERENCES "public"."orders"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."ar_payment_status"
    ADD CONSTRAINT "ar_payment_status_payment_id_fkey" FOREIGN KEY ("payment_id") REFERENCES "public"."payments"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."batch_balances"
    ADD CONSTRAINT "batch_balances_warehouse_id_fkey" FOREIGN KEY ("warehouse_id") REFERENCES "public"."warehouses"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."batch_recalls"
    ADD CONSTRAINT "batch_recalls_batch_id_fkey" FOREIGN KEY ("batch_id") REFERENCES "public"."batches"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."batch_reservations"
    ADD CONSTRAINT "batch_reservations_order_id_fkey" FOREIGN KEY ("order_id") REFERENCES "public"."orders"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."batch_reservations"
    ADD CONSTRAINT "batch_reservations_warehouse_id_fkey" FOREIGN KEY ("warehouse_id") REFERENCES "public"."warehouses"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."batch_sales_trace"
    ADD CONSTRAINT "batch_sales_trace_batch_id_fkey" FOREIGN KEY ("batch_id") REFERENCES "public"."batches"("id");



ALTER TABLE ONLY "public"."batch_sales_trace"
    ADD CONSTRAINT "batch_sales_trace_order_id_fkey" FOREIGN KEY ("order_id") REFERENCES "public"."orders"("id");



ALTER TABLE ONLY "public"."batches"
    ADD CONSTRAINT "batches_item_id_fkey" FOREIGN KEY ("item_id") REFERENCES "public"."menu_items"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."batches"
    ADD CONSTRAINT "batches_receipt_id_fkey" FOREIGN KEY ("receipt_id") REFERENCES "public"."purchase_receipts"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."batches"
    ADD CONSTRAINT "batches_receipt_item_id_fkey" FOREIGN KEY ("receipt_item_id") REFERENCES "public"."purchase_receipt_items"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."batches"
    ADD CONSTRAINT "batches_warehouse_id_fkey" FOREIGN KEY ("warehouse_id") REFERENCES "public"."warehouses"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."branches"
    ADD CONSTRAINT "branches_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."cash_shifts"
    ADD CONSTRAINT "cash_shifts_cashier_id_fkey" FOREIGN KEY ("cashier_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."cash_shifts"
    ADD CONSTRAINT "cash_shifts_closed_by_fkey" FOREIGN KEY ("closed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."cod_settlement_orders"
    ADD CONSTRAINT "cod_settlement_orders_order_id_fkey" FOREIGN KEY ("order_id") REFERENCES "public"."orders"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."cod_settlement_orders"
    ADD CONSTRAINT "cod_settlement_orders_settlement_id_fkey" FOREIGN KEY ("settlement_id") REFERENCES "public"."cod_settlements"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."cod_settlements"
    ADD CONSTRAINT "cod_settlements_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."cod_settlements"
    ADD CONSTRAINT "cod_settlements_driver_id_fkey" FOREIGN KEY ("driver_id") REFERENCES "auth"."users"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."cod_settlements"
    ADD CONSTRAINT "cod_settlements_shift_id_fkey" FOREIGN KEY ("shift_id") REFERENCES "public"."cash_shifts"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."customer_special_prices"
    ADD CONSTRAINT "customer_special_prices_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."customer_special_prices"
    ADD CONSTRAINT "customer_special_prices_customer_id_fkey" FOREIGN KEY ("customer_id") REFERENCES "public"."customers"("auth_user_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."customer_special_prices"
    ADD CONSTRAINT "customer_special_prices_item_id_fkey" FOREIGN KEY ("item_id") REFERENCES "public"."menu_items"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."customer_tax_profiles"
    ADD CONSTRAINT "customer_tax_profiles_customer_id_fkey" FOREIGN KEY ("customer_id") REFERENCES "public"."customers"("auth_user_id");



ALTER TABLE ONLY "public"."customer_tax_profiles"
    ADD CONSTRAINT "customer_tax_profiles_jurisdiction_id_fkey" FOREIGN KEY ("jurisdiction_id") REFERENCES "public"."tax_jurisdictions"("id");



ALTER TABLE ONLY "public"."customers"
    ADD CONSTRAINT "customers_auth_user_id_fkey" FOREIGN KEY ("auth_user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."customers"
    ADD CONSTRAINT "customers_preferred_currency_fk" FOREIGN KEY ("preferred_currency") REFERENCES "public"."currencies"("code") ON UPDATE CASCADE ON DELETE SET NULL;



ALTER TABLE ONLY "public"."driver_ledger"
    ADD CONSTRAINT "driver_ledger_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."driver_ledger"
    ADD CONSTRAINT "driver_ledger_driver_id_fkey" FOREIGN KEY ("driver_id") REFERENCES "auth"."users"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."expenses"
    ADD CONSTRAINT "expenses_cost_center_id_fkey" FOREIGN KEY ("cost_center_id") REFERENCES "public"."cost_centers"("id");



ALTER TABLE ONLY "public"."expenses"
    ADD CONSTRAINT "expenses_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."inventory_movements"
    ADD CONSTRAINT "fk_inventory_movements_batch" FOREIGN KEY ("batch_id") REFERENCES "public"."batches"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."order_item_reservations"
    ADD CONSTRAINT "fk_order_item_reservations_batch" FOREIGN KEY ("batch_id") REFERENCES "public"."batches"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."fx_rates"
    ADD CONSTRAINT "fx_rates_currency_code_fkey" FOREIGN KEY ("currency_code") REFERENCES "public"."currencies"("code");



ALTER TABLE ONLY "public"."import_expenses"
    ADD CONSTRAINT "import_expenses_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."import_expenses"
    ADD CONSTRAINT "import_expenses_shipment_id_fkey" FOREIGN KEY ("shipment_id") REFERENCES "public"."import_shipments"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."import_shipments"
    ADD CONSTRAINT "import_shipments_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."import_shipments"
    ADD CONSTRAINT "import_shipments_destination_warehouse_id_fkey" FOREIGN KEY ("destination_warehouse_id") REFERENCES "public"."warehouses"("id");



ALTER TABLE ONLY "public"."import_shipments_items"
    ADD CONSTRAINT "import_shipments_items_item_id_fkey" FOREIGN KEY ("item_id") REFERENCES "public"."menu_items"("id");



ALTER TABLE ONLY "public"."import_shipments_items"
    ADD CONSTRAINT "import_shipments_items_shipment_id_fkey" FOREIGN KEY ("shipment_id") REFERENCES "public"."import_shipments"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."import_shipments"
    ADD CONSTRAINT "import_shipments_supplier_id_fkey" FOREIGN KEY ("supplier_id") REFERENCES "public"."suppliers"("id");



ALTER TABLE ONLY "public"."inventory_movements"
    ADD CONSTRAINT "inventory_movements_approval_request_id_fkey" FOREIGN KEY ("approval_request_id") REFERENCES "public"."approval_requests"("id");



ALTER TABLE ONLY "public"."inventory_movements"
    ADD CONSTRAINT "inventory_movements_branch_id_fkey" FOREIGN KEY ("branch_id") REFERENCES "public"."branches"("id");



ALTER TABLE ONLY "public"."inventory_movements"
    ADD CONSTRAINT "inventory_movements_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."inventory_movements"
    ADD CONSTRAINT "inventory_movements_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."inventory_movements"
    ADD CONSTRAINT "inventory_movements_item_id_fkey" FOREIGN KEY ("item_id") REFERENCES "public"."menu_items"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."inventory_movements"
    ADD CONSTRAINT "inventory_movements_uom_id_fkey" FOREIGN KEY ("uom_id") REFERENCES "public"."uom"("id");



ALTER TABLE ONLY "public"."inventory_movements"
    ADD CONSTRAINT "inventory_movements_warehouse_id_fkey" FOREIGN KEY ("warehouse_id") REFERENCES "public"."warehouses"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."inventory_transfer_items"
    ADD CONSTRAINT "inventory_transfer_items_item_id_fkey" FOREIGN KEY ("item_id") REFERENCES "public"."menu_items"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."inventory_transfer_items"
    ADD CONSTRAINT "inventory_transfer_items_received_batch_id_fkey" FOREIGN KEY ("received_batch_id") REFERENCES "public"."batches"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."inventory_transfer_items"
    ADD CONSTRAINT "inventory_transfer_items_source_batch_id_fkey" FOREIGN KEY ("source_batch_id") REFERENCES "public"."batches"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."inventory_transfer_items"
    ADD CONSTRAINT "inventory_transfer_items_transfer_id_fkey" FOREIGN KEY ("transfer_id") REFERENCES "public"."inventory_transfers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."inventory_transfer_items"
    ADD CONSTRAINT "inventory_transfer_items_uom_id_fkey" FOREIGN KEY ("uom_id") REFERENCES "public"."uom"("id");



ALTER TABLE ONLY "public"."inventory_transfers"
    ADD CONSTRAINT "inventory_transfers_approval_request_id_fkey" FOREIGN KEY ("approval_request_id") REFERENCES "public"."approval_requests"("id");



ALTER TABLE ONLY "public"."inventory_transfers"
    ADD CONSTRAINT "inventory_transfers_branch_id_fkey" FOREIGN KEY ("branch_id") REFERENCES "public"."branches"("id");



ALTER TABLE ONLY "public"."inventory_transfers"
    ADD CONSTRAINT "inventory_transfers_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."inventory_transfers"
    ADD CONSTRAINT "inventory_transfers_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."inventory_transfers"
    ADD CONSTRAINT "inventory_transfers_dispatched_by_fkey" FOREIGN KEY ("dispatched_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."inventory_transfers"
    ADD CONSTRAINT "inventory_transfers_from_warehouse_id_fkey" FOREIGN KEY ("from_warehouse_id") REFERENCES "public"."warehouses"("id");



ALTER TABLE ONLY "public"."inventory_transfers"
    ADD CONSTRAINT "inventory_transfers_received_by_fkey" FOREIGN KEY ("received_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."inventory_transfers"
    ADD CONSTRAINT "inventory_transfers_to_warehouse_id_fkey" FOREIGN KEY ("to_warehouse_id") REFERENCES "public"."warehouses"("id");



ALTER TABLE ONLY "public"."item_groups"
    ADD CONSTRAINT "item_groups_category_key_fkey" FOREIGN KEY ("category_key") REFERENCES "public"."item_categories"("key") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."item_uom"
    ADD CONSTRAINT "item_uom_base_uom_id_fkey" FOREIGN KEY ("base_uom_id") REFERENCES "public"."uom"("id");



ALTER TABLE ONLY "public"."item_uom"
    ADD CONSTRAINT "item_uom_purchase_uom_id_fkey" FOREIGN KEY ("purchase_uom_id") REFERENCES "public"."uom"("id");



ALTER TABLE ONLY "public"."item_uom"
    ADD CONSTRAINT "item_uom_sales_uom_id_fkey" FOREIGN KEY ("sales_uom_id") REFERENCES "public"."uom"("id");



ALTER TABLE ONLY "public"."journal_entries"
    ADD CONSTRAINT "journal_entries_approved_by_fkey" FOREIGN KEY ("approved_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."journal_entries"
    ADD CONSTRAINT "journal_entries_branch_id_fkey" FOREIGN KEY ("branch_id") REFERENCES "public"."branches"("id");



ALTER TABLE ONLY "public"."journal_entries"
    ADD CONSTRAINT "journal_entries_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."journal_entries"
    ADD CONSTRAINT "journal_entries_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."journal_entries"
    ADD CONSTRAINT "journal_entries_document_id_fkey" FOREIGN KEY ("document_id") REFERENCES "public"."accounting_documents"("id");



ALTER TABLE ONLY "public"."journal_entries"
    ADD CONSTRAINT "journal_entries_voided_by_fkey" FOREIGN KEY ("voided_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."journal_lines"
    ADD CONSTRAINT "journal_lines_account_id_fkey" FOREIGN KEY ("account_id") REFERENCES "public"."chart_of_accounts"("id");



ALTER TABLE ONLY "public"."journal_lines"
    ADD CONSTRAINT "journal_lines_cost_center_id_fkey" FOREIGN KEY ("cost_center_id") REFERENCES "public"."cost_centers"("id");



ALTER TABLE ONLY "public"."journal_lines"
    ADD CONSTRAINT "journal_lines_journal_entry_id_fkey" FOREIGN KEY ("journal_entry_id") REFERENCES "public"."journal_entries"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."ledger_entries"
    ADD CONSTRAINT "ledger_entries_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."ledger_lines"
    ADD CONSTRAINT "ledger_lines_entry_id_fkey" FOREIGN KEY ("entry_id") REFERENCES "public"."ledger_entries"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."notifications"
    ADD CONSTRAINT "notifications_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."order_events"
    ADD CONSTRAINT "order_events_order_id_fkey" FOREIGN KEY ("order_id") REFERENCES "public"."orders"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."order_item_cogs"
    ADD CONSTRAINT "order_item_cogs_item_id_fkey" FOREIGN KEY ("item_id") REFERENCES "public"."menu_items"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."order_item_cogs"
    ADD CONSTRAINT "order_item_cogs_order_id_fkey" FOREIGN KEY ("order_id") REFERENCES "public"."orders"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."order_item_reservations"
    ADD CONSTRAINT "order_item_reservations_order_id_fkey" FOREIGN KEY ("order_id") REFERENCES "public"."orders"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."order_item_reservations"
    ADD CONSTRAINT "order_item_reservations_warehouse_id_fkey" FOREIGN KEY ("warehouse_id") REFERENCES "public"."warehouses"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."order_line_items"
    ADD CONSTRAINT "order_line_items_order_id_fkey" FOREIGN KEY ("order_id") REFERENCES "public"."orders"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."order_tax_lines"
    ADD CONSTRAINT "order_tax_lines_order_id_fkey" FOREIGN KEY ("order_id") REFERENCES "public"."orders"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."orders"
    ADD CONSTRAINT "orders_assigned_delivery_user_id_fkey" FOREIGN KEY ("assigned_delivery_user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."orders"
    ADD CONSTRAINT "orders_branch_id_fkey" FOREIGN KEY ("branch_id") REFERENCES "public"."branches"("id");



ALTER TABLE ONLY "public"."orders"
    ADD CONSTRAINT "orders_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."orders"
    ADD CONSTRAINT "orders_customer_auth_user_id_fkey" FOREIGN KEY ("customer_auth_user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."orders"
    ADD CONSTRAINT "orders_discount_approval_request_id_fkey" FOREIGN KEY ("discount_approval_request_id") REFERENCES "public"."approval_requests"("id");



ALTER TABLE ONLY "public"."orders"
    ADD CONSTRAINT "orders_warehouse_id_fkey" FOREIGN KEY ("warehouse_id") REFERENCES "public"."warehouses"("id");



ALTER TABLE ONLY "public"."payments"
    ADD CONSTRAINT "payments_branch_id_fkey" FOREIGN KEY ("branch_id") REFERENCES "public"."branches"("id");



ALTER TABLE ONLY "public"."payments"
    ADD CONSTRAINT "payments_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."payments"
    ADD CONSTRAINT "payments_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."payments"
    ADD CONSTRAINT "payments_shift_id_fkey" FOREIGN KEY ("shift_id") REFERENCES "public"."cash_shifts"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."pos_offline_sales"
    ADD CONSTRAINT "pos_offline_sales_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."pos_offline_sales"
    ADD CONSTRAINT "pos_offline_sales_reconciled_by_fkey" FOREIGN KEY ("reconciled_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."pos_offline_sales"
    ADD CONSTRAINT "pos_offline_sales_reconciliation_approval_request_id_fkey" FOREIGN KEY ("reconciliation_approval_request_id") REFERENCES "public"."approval_requests"("id");



ALTER TABLE ONLY "public"."pos_offline_sales"
    ADD CONSTRAINT "pos_offline_sales_warehouse_id_fkey" FOREIGN KEY ("warehouse_id") REFERENCES "public"."warehouses"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."price_history"
    ADD CONSTRAINT "price_history_item_id_fkey" FOREIGN KEY ("item_id") REFERENCES "public"."menu_items"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."price_tiers"
    ADD CONSTRAINT "price_tiers_item_id_fkey" FOREIGN KEY ("item_id") REFERENCES "public"."menu_items"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."production_order_inputs"
    ADD CONSTRAINT "production_order_inputs_item_id_fkey" FOREIGN KEY ("item_id") REFERENCES "public"."menu_items"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."production_order_inputs"
    ADD CONSTRAINT "production_order_inputs_order_id_fkey" FOREIGN KEY ("order_id") REFERENCES "public"."production_orders"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."production_order_outputs"
    ADD CONSTRAINT "production_order_outputs_item_id_fkey" FOREIGN KEY ("item_id") REFERENCES "public"."menu_items"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."production_order_outputs"
    ADD CONSTRAINT "production_order_outputs_order_id_fkey" FOREIGN KEY ("order_id") REFERENCES "public"."production_orders"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."production_orders"
    ADD CONSTRAINT "production_orders_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."promotion_items"
    ADD CONSTRAINT "promotion_items_item_id_fkey" FOREIGN KEY ("item_id") REFERENCES "public"."menu_items"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."promotion_items"
    ADD CONSTRAINT "promotion_items_promotion_id_fkey" FOREIGN KEY ("promotion_id") REFERENCES "public"."promotions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."promotion_usage"
    ADD CONSTRAINT "promotion_usage_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."promotion_usage"
    ADD CONSTRAINT "promotion_usage_order_id_fkey" FOREIGN KEY ("order_id") REFERENCES "public"."orders"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."promotion_usage"
    ADD CONSTRAINT "promotion_usage_promotion_id_fkey" FOREIGN KEY ("promotion_id") REFERENCES "public"."promotions"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."promotion_usage"
    ADD CONSTRAINT "promotion_usage_warehouse_id_fkey" FOREIGN KEY ("warehouse_id") REFERENCES "public"."warehouses"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."promotions"
    ADD CONSTRAINT "promotions_approval_request_id_fkey" FOREIGN KEY ("approval_request_id") REFERENCES "public"."approval_requests"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."promotions"
    ADD CONSTRAINT "promotions_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."purchase_items"
    ADD CONSTRAINT "purchase_items_item_id_fkey" FOREIGN KEY ("item_id") REFERENCES "public"."menu_items"("id");



ALTER TABLE ONLY "public"."purchase_items"
    ADD CONSTRAINT "purchase_items_purchase_order_id_fkey" FOREIGN KEY ("purchase_order_id") REFERENCES "public"."purchase_orders"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."purchase_items"
    ADD CONSTRAINT "purchase_items_uom_id_fkey" FOREIGN KEY ("uom_id") REFERENCES "public"."uom"("id");



ALTER TABLE ONLY "public"."purchase_orders"
    ADD CONSTRAINT "purchase_orders_approval_request_id_fkey" FOREIGN KEY ("approval_request_id") REFERENCES "public"."approval_requests"("id");



ALTER TABLE ONLY "public"."purchase_orders"
    ADD CONSTRAINT "purchase_orders_branch_id_fkey" FOREIGN KEY ("branch_id") REFERENCES "public"."branches"("id");



ALTER TABLE ONLY "public"."purchase_orders"
    ADD CONSTRAINT "purchase_orders_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."purchase_orders"
    ADD CONSTRAINT "purchase_orders_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."purchase_orders"
    ADD CONSTRAINT "purchase_orders_supplier_id_fkey" FOREIGN KEY ("supplier_id") REFERENCES "public"."suppliers"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."purchase_orders"
    ADD CONSTRAINT "purchase_orders_warehouse_id_fkey" FOREIGN KEY ("warehouse_id") REFERENCES "public"."warehouses"("id");



ALTER TABLE ONLY "public"."purchase_receipt_items"
    ADD CONSTRAINT "purchase_receipt_items_item_id_fkey" FOREIGN KEY ("item_id") REFERENCES "public"."menu_items"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."purchase_receipt_items"
    ADD CONSTRAINT "purchase_receipt_items_receipt_id_fkey" FOREIGN KEY ("receipt_id") REFERENCES "public"."purchase_receipts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."purchase_receipt_items"
    ADD CONSTRAINT "purchase_receipt_items_uom_id_fkey" FOREIGN KEY ("uom_id") REFERENCES "public"."uom"("id");



ALTER TABLE ONLY "public"."purchase_receipts"
    ADD CONSTRAINT "purchase_receipts_approval_request_id_fkey" FOREIGN KEY ("approval_request_id") REFERENCES "public"."approval_requests"("id");



ALTER TABLE ONLY "public"."purchase_receipts"
    ADD CONSTRAINT "purchase_receipts_branch_id_fkey" FOREIGN KEY ("branch_id") REFERENCES "public"."branches"("id");



ALTER TABLE ONLY "public"."purchase_receipts"
    ADD CONSTRAINT "purchase_receipts_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."purchase_receipts"
    ADD CONSTRAINT "purchase_receipts_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."purchase_receipts"
    ADD CONSTRAINT "purchase_receipts_import_shipment_id_fkey" FOREIGN KEY ("import_shipment_id") REFERENCES "public"."import_shipments"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."purchase_receipts"
    ADD CONSTRAINT "purchase_receipts_purchase_order_id_fkey" FOREIGN KEY ("purchase_order_id") REFERENCES "public"."purchase_orders"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."purchase_receipts"
    ADD CONSTRAINT "purchase_receipts_warehouse_id_fkey" FOREIGN KEY ("warehouse_id") REFERENCES "public"."warehouses"("id");



ALTER TABLE ONLY "public"."purchase_return_items"
    ADD CONSTRAINT "purchase_return_items_item_id_fkey" FOREIGN KEY ("item_id") REFERENCES "public"."menu_items"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."purchase_return_items"
    ADD CONSTRAINT "purchase_return_items_return_id_fkey" FOREIGN KEY ("return_id") REFERENCES "public"."purchase_returns"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."purchase_returns"
    ADD CONSTRAINT "purchase_returns_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."purchase_returns"
    ADD CONSTRAINT "purchase_returns_purchase_order_id_fkey" FOREIGN KEY ("purchase_order_id") REFERENCES "public"."purchase_orders"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."qc_checks"
    ADD CONSTRAINT "qc_checks_batch_id_fkey" FOREIGN KEY ("batch_id") REFERENCES "public"."batches"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."reviews"
    ADD CONSTRAINT "reviews_customer_auth_user_id_fkey" FOREIGN KEY ("customer_auth_user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."reviews"
    ADD CONSTRAINT "reviews_menu_item_id_fkey" FOREIGN KEY ("menu_item_id") REFERENCES "public"."menu_items"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."sales_returns"
    ADD CONSTRAINT "sales_returns_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."sales_returns"
    ADD CONSTRAINT "sales_returns_order_id_fkey" FOREIGN KEY ("order_id") REFERENCES "public"."orders"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stock_history"
    ADD CONSTRAINT "stock_history_item_id_fkey" FOREIGN KEY ("item_id") REFERENCES "public"."menu_items"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stock_management"
    ADD CONSTRAINT "stock_management_item_id_fkey" FOREIGN KEY ("item_id") REFERENCES "public"."menu_items"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stock_management"
    ADD CONSTRAINT "stock_management_warehouse_id_fkey" FOREIGN KEY ("warehouse_id") REFERENCES "public"."warehouses"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stock_wastage"
    ADD CONSTRAINT "stock_wastage_item_id_fkey" FOREIGN KEY ("item_id") REFERENCES "public"."menu_items"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stock_wastage"
    ADD CONSTRAINT "stock_wastage_reported_by_fkey" FOREIGN KEY ("reported_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."stock_wastage"
    ADD CONSTRAINT "stock_wastage_warehouse_id_fkey" FOREIGN KEY ("warehouse_id") REFERENCES "public"."warehouses"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."supplier_contracts"
    ADD CONSTRAINT "supplier_contracts_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."supplier_contracts"
    ADD CONSTRAINT "supplier_contracts_supplier_id_fkey" FOREIGN KEY ("supplier_id") REFERENCES "public"."suppliers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."supplier_credit_note_allocations"
    ADD CONSTRAINT "supplier_credit_note_allocations_affected_batch_id_fkey" FOREIGN KEY ("affected_batch_id") REFERENCES "public"."batches"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."supplier_credit_note_allocations"
    ADD CONSTRAINT "supplier_credit_note_allocations_credit_note_id_fkey" FOREIGN KEY ("credit_note_id") REFERENCES "public"."supplier_credit_notes"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."supplier_credit_note_allocations"
    ADD CONSTRAINT "supplier_credit_note_allocations_receipt_id_fkey" FOREIGN KEY ("receipt_id") REFERENCES "public"."purchase_receipts"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."supplier_credit_note_allocations"
    ADD CONSTRAINT "supplier_credit_note_allocations_root_batch_id_fkey" FOREIGN KEY ("root_batch_id") REFERENCES "public"."batches"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."supplier_credit_notes"
    ADD CONSTRAINT "supplier_credit_notes_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."supplier_credit_notes"
    ADD CONSTRAINT "supplier_credit_notes_journal_entry_id_fkey" FOREIGN KEY ("journal_entry_id") REFERENCES "public"."journal_entries"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."supplier_credit_notes"
    ADD CONSTRAINT "supplier_credit_notes_reference_purchase_receipt_id_fkey" FOREIGN KEY ("reference_purchase_receipt_id") REFERENCES "public"."purchase_receipts"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."supplier_credit_notes"
    ADD CONSTRAINT "supplier_credit_notes_supplier_id_fkey" FOREIGN KEY ("supplier_id") REFERENCES "public"."suppliers"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."supplier_evaluations"
    ADD CONSTRAINT "supplier_evaluations_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."supplier_evaluations"
    ADD CONSTRAINT "supplier_evaluations_supplier_id_fkey" FOREIGN KEY ("supplier_id") REFERENCES "public"."suppliers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."supplier_invoice_lines"
    ADD CONSTRAINT "supplier_invoice_lines_invoice_id_fkey" FOREIGN KEY ("invoice_id") REFERENCES "public"."supplier_invoices"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."supplier_invoices"
    ADD CONSTRAINT "supplier_invoices_branch_id_fkey" FOREIGN KEY ("branch_id") REFERENCES "public"."branches"("id");



ALTER TABLE ONLY "public"."supplier_invoices"
    ADD CONSTRAINT "supplier_invoices_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."supplier_invoices"
    ADD CONSTRAINT "supplier_invoices_supplier_id_fkey" FOREIGN KEY ("supplier_id") REFERENCES "public"."suppliers"("id");



ALTER TABLE ONLY "public"."suppliers"
    ADD CONSTRAINT "suppliers_preferred_currency_fk" FOREIGN KEY ("preferred_currency") REFERENCES "public"."currencies"("code") ON UPDATE CASCADE ON DELETE SET NULL;



ALTER TABLE ONLY "public"."system_audit_logs"
    ADD CONSTRAINT "system_audit_logs_performed_by_fkey" FOREIGN KEY ("performed_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."tax_rates"
    ADD CONSTRAINT "tax_rates_jurisdiction_id_fkey" FOREIGN KEY ("jurisdiction_id") REFERENCES "public"."tax_jurisdictions"("id");



ALTER TABLE ONLY "public"."three_way_match_results"
    ADD CONSTRAINT "three_way_match_results_invoice_id_fkey" FOREIGN KEY ("invoice_id") REFERENCES "public"."supplier_invoices"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."uom_conversions"
    ADD CONSTRAINT "uom_conversions_from_uom_id_fkey" FOREIGN KEY ("from_uom_id") REFERENCES "public"."uom"("id");



ALTER TABLE ONLY "public"."uom_conversions"
    ADD CONSTRAINT "uom_conversions_to_uom_id_fkey" FOREIGN KEY ("to_uom_id") REFERENCES "public"."uom"("id");



ALTER TABLE ONLY "public"."user_challenge_progress"
    ADD CONSTRAINT "user_challenge_progress_challenge_id_fkey" FOREIGN KEY ("challenge_id") REFERENCES "public"."challenges"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_challenge_progress"
    ADD CONSTRAINT "user_challenge_progress_customer_auth_user_id_fkey" FOREIGN KEY ("customer_auth_user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."warehouse_transfer_items"
    ADD CONSTRAINT "warehouse_transfer_items_item_id_fkey" FOREIGN KEY ("item_id") REFERENCES "public"."menu_items"("id");



ALTER TABLE ONLY "public"."warehouse_transfer_items"
    ADD CONSTRAINT "warehouse_transfer_items_transfer_id_fkey" FOREIGN KEY ("transfer_id") REFERENCES "public"."warehouse_transfers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."warehouse_transfers"
    ADD CONSTRAINT "warehouse_transfers_approved_by_fkey" FOREIGN KEY ("approved_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."warehouse_transfers"
    ADD CONSTRAINT "warehouse_transfers_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."warehouse_transfers"
    ADD CONSTRAINT "warehouse_transfers_from_warehouse_id_fkey" FOREIGN KEY ("from_warehouse_id") REFERENCES "public"."warehouses"("id");



ALTER TABLE ONLY "public"."warehouse_transfers"
    ADD CONSTRAINT "warehouse_transfers_to_warehouse_id_fkey" FOREIGN KEY ("to_warehouse_id") REFERENCES "public"."warehouses"("id");



ALTER TABLE ONLY "public"."warehouses"
    ADD CONSTRAINT "warehouses_branch_id_fkey" FOREIGN KEY ("branch_id") REFERENCES "public"."branches"("id");



ALTER TABLE ONLY "public"."warehouses"
    ADD CONSTRAINT "warehouses_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");



ALTER TABLE ONLY "public"."warehouses"
    ADD CONSTRAINT "warehouses_manager_id_fkey" FOREIGN KEY ("manager_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



CREATE POLICY "Cashiers can insert their shifts" ON "public"."cash_shifts" FOR INSERT WITH CHECK ((("auth"."uid"() = "cashier_id") AND (EXISTS ( SELECT 1
   FROM "public"."admin_users" "au"
  WHERE (("au"."auth_user_id" = "auth"."uid"()) AND ("au"."is_active" = true) AND (("au"."role" = 'cashier'::"text") OR "public"."has_admin_permission"('cashShifts.open'::"text")))))));



CREATE POLICY "Cashiers can update their own open shifts" ON "public"."cash_shifts" FOR UPDATE USING ((("auth"."uid"() = "cashier_id") AND ("status" = 'open'::"text")));



CREATE POLICY "Cashiers can view their own shifts" ON "public"."cash_shifts" FOR SELECT USING ((("auth"."uid"() = "cashier_id") OR (( SELECT "admin_users"."role"
   FROM "public"."admin_users"
  WHERE ("admin_users"."auth_user_id" = "auth"."uid"())) = ANY (ARRAY['owner'::"text", 'manager'::"text"]))));



CREATE POLICY "Manage expenses for admins" ON "public"."expenses" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE (("admin_users"."auth_user_id" = "auth"."uid"()) AND ("admin_users"."role" = ANY (ARRAY['owner'::"text", 'manager'::"text"]))))));



CREATE POLICY "Managers can update open shifts" ON "public"."cash_shifts" FOR UPDATE USING ((("status" = 'open'::"text") AND (EXISTS ( SELECT 1
   FROM "public"."admin_users" "au"
  WHERE (("au"."auth_user_id" = "auth"."uid"()) AND ("au"."is_active" = true) AND ("au"."role" = ANY (ARRAY['owner'::"text", 'manager'::"text"]))))) AND ("cashier_id" IS NOT NULL))) WITH CHECK ((("status" = ANY (ARRAY['open'::"text", 'closed'::"text"])) AND (EXISTS ( SELECT 1
   FROM "public"."admin_users" "au"
  WHERE (("au"."auth_user_id" = "auth"."uid"()) AND ("au"."is_active" = true) AND ("au"."role" = ANY (ARRAY['owner'::"text", 'manager'::"text"])))))));



ALTER TABLE "public"."accounting_documents" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "accounting_documents_admin_all" ON "public"."accounting_documents" USING ("public"."has_admin_permission"('accounting.manage'::"text")) WITH CHECK ("public"."has_admin_permission"('accounting.manage'::"text"));



ALTER TABLE "public"."accounting_light_entries" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "accounting_light_entries_admin_only" ON "public"."accounting_light_entries" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."accounting_period_snapshots" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "accounting_period_snapshots_admin_select" ON "public"."accounting_period_snapshots" FOR SELECT USING ("public"."has_admin_permission"('accounting.view'::"text"));



CREATE POLICY "accounting_period_snapshots_admin_write" ON "public"."accounting_period_snapshots" FOR INSERT WITH CHECK (("public"."has_admin_permission"('accounting.manage'::"text") OR ("auth"."role"() = 'service_role'::"text")));



ALTER TABLE "public"."accounting_periods" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "accounting_periods_admin_select" ON "public"."accounting_periods" FOR SELECT USING ("public"."has_admin_permission"('accounting.view'::"text"));



CREATE POLICY "accounting_periods_write_manage" ON "public"."accounting_periods" USING ("public"."has_admin_permission"('accounting.manage'::"text")) WITH CHECK ("public"."has_admin_permission"('accounting.manage'::"text"));



ALTER TABLE "public"."addons" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "addons_select_all" ON "public"."addons" FOR SELECT USING (true);



CREATE POLICY "addons_write_admin" ON "public"."addons" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."admin_users" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "admin_users_admin_read_all" ON "public"."admin_users" FOR SELECT USING ("public"."is_admin"());



CREATE POLICY "admin_users_manager_insert" ON "public"."admin_users" FOR INSERT WITH CHECK (((EXISTS ( SELECT 1
   FROM "public"."admin_users" "me"
  WHERE (("me"."auth_user_id" = "auth"."uid"()) AND ("me"."is_active" = true) AND ("me"."role" = ANY (ARRAY['owner'::"text", 'manager'::"text"]))))) AND ("role" = ANY (ARRAY['manager'::"text", 'employee'::"text", 'delivery'::"text"]))));



CREATE POLICY "admin_users_manager_update" ON "public"."admin_users" FOR UPDATE USING (((EXISTS ( SELECT 1
   FROM "public"."admin_users" "me"
  WHERE (("me"."auth_user_id" = "auth"."uid"()) AND ("me"."is_active" = true) AND ("me"."role" = ANY (ARRAY['owner'::"text", 'manager'::"text"]))))) AND ("auth_user_id" <> "auth"."uid"()) AND ("role" <> 'owner'::"text"))) WITH CHECK (("role" <> 'owner'::"text"));



CREATE POLICY "admin_users_owner_write" ON "public"."admin_users" USING ("public"."is_owner"()) WITH CHECK ("public"."is_owner"());



CREATE POLICY "admin_users_self_read" ON "public"."admin_users" FOR SELECT USING (("auth"."uid"() = "auth_user_id"));



CREATE POLICY "admin_users_self_update_profile" ON "public"."admin_users" FOR UPDATE USING (("auth"."uid"() = "auth_user_id")) WITH CHECK (("auth"."uid"() = "auth_user_id"));



ALTER TABLE "public"."ads" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "ads_select_all" ON "public"."ads" FOR SELECT USING (true);



CREATE POLICY "ads_write_admin" ON "public"."ads" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."app_settings" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "app_settings_read_public" ON "public"."app_settings" FOR SELECT USING (true);



CREATE POLICY "app_settings_write_admin" ON "public"."app_settings" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."approval_policies" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "approval_policies_admin_all" ON "public"."approval_policies" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."approval_policy_steps" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "approval_policy_steps_admin_all" ON "public"."approval_policy_steps" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."approval_requests" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "approval_requests_admin_all" ON "public"."approval_requests" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."approval_steps" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "approval_steps_admin_all" ON "public"."approval_steps" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."ar_allocations" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "ar_allocations_select" ON "public"."ar_allocations" FOR SELECT USING ("public"."has_admin_permission"('accounting.view'::"text"));



CREATE POLICY "ar_allocations_write" ON "public"."ar_allocations" FOR INSERT WITH CHECK ("public"."has_admin_permission"('accounting.manage'::"text"));



ALTER TABLE "public"."ar_open_items" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "ar_open_items_select" ON "public"."ar_open_items" FOR SELECT USING ("public"."has_admin_permission"('accounting.view'::"text"));



CREATE POLICY "ar_open_items_update" ON "public"."ar_open_items" FOR UPDATE USING ("public"."has_admin_permission"('accounting.manage'::"text")) WITH CHECK ("public"."has_admin_permission"('accounting.manage'::"text"));



CREATE POLICY "ar_open_items_write" ON "public"."ar_open_items" FOR INSERT WITH CHECK ("public"."has_admin_permission"('accounting.manage'::"text"));



ALTER TABLE "public"."ar_payment_status" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "ar_payment_status_select" ON "public"."ar_payment_status" FOR SELECT USING ("public"."has_admin_permission"('accounting.view'::"text"));



CREATE POLICY "ar_payment_status_update" ON "public"."ar_payment_status" FOR UPDATE USING ("public"."has_admin_permission"('accounting.manage'::"text")) WITH CHECK ("public"."has_admin_permission"('accounting.manage'::"text"));



CREATE POLICY "ar_payment_status_write" ON "public"."ar_payment_status" FOR INSERT WITH CHECK ("public"."has_admin_permission"('accounting.manage'::"text"));



CREATE POLICY "audit_logs_insert" ON "public"."system_audit_logs" FOR INSERT WITH CHECK (("auth"."uid"() IS NOT NULL));



CREATE POLICY "audit_logs_select" ON "public"."system_audit_logs" FOR SELECT USING ("public"."is_admin"());



ALTER TABLE "public"."banks" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "banks_select_all" ON "public"."banks" FOR SELECT USING (true);



CREATE POLICY "banks_write_admin" ON "public"."banks" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."batch_balances" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "batch_balances_admin_only" ON "public"."batch_balances" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."batch_recalls" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "batch_recalls_admin_all" ON "public"."batch_recalls" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."batch_reservations" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "batch_reservations_admin_only" ON "public"."batch_reservations" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."batch_sales_trace" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "batch_sales_trace_admin_all" ON "public"."batch_sales_trace" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."batches" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "batches_manage_admin" ON "public"."batches" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



CREATE POLICY "batches_select_all" ON "public"."batches" FOR SELECT USING (true);



ALTER TABLE "public"."branches" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "branches_admin_all" ON "public"."branches" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."cash_shifts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."challenges" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "challenges_select_all" ON "public"."challenges" FOR SELECT USING (true);



CREATE POLICY "challenges_write_admin" ON "public"."challenges" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."chart_of_accounts" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "coa_admin_select" ON "public"."chart_of_accounts" FOR SELECT USING ("public"."has_admin_permission"('accounting.view'::"text"));



CREATE POLICY "coa_admin_write" ON "public"."chart_of_accounts" USING ("public"."is_owner"()) WITH CHECK ("public"."is_owner"());



ALTER TABLE "public"."cod_settlement_orders" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "cod_settlement_orders_select" ON "public"."cod_settlement_orders" FOR SELECT USING ("public"."has_admin_permission"('accounting.view'::"text"));



CREATE POLICY "cod_settlement_orders_write" ON "public"."cod_settlement_orders" FOR INSERT WITH CHECK (("public"."has_admin_permission"('accounting.manage'::"text") OR "public"."is_admin"()));



ALTER TABLE "public"."cod_settlements" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "cod_settlements_select" ON "public"."cod_settlements" FOR SELECT USING ("public"."has_admin_permission"('accounting.view'::"text"));



CREATE POLICY "cod_settlements_write" ON "public"."cod_settlements" FOR INSERT WITH CHECK (("public"."has_admin_permission"('accounting.manage'::"text") OR "public"."is_admin"()));



ALTER TABLE "public"."companies" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "companies_admin_all" ON "public"."companies" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."cost_centers" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "cost_centers_select" ON "public"."cost_centers" FOR SELECT USING (("public"."can_manage_expenses"() OR "public"."can_view_accounting_reports"()));



CREATE POLICY "cost_centers_write" ON "public"."cost_centers" USING ("public"."can_manage_expenses"()) WITH CHECK ("public"."can_manage_expenses"());



ALTER TABLE "public"."coupons" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "coupons_admin_only" ON "public"."coupons" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



CREATE POLICY "coupons_select_active" ON "public"."coupons" FOR SELECT USING (("is_active" = true));



ALTER TABLE "public"."currencies" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "currencies_admin_all" ON "public"."currencies" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."customer_special_prices" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."customer_tax_profiles" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "customer_tax_profiles_admin_all" ON "public"."customer_tax_profiles" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."customers" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "customers_insert_own" ON "public"."customers" FOR INSERT WITH CHECK (("auth"."uid"() = "auth_user_id"));



CREATE POLICY "customers_select_own_or_admin" ON "public"."customers" FOR SELECT USING ((("auth"."uid"() = "auth_user_id") OR "public"."is_admin"()));



CREATE POLICY "customers_update_own_or_admin" ON "public"."customers" FOR UPDATE USING ((("auth"."uid"() = "auth_user_id") OR "public"."is_admin"())) WITH CHECK ((("auth"."uid"() = "auth_user_id") OR "public"."is_admin"()));



ALTER TABLE "public"."delivery_zones" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "delivery_zones_select_all" ON "public"."delivery_zones" FOR SELECT USING (true);



CREATE POLICY "delivery_zones_write_admin" ON "public"."delivery_zones" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."driver_ledger" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "driver_ledger_select" ON "public"."driver_ledger" FOR SELECT USING ("public"."has_admin_permission"('accounting.view'::"text"));



CREATE POLICY "driver_ledger_write" ON "public"."driver_ledger" FOR INSERT WITH CHECK (("public"."has_admin_permission"('accounting.manage'::"text") OR "public"."is_admin"()));



ALTER TABLE "public"."expenses" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "expenses_insert_manage" ON "public"."expenses" FOR INSERT WITH CHECK ("public"."can_manage_expenses"());



CREATE POLICY "expenses_no_delete" ON "public"."expenses" FOR DELETE USING (false);



CREATE POLICY "expenses_select_manage" ON "public"."expenses" FOR SELECT USING ("public"."can_manage_expenses"());



CREATE POLICY "expenses_update_manage" ON "public"."expenses" FOR UPDATE USING ("public"."can_manage_expenses"()) WITH CHECK ("public"."can_manage_expenses"());



ALTER TABLE "public"."freshness_levels" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "freshness_levels_select_all" ON "public"."freshness_levels" FOR SELECT USING (true);



CREATE POLICY "freshness_levels_write_admin" ON "public"."freshness_levels" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."fx_rates" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "fx_rates_admin_all" ON "public"."fx_rates" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."import_expenses" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "import_expenses_manage" ON "public"."import_expenses" USING ("public"."has_admin_permission"('procurement.manage'::"text")) WITH CHECK ("public"."has_admin_permission"('procurement.manage'::"text"));



ALTER TABLE "public"."import_shipments" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "import_shipments_close_status" ON "public"."import_shipments" FOR UPDATE USING ("public"."has_admin_permission"('import.close'::"text")) WITH CHECK (("public"."has_admin_permission"('import.close'::"text") AND ("status" = ANY (ARRAY['delivered'::"text", 'closed'::"text"]))));



ALTER TABLE "public"."import_shipments_items" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "import_shipments_items_manage" ON "public"."import_shipments_items" USING ("public"."has_admin_permission"('procurement.manage'::"text")) WITH CHECK ("public"."has_admin_permission"('procurement.manage'::"text"));



CREATE POLICY "import_shipments_manage" ON "public"."import_shipments" USING ("public"."has_admin_permission"('procurement.manage'::"text")) WITH CHECK (("public"."has_admin_permission"('procurement.manage'::"text") AND (COALESCE("status", ''::"text") <> ALL (ARRAY['delivered'::"text", 'closed'::"text"]))));



ALTER TABLE "public"."inventory_movements" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "inventory_movements_manage" ON "public"."inventory_movements" USING ("public"."has_admin_permission"('inventory.manage'::"text")) WITH CHECK ("public"."has_admin_permission"('inventory.manage'::"text"));



ALTER TABLE "public"."inventory_transfer_items" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "inventory_transfer_items_admin_all" ON "public"."inventory_transfer_items" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."inventory_transfers" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "inventory_transfers_admin_all" ON "public"."inventory_transfers" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."invoice_tolerances" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "invoice_tolerances_admin_all" ON "public"."invoice_tolerances" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."item_categories" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "item_categories_select_all" ON "public"."item_categories" FOR SELECT USING (true);



CREATE POLICY "item_categories_write_admin" ON "public"."item_categories" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."item_groups" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "item_groups_select_all" ON "public"."item_groups" FOR SELECT USING (true);



CREATE POLICY "item_groups_write_admin" ON "public"."item_groups" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."item_tax_profiles" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "item_tax_profiles_admin_all" ON "public"."item_tax_profiles" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."item_uom" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "item_uom_admin_all" ON "public"."item_uom" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."job_runs" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "job_runs_admin_all" ON "public"."job_runs" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."job_schedules" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "job_schedules_admin_all" ON "public"."job_schedules" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."journal_entries" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "journal_entries_admin_insert" ON "public"."journal_entries" FOR INSERT WITH CHECK (("public"."has_admin_permission"('accounting.manage'::"text") OR ("auth"."role"() = 'service_role'::"text")));



CREATE POLICY "journal_entries_delete_none" ON "public"."journal_entries" FOR DELETE USING (false);



CREATE POLICY "journal_entries_insert_accounting" ON "public"."journal_entries" FOR INSERT WITH CHECK ("public"."has_admin_permission"('accounting.manage'::"text"));



CREATE POLICY "journal_entries_select_accounting" ON "public"."journal_entries" FOR SELECT USING ("public"."has_admin_permission"('accounting.view'::"text"));



CREATE POLICY "journal_entries_update_accounting" ON "public"."journal_entries" FOR UPDATE USING ("public"."has_admin_permission"('accounting.manage'::"text")) WITH CHECK ("public"."has_admin_permission"('accounting.manage'::"text"));



ALTER TABLE "public"."journal_lines" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "journal_lines_admin_insert" ON "public"."journal_lines" FOR INSERT WITH CHECK (("public"."has_admin_permission"('accounting.manage'::"text") OR ("auth"."role"() = 'service_role'::"text")));



CREATE POLICY "journal_lines_delete_none" ON "public"."journal_lines" FOR DELETE USING (false);



CREATE POLICY "journal_lines_insert_accounting" ON "public"."journal_lines" FOR INSERT WITH CHECK ("public"."has_admin_permission"('accounting.manage'::"text"));



CREATE POLICY "journal_lines_select_accounting" ON "public"."journal_lines" FOR SELECT USING ("public"."has_admin_permission"('accounting.view'::"text"));



CREATE POLICY "journal_lines_update_accounting" ON "public"."journal_lines" FOR UPDATE USING ("public"."has_admin_permission"('accounting.manage'::"text")) WITH CHECK ("public"."has_admin_permission"('accounting.manage'::"text"));



ALTER TABLE "public"."ledger_audit_log" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "ledger_audit_log_admin_only" ON "public"."ledger_audit_log" FOR SELECT USING ("public"."has_admin_permission"('accounting.view'::"text"));



CREATE POLICY "ledger_audit_log_insert_internal" ON "public"."ledger_audit_log" FOR INSERT WITH CHECK (true);



ALTER TABLE "public"."ledger_entries" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "ledger_entries_select" ON "public"."ledger_entries" FOR SELECT USING ("public"."has_admin_permission"('accounting.view'::"text"));



CREATE POLICY "ledger_entries_write" ON "public"."ledger_entries" FOR INSERT WITH CHECK (("public"."has_admin_permission"('accounting.manage'::"text") OR "public"."is_admin"()));



ALTER TABLE "public"."ledger_lines" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "ledger_lines_select" ON "public"."ledger_lines" FOR SELECT USING ("public"."has_admin_permission"('accounting.view'::"text"));



CREATE POLICY "ledger_lines_write" ON "public"."ledger_lines" FOR INSERT WITH CHECK (("public"."has_admin_permission"('accounting.manage'::"text") OR "public"."is_admin"()));



ALTER TABLE "public"."menu_items" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "menu_items_delete_admin" ON "public"."menu_items" FOR DELETE USING ("public"."is_admin"());



CREATE POLICY "menu_items_select_all" ON "public"."menu_items" FOR SELECT USING ("public"."is_staff"());



CREATE POLICY "menu_items_update_admin" ON "public"."menu_items" FOR UPDATE USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



CREATE POLICY "menu_items_write_admin" ON "public"."menu_items" FOR INSERT WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."notifications" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "notifications_insert_admin" ON "public"."notifications" FOR INSERT WITH CHECK ("public"."is_admin"());



CREATE POLICY "notifications_select_own" ON "public"."notifications" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "notifications_update_own" ON "public"."notifications" FOR UPDATE USING (("auth"."uid"() = "user_id"));



ALTER TABLE "public"."order_events" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "order_events_delete_admin" ON "public"."order_events" FOR DELETE USING ("public"."is_admin"());



CREATE POLICY "order_events_insert_admin" ON "public"."order_events" FOR INSERT WITH CHECK ("public"."is_admin"());



CREATE POLICY "order_events_select_permissions" ON "public"."order_events" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."orders" "o"
  WHERE (("o"."id" = "order_events"."order_id") AND (("o"."customer_auth_user_id" = "auth"."uid"()) OR ((EXISTS ( SELECT 1
           FROM "public"."admin_users" "au"
          WHERE (("au"."auth_user_id" = "auth"."uid"()) AND ("au"."is_active" = true) AND ("au"."role" <> 'delivery'::"text")))) AND "public"."has_admin_permission"('orders.view'::"text")) OR ((EXISTS ( SELECT 1
           FROM "public"."admin_users" "au"
          WHERE (("au"."auth_user_id" = "auth"."uid"()) AND ("au"."is_active" = true) AND ("au"."role" = 'delivery'::"text")))) AND (("o"."data" ->> 'assignedDeliveryUserId'::"text") = ("auth"."uid"())::"text")))))));



ALTER TABLE "public"."order_item_cogs" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "order_item_cogs_manage" ON "public"."order_item_cogs" USING ("public"."has_admin_permission"('inventory.manage'::"text")) WITH CHECK ("public"."has_admin_permission"('inventory.manage'::"text"));



ALTER TABLE "public"."order_item_reservations" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "order_item_reservations_admin_only" ON "public"."order_item_reservations" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."order_line_items" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "order_line_items_admin_all" ON "public"."order_line_items" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."order_tax_lines" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "order_tax_lines_admin_all" ON "public"."order_tax_lines" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."orders" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "orders_delete_admin" ON "public"."orders" FOR DELETE USING ("public"."is_admin"());



CREATE POLICY "orders_insert_admin" ON "public"."orders" FOR INSERT WITH CHECK ("public"."is_admin"());



CREATE POLICY "orders_select_permissions" ON "public"."orders" FOR SELECT USING (((("auth"."role"() = 'authenticated'::"text") AND ("customer_auth_user_id" = "auth"."uid"())) OR ((EXISTS ( SELECT 1
   FROM "public"."admin_users" "au"
  WHERE (("au"."auth_user_id" = "auth"."uid"()) AND ("au"."is_active" = true) AND ("au"."role" <> 'delivery'::"text")))) AND "public"."has_admin_permission"('orders.view'::"text")) OR ((EXISTS ( SELECT 1
   FROM "public"."admin_users" "au"
  WHERE (("au"."auth_user_id" = "auth"."uid"()) AND ("au"."is_active" = true) AND ("au"."role" = 'delivery'::"text")))) AND (("data" ->> 'assignedDeliveryUserId'::"text") = ("auth"."uid"())::"text"))));



CREATE POLICY "orders_update_admin" ON "public"."orders" FOR UPDATE USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."payments" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "payments_admin_insert" ON "public"."payments" FOR INSERT WITH CHECK ("public"."is_admin"());



CREATE POLICY "payments_admin_select" ON "public"."payments" FOR SELECT USING ("public"."is_admin"());



CREATE POLICY "payments_admin_update" ON "public"."payments" FOR UPDATE USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



CREATE POLICY "payments_no_delete" ON "public"."payments" FOR DELETE USING (false);



CREATE POLICY "payments_select_staff" ON "public"."payments" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users" "au"
  WHERE (("au"."auth_user_id" = "auth"."uid"()) AND ("au"."is_active" = true) AND ("au"."role" = ANY (ARRAY['owner'::"text", 'manager'::"text", 'employee'::"text", 'cashier'::"text", 'accountant'::"text"]))))));



ALTER TABLE "public"."pos_offline_sales" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "pos_offline_sales_manage_admin" ON "public"."pos_offline_sales" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



CREATE POLICY "pos_offline_sales_select_staff" ON "public"."pos_offline_sales" FOR SELECT USING (("public"."is_staff"() AND ("created_by" = "auth"."uid"())));



ALTER TABLE "public"."price_history" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "price_history_admin_only" ON "public"."price_history" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."price_tiers" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "price_tiers_manage" ON "public"."price_tiers" USING ("public"."has_admin_permission"('prices.manage'::"text")) WITH CHECK ("public"."has_admin_permission"('prices.manage'::"text"));



CREATE POLICY "price_tiers_select" ON "public"."price_tiers" FOR SELECT USING ("public"."is_admin"());



ALTER TABLE "public"."production_order_inputs" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "production_order_inputs_admin_only" ON "public"."production_order_inputs" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."production_order_outputs" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "production_order_outputs_admin_only" ON "public"."production_order_outputs" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."production_orders" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "production_orders_admin_only" ON "public"."production_orders" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."promotion_items" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "promotion_items_admin_all" ON "public"."promotion_items" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."promotion_usage" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "promotion_usage_admin_all" ON "public"."promotion_usage" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."promotions" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "promotions_admin_all" ON "public"."promotions" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."purchase_items" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "purchase_items_delete" ON "public"."purchase_items" FOR DELETE USING (("public"."can_manage_stock"() AND (EXISTS ( SELECT 1
   FROM "public"."purchase_orders" "po"
  WHERE (("po"."id" = "purchase_items"."purchase_order_id") AND ("po"."status" = 'draft'::"text"))))));



CREATE POLICY "purchase_items_insert" ON "public"."purchase_items" FOR INSERT WITH CHECK ("public"."can_manage_stock"());



CREATE POLICY "purchase_items_select" ON "public"."purchase_items" FOR SELECT USING ("public"."can_manage_stock"());



CREATE POLICY "purchase_items_update" ON "public"."purchase_items" FOR UPDATE USING ("public"."can_manage_stock"()) WITH CHECK ("public"."can_manage_stock"());



ALTER TABLE "public"."purchase_orders" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "purchase_orders_delete" ON "public"."purchase_orders" FOR DELETE USING (("public"."can_manage_stock"() AND ("status" = 'draft'::"text")));



CREATE POLICY "purchase_orders_insert" ON "public"."purchase_orders" FOR INSERT WITH CHECK ("public"."can_manage_stock"());



CREATE POLICY "purchase_orders_select" ON "public"."purchase_orders" FOR SELECT USING ("public"."can_manage_stock"());



CREATE POLICY "purchase_orders_update" ON "public"."purchase_orders" FOR UPDATE USING ("public"."can_manage_stock"()) WITH CHECK ("public"."can_manage_stock"());



ALTER TABLE "public"."purchase_receipt_items" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "purchase_receipt_items_insert" ON "public"."purchase_receipt_items" FOR INSERT WITH CHECK ("public"."can_manage_stock"());



CREATE POLICY "purchase_receipt_items_select" ON "public"."purchase_receipt_items" FOR SELECT USING ("public"."can_manage_stock"());



CREATE POLICY "purchase_receipt_items_update" ON "public"."purchase_receipt_items" FOR UPDATE USING ("public"."can_manage_stock"()) WITH CHECK ("public"."can_manage_stock"());



ALTER TABLE "public"."purchase_receipts" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "purchase_receipts_insert" ON "public"."purchase_receipts" FOR INSERT WITH CHECK ("public"."can_manage_stock"());



CREATE POLICY "purchase_receipts_select" ON "public"."purchase_receipts" FOR SELECT USING ("public"."can_manage_stock"());



CREATE POLICY "purchase_receipts_update" ON "public"."purchase_receipts" FOR UPDATE USING ("public"."can_manage_stock"()) WITH CHECK ("public"."can_manage_stock"());



ALTER TABLE "public"."purchase_return_items" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "purchase_return_items_insert" ON "public"."purchase_return_items" FOR INSERT WITH CHECK ("public"."can_manage_stock"());



CREATE POLICY "purchase_return_items_select" ON "public"."purchase_return_items" FOR SELECT USING ("public"."can_manage_stock"());



CREATE POLICY "purchase_return_items_update" ON "public"."purchase_return_items" FOR UPDATE USING ("public"."can_manage_stock"()) WITH CHECK ("public"."can_manage_stock"());



ALTER TABLE "public"."purchase_returns" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "purchase_returns_insert" ON "public"."purchase_returns" FOR INSERT WITH CHECK ("public"."can_manage_stock"());



CREATE POLICY "purchase_returns_select" ON "public"."purchase_returns" FOR SELECT USING ("public"."can_manage_stock"());



CREATE POLICY "purchase_returns_update" ON "public"."purchase_returns" FOR UPDATE USING ("public"."can_manage_stock"()) WITH CHECK ("public"."can_manage_stock"());



ALTER TABLE "public"."qc_checks" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "qc_checks_admin_all" ON "public"."qc_checks" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."reviews" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "reviews_delete_own_or_admin" ON "public"."reviews" FOR DELETE USING ((("auth"."uid"() = "customer_auth_user_id") OR "public"."is_admin"()));



CREATE POLICY "reviews_insert_authenticated" ON "public"."reviews" FOR INSERT WITH CHECK (("auth"."uid"() = "customer_auth_user_id"));



CREATE POLICY "reviews_select_all" ON "public"."reviews" FOR SELECT USING (true);



CREATE POLICY "reviews_update_own_or_admin" ON "public"."reviews" FOR UPDATE USING ((("auth"."uid"() = "customer_auth_user_id") OR "public"."is_admin"())) WITH CHECK ((("auth"."uid"() = "customer_auth_user_id") OR "public"."is_admin"()));



ALTER TABLE "public"."sales_returns" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "sales_returns_admin_only" ON "public"."sales_returns" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



CREATE POLICY "special_prices_manage" ON "public"."customer_special_prices" USING ("public"."has_admin_permission"('prices.manage'::"text")) WITH CHECK ("public"."has_admin_permission"('prices.manage'::"text"));



CREATE POLICY "special_prices_select" ON "public"."customer_special_prices" FOR SELECT USING ((("auth"."uid"() = "customer_id") OR "public"."is_admin"()));



ALTER TABLE "public"."stock_history" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "stock_history_admin_only" ON "public"."stock_history" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."stock_management" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "stock_management_manage" ON "public"."stock_management" USING ("public"."has_admin_permission"('inventory.manage'::"text")) WITH CHECK ("public"."has_admin_permission"('inventory.manage'::"text"));



ALTER TABLE "public"."stock_wastage" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "stock_wastage_admin_all" ON "public"."stock_wastage" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."supplier_contracts" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "supplier_contracts_manage" ON "public"."supplier_contracts" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE (("admin_users"."auth_user_id" = "auth"."uid"()) AND ("admin_users"."is_active" = true)))));



CREATE POLICY "supplier_contracts_select" ON "public"."supplier_contracts" FOR SELECT USING (true);



ALTER TABLE "public"."supplier_credit_note_allocations" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "supplier_credit_note_allocations_admin_all" ON "public"."supplier_credit_note_allocations" USING ("public"."has_admin_permission"('accounting.manage'::"text")) WITH CHECK ("public"."has_admin_permission"('accounting.manage'::"text"));



ALTER TABLE "public"."supplier_credit_notes" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "supplier_credit_notes_admin_all" ON "public"."supplier_credit_notes" USING ("public"."has_admin_permission"('accounting.manage'::"text")) WITH CHECK ("public"."has_admin_permission"('accounting.manage'::"text"));



ALTER TABLE "public"."supplier_evaluations" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "supplier_evaluations_manage" ON "public"."supplier_evaluations" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE (("admin_users"."auth_user_id" = "auth"."uid"()) AND ("admin_users"."is_active" = true)))));



CREATE POLICY "supplier_evaluations_select" ON "public"."supplier_evaluations" FOR SELECT USING (true);



ALTER TABLE "public"."supplier_invoice_lines" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "supplier_invoice_lines_admin_all" ON "public"."supplier_invoice_lines" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."supplier_invoices" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "supplier_invoices_admin_all" ON "public"."supplier_invoices" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."suppliers" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "suppliers_manage" ON "public"."suppliers" USING ("public"."can_manage_stock"()) WITH CHECK ("public"."can_manage_stock"());



CREATE POLICY "suppliers_select" ON "public"."suppliers" FOR SELECT USING ("public"."can_manage_stock"());



ALTER TABLE "public"."system_audit_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."tax_jurisdictions" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "tax_jurisdictions_admin_all" ON "public"."tax_jurisdictions" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."tax_rates" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "tax_rates_admin_all" ON "public"."tax_rates" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."three_way_match_results" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "three_way_match_results_admin_all" ON "public"."three_way_match_results" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



CREATE POLICY "transfer_items_manage" ON "public"."warehouse_transfer_items" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE (("admin_users"."auth_user_id" = "auth"."uid"()) AND ("admin_users"."is_active" = true)))));



CREATE POLICY "transfer_items_select" ON "public"."warehouse_transfer_items" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE (("admin_users"."auth_user_id" = "auth"."uid"()) AND ("admin_users"."is_active" = true)))));



ALTER TABLE "public"."transfer_recipients" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "transfer_recipients_select_all" ON "public"."transfer_recipients" FOR SELECT USING (true);



CREATE POLICY "transfer_recipients_write_admin" ON "public"."transfer_recipients" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



CREATE POLICY "transfers_manage" ON "public"."warehouse_transfers" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE (("admin_users"."auth_user_id" = "auth"."uid"()) AND ("admin_users"."is_active" = true)))));



CREATE POLICY "transfers_select" ON "public"."warehouse_transfers" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE (("admin_users"."auth_user_id" = "auth"."uid"()) AND ("admin_users"."is_active" = true)))));



CREATE POLICY "ucp_delete_admin" ON "public"."user_challenge_progress" FOR DELETE USING ("public"."is_admin"());



CREATE POLICY "ucp_insert_own" ON "public"."user_challenge_progress" FOR INSERT WITH CHECK (("customer_auth_user_id" = "auth"."uid"()));



CREATE POLICY "ucp_select_own_or_admin" ON "public"."user_challenge_progress" FOR SELECT USING ((("customer_auth_user_id" = "auth"."uid"()) OR "public"."is_admin"()));



CREATE POLICY "ucp_update_own_or_admin" ON "public"."user_challenge_progress" FOR UPDATE USING ((("customer_auth_user_id" = "auth"."uid"()) OR "public"."is_admin"())) WITH CHECK ((("customer_auth_user_id" = "auth"."uid"()) OR "public"."is_admin"()));



ALTER TABLE "public"."unit_types" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "unit_types_select_all" ON "public"."unit_types" FOR SELECT USING (true);



CREATE POLICY "unit_types_write_admin" ON "public"."unit_types" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."uom" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "uom_admin_all" ON "public"."uom" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."uom_conversions" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "uom_conversions_admin_all" ON "public"."uom_conversions" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



ALTER TABLE "public"."user_challenge_progress" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."warehouse_transfer_items" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."warehouse_transfers" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."warehouses" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "warehouses_manage" ON "public"."warehouses" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users"
  WHERE (("admin_users"."auth_user_id" = "auth"."uid"()) AND ("admin_users"."is_active" = true)))));



CREATE POLICY "warehouses_select" ON "public"."warehouses" FOR SELECT USING (true);



GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";



REVOKE ALL ON FUNCTION "public"."_apply_ar_open_item_credit"("p_invoice_id" "uuid", "p_amount" numeric) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."_apply_ar_open_item_credit"("p_invoice_id" "uuid", "p_amount" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."_apply_ar_open_item_credit"("p_invoice_id" "uuid", "p_amount" numeric) TO "service_role";



GRANT ALL ON FUNCTION "public"."_assign_po_number"("p_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."_assign_po_number"("p_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."_assign_po_number"("p_date" "date") TO "service_role";



REVOKE ALL ON FUNCTION "public"."_compute_promotion_price_only"("p_promotion_id" "uuid", "p_customer_id" "uuid", "p_bundle_qty" numeric) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."_compute_promotion_price_only"("p_promotion_id" "uuid", "p_customer_id" "uuid", "p_bundle_qty" numeric) TO "anon";
GRANT ALL ON FUNCTION "public"."_compute_promotion_price_only"("p_promotion_id" "uuid", "p_customer_id" "uuid", "p_bundle_qty" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."_compute_promotion_price_only"("p_promotion_id" "uuid", "p_customer_id" "uuid", "p_bundle_qty" numeric) TO "service_role";



REVOKE ALL ON FUNCTION "public"."_compute_promotion_snapshot"("p_promotion_id" "uuid", "p_customer_id" "uuid", "p_warehouse_id" "uuid", "p_bundle_qty" numeric, "p_coupon_code" "text", "p_require_active" boolean) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."_compute_promotion_snapshot"("p_promotion_id" "uuid", "p_customer_id" "uuid", "p_warehouse_id" "uuid", "p_bundle_qty" numeric, "p_coupon_code" "text", "p_require_active" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."_compute_promotion_snapshot"("p_promotion_id" "uuid", "p_customer_id" "uuid", "p_warehouse_id" "uuid", "p_bundle_qty" numeric, "p_coupon_code" "text", "p_require_active" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."_compute_promotion_snapshot"("p_promotion_id" "uuid", "p_customer_id" "uuid", "p_warehouse_id" "uuid", "p_bundle_qty" numeric, "p_coupon_code" "text", "p_require_active" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."_driver_ledger_next_balance"("p_driver_id" "uuid", "p_debit" numeric, "p_credit" numeric) TO "anon";
GRANT ALL ON FUNCTION "public"."_driver_ledger_next_balance"("p_driver_id" "uuid", "p_debit" numeric, "p_credit" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."_driver_ledger_next_balance"("p_driver_id" "uuid", "p_debit" numeric, "p_credit" numeric) TO "service_role";



REVOKE ALL ON FUNCTION "public"."_extract_stock_items_from_order_data"("p_order_data" "jsonb") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."_extract_stock_items_from_order_data"("p_order_data" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."_extract_stock_items_from_order_data"("p_order_data" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."_extract_stock_items_from_order_data"("p_order_data" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."_is_cod_delivery_order"("p_order" "jsonb", "p_delivery_zone_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."_is_cod_delivery_order"("p_order" "jsonb", "p_delivery_zone_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."_is_cod_delivery_order"("p_order" "jsonb", "p_delivery_zone_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."_is_migration_actor"() TO "anon";
GRANT ALL ON FUNCTION "public"."_is_migration_actor"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."_is_migration_actor"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."_merge_stock_items"("p_items" "jsonb") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."_merge_stock_items"("p_items" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."_merge_stock_items"("p_items" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."_merge_stock_items"("p_items" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."_money_round"("p_value" numeric, "p_scale" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."_money_round"("p_value" numeric, "p_scale" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."_money_round"("p_value" numeric, "p_scale" integer) TO "service_role";



REVOKE ALL ON FUNCTION "public"."_require_staff"("p_action" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."_require_staff"("p_action" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."_require_staff"("p_action" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."_require_staff"("p_action" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."_require_stock_manager"("p_action" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."_require_stock_manager"("p_action" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."_require_stock_manager"("p_action" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."_require_stock_manager"("p_action" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."_resolve_batch_sale_failure_reason"("p_item_id" "text", "p_warehouse_id" "uuid", "p_quantity" numeric) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."_resolve_batch_sale_failure_reason"("p_item_id" "text", "p_warehouse_id" "uuid", "p_quantity" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."_resolve_batch_sale_failure_reason"("p_item_id" "text", "p_warehouse_id" "uuid", "p_quantity" numeric) TO "service_role";



REVOKE ALL ON FUNCTION "public"."_resolve_default_admin_warehouse_id"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."_resolve_default_admin_warehouse_id"() TO "anon";
GRANT ALL ON FUNCTION "public"."_resolve_default_admin_warehouse_id"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."_resolve_default_admin_warehouse_id"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."_resolve_default_min_margin_pct"("p_item_id" "text", "p_warehouse_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."_resolve_default_min_margin_pct"("p_item_id" "text", "p_warehouse_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."_resolve_default_min_margin_pct"("p_item_id" "text", "p_warehouse_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."_resolve_default_warehouse_id"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."_resolve_default_warehouse_id"() TO "anon";
GRANT ALL ON FUNCTION "public"."_resolve_default_warehouse_id"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."_resolve_default_warehouse_id"() TO "service_role";



GRANT ALL ON FUNCTION "public"."_resolve_open_shift_for_cash"("p_operator" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."_resolve_open_shift_for_cash"("p_operator" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."_resolve_open_shift_for_cash"("p_operator" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."_sync_order_terms_columns"() TO "anon";
GRANT ALL ON FUNCTION "public"."_sync_order_terms_columns"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."_sync_order_terms_columns"() TO "service_role";



GRANT ALL ON FUNCTION "public"."_trg_purchase_orders_po_number"() TO "anon";
GRANT ALL ON FUNCTION "public"."_trg_purchase_orders_po_number"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."_trg_purchase_orders_po_number"() TO "service_role";



GRANT ALL ON FUNCTION "public"."_uuid_or_null"("p_value" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."_uuid_or_null"("p_value" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."_uuid_or_null"("p_value" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."allocate_landed_cost_to_inventory"("p_shipment_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."allocate_landed_cost_to_inventory"("p_shipment_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."allocate_landed_cost_to_inventory"("p_shipment_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."allocate_landed_cost_to_inventory"("p_shipment_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."allocate_payment_to_open_item"("p_open_item_id" "uuid", "p_payment_id" "uuid", "p_amount" numeric) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."allocate_payment_to_open_item"("p_open_item_id" "uuid", "p_payment_id" "uuid", "p_amount" numeric) TO "anon";
GRANT ALL ON FUNCTION "public"."allocate_payment_to_open_item"("p_open_item_id" "uuid", "p_payment_id" "uuid", "p_amount" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."allocate_payment_to_open_item"("p_open_item_id" "uuid", "p_payment_id" "uuid", "p_amount" numeric) TO "service_role";



REVOKE ALL ON FUNCTION "public"."ap_aging_summary"("p_as_of" "date") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."ap_aging_summary"("p_as_of" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."ap_aging_summary"("p_as_of" "date") TO "service_role";



REVOKE ALL ON FUNCTION "public"."apply_promotion_to_cart"("p_cart_payload" "jsonb", "p_promotion_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."apply_promotion_to_cart"("p_cart_payload" "jsonb", "p_promotion_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."apply_promotion_to_cart"("p_cart_payload" "jsonb", "p_promotion_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."apply_promotion_to_cart"("p_cart_payload" "jsonb", "p_promotion_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."apply_supplier_credit_note"("p_credit_note_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."apply_supplier_credit_note"("p_credit_note_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."apply_supplier_credit_note"("p_credit_note_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."approval_required"("p_request_type" "text", "p_amount" numeric) TO "anon";
GRANT ALL ON FUNCTION "public"."approval_required"("p_request_type" "text", "p_amount" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."approval_required"("p_request_type" "text", "p_amount" numeric) TO "service_role";



GRANT ALL ON FUNCTION "public"."approve_approval_step"("p_request_id" "uuid", "p_step_no" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."approve_approval_step"("p_request_id" "uuid", "p_step_no" integer) TO "service_role";



REVOKE ALL ON FUNCTION "public"."approve_journal_entry"("p_entry_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."approve_journal_entry"("p_entry_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."approve_journal_entry"("p_entry_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."approve_journal_entry"("p_entry_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."ar_aging_as_of"("p_as_of" timestamp with time zone) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."ar_aging_as_of"("p_as_of" timestamp with time zone) TO "anon";
GRANT ALL ON FUNCTION "public"."ar_aging_as_of"("p_as_of" timestamp with time zone) TO "authenticated";
GRANT ALL ON FUNCTION "public"."ar_aging_as_of"("p_as_of" timestamp with time zone) TO "service_role";



REVOKE ALL ON FUNCTION "public"."ar_aging_summary"("p_as_of" "date") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."ar_aging_summary"("p_as_of" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."ar_aging_summary"("p_as_of" "date") TO "service_role";



REVOKE ALL ON FUNCTION "public"."assert_balance_sheet"("p_as_of" timestamp with time zone) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."assert_balance_sheet"("p_as_of" timestamp with time zone) TO "anon";
GRANT ALL ON FUNCTION "public"."assert_balance_sheet"("p_as_of" timestamp with time zone) TO "authenticated";
GRANT ALL ON FUNCTION "public"."assert_balance_sheet"("p_as_of" timestamp with time zone) TO "service_role";



REVOKE ALL ON FUNCTION "public"."assert_trial_balance_by_range"("p_start" "date", "p_end" "date") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."assert_trial_balance_by_range"("p_start" "date", "p_end" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."assert_trial_balance_by_range"("p_start" "date", "p_end" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."assert_trial_balance_by_range"("p_start" "date", "p_end" "date") TO "service_role";



REVOKE ALL ON FUNCTION "public"."assign_invoice_number_if_missing"("p_order_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."assign_invoice_number_if_missing"("p_order_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."assign_invoice_number_if_missing"("p_order_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."audit_changed_columns"("p_old" "jsonb", "p_new" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."audit_changed_columns"("p_old" "jsonb", "p_new" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."audit_changed_columns"("p_old" "jsonb", "p_new" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."audit_get_record_id"("p_table" "text", "p_row" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."audit_get_record_id"("p_table" "text", "p_row" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."audit_get_record_id"("p_table" "text", "p_row" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."audit_row_change"() TO "anon";
GRANT ALL ON FUNCTION "public"."audit_row_change"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."audit_row_change"() TO "service_role";



GRANT ALL ON FUNCTION "public"."audit_table_module"("p_table" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."audit_table_module"("p_table" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."audit_table_module"("p_table" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."backfill_batches_from_movements"() TO "anon";
GRANT ALL ON FUNCTION "public"."backfill_batches_from_movements"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."backfill_batches_from_movements"() TO "service_role";



GRANT ALL ON FUNCTION "public"."balance_sheet"("p_as_of" "date", "p_cost_center_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."balance_sheet"("p_as_of" "date", "p_cost_center_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."balance_sheet"("p_as_of" "date", "p_cost_center_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."balances_as_of"("p_as_of" timestamp with time zone) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."balances_as_of"("p_as_of" timestamp with time zone) TO "anon";
GRANT ALL ON FUNCTION "public"."balances_as_of"("p_as_of" timestamp with time zone) TO "authenticated";
GRANT ALL ON FUNCTION "public"."balances_as_of"("p_as_of" timestamp with time zone) TO "service_role";



GRANT ALL ON FUNCTION "public"."block_writes_during_maintenance"() TO "anon";
GRANT ALL ON FUNCTION "public"."block_writes_during_maintenance"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."block_writes_during_maintenance"() TO "service_role";



GRANT ALL ON FUNCTION "public"."branch_from_warehouse"("p_warehouse_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."branch_from_warehouse"("p_warehouse_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."branch_from_warehouse"("p_warehouse_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."calculate_cash_shift_expected"("p_shift_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."calculate_cash_shift_expected"("p_shift_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_cash_shift_expected"("p_shift_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_cash_shift_expected"("p_shift_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_risk_level"("p_table" "text", "p_op" "text", "p_old" "jsonb", "p_new" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_risk_level"("p_table" "text", "p_op" "text", "p_old" "jsonb", "p_new" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_risk_level"("p_table" "text", "p_op" "text", "p_old" "jsonb", "p_new" "jsonb") TO "service_role";



REVOKE ALL ON FUNCTION "public"."calculate_shipment_landed_cost"("p_shipment_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."calculate_shipment_landed_cost"("p_shipment_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_shipment_landed_cost"("p_shipment_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_three_way_match"("p_invoice_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_three_way_match"("p_invoice_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_three_way_match"("p_invoice_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."can_manage_expenses"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."can_manage_expenses"() TO "anon";
GRANT ALL ON FUNCTION "public"."can_manage_expenses"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."can_manage_expenses"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."can_manage_stock"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."can_manage_stock"() TO "anon";
GRANT ALL ON FUNCTION "public"."can_manage_stock"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."can_manage_stock"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."can_view_accounting_reports"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."can_view_accounting_reports"() TO "anon";
GRANT ALL ON FUNCTION "public"."can_view_accounting_reports"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."can_view_accounting_reports"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."can_view_reports"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."can_view_reports"() TO "anon";
GRANT ALL ON FUNCTION "public"."can_view_reports"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."can_view_reports"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."can_view_sales_reports"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."can_view_sales_reports"() TO "anon";
GRANT ALL ON FUNCTION "public"."can_view_sales_reports"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."can_view_sales_reports"() TO "service_role";



GRANT ALL ON FUNCTION "public"."cancel_order"("p_order_id" "uuid", "p_reason" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."cancel_order"("p_order_id" "uuid", "p_reason" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."cancel_order"("p_order_id" "uuid", "p_reason" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."cancel_order"("p_order_id" "uuid", "p_reason" "text", "p_occurred_at" timestamp with time zone) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."cancel_order"("p_order_id" "uuid", "p_reason" "text", "p_occurred_at" timestamp with time zone) TO "authenticated";
GRANT ALL ON FUNCTION "public"."cancel_order"("p_order_id" "uuid", "p_reason" "text", "p_occurred_at" timestamp with time zone) TO "service_role";



REVOKE ALL ON FUNCTION "public"."cancel_purchase_order"("p_order_id" "uuid", "p_reason" "text", "p_occurred_at" timestamp with time zone) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."cancel_purchase_order"("p_order_id" "uuid", "p_reason" "text", "p_occurred_at" timestamp with time zone) TO "anon";
GRANT ALL ON FUNCTION "public"."cancel_purchase_order"("p_order_id" "uuid", "p_reason" "text", "p_occurred_at" timestamp with time zone) TO "authenticated";
GRANT ALL ON FUNCTION "public"."cancel_purchase_order"("p_order_id" "uuid", "p_reason" "text", "p_occurred_at" timestamp with time zone) TO "service_role";



GRANT ALL ON FUNCTION "public"."cancel_warehouse_transfer"("p_transfer_id" "uuid", "p_reason" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."cancel_warehouse_transfer"("p_transfer_id" "uuid", "p_reason" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."cancel_warehouse_transfer"("p_transfer_id" "uuid", "p_reason" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."cash_flow_detailed"("p_start" "date", "p_end" "date") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."cash_flow_detailed"("p_start" "date", "p_end" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."cash_flow_detailed"("p_start" "date", "p_end" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."cash_flow_detailed"("p_start" "date", "p_end" "date") TO "service_role";



REVOKE ALL ON FUNCTION "public"."cash_flow_statement"("p_start" "date", "p_end" "date", "p_cost_center_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."cash_flow_statement"("p_start" "date", "p_end" "date", "p_cost_center_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."cash_flow_statement"("p_start" "date", "p_end" "date", "p_cost_center_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."check_batch_invariants"("p_item_id" "text", "p_warehouse_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."check_batch_invariants"("p_item_id" "text", "p_warehouse_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."check_batch_invariants"("p_item_id" "text", "p_warehouse_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_batch_invariants"("p_item_id" "text", "p_warehouse_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."check_customer_credit_limit"("p_customer_id" "uuid", "p_order_amount" numeric) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."check_customer_credit_limit"("p_customer_id" "uuid", "p_order_amount" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_customer_credit_limit"("p_customer_id" "uuid", "p_order_amount" numeric) TO "service_role";



REVOKE ALL ON FUNCTION "public"."check_journal_entry_balance"("p_entry_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."check_journal_entry_balance"("p_entry_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."check_journal_entry_balance"("p_entry_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_journal_entry_balance"("p_entry_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."close_accounting_period"("p_period_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."close_accounting_period"("p_period_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."close_accounting_period"("p_period_id" "uuid") TO "service_role";



GRANT ALL ON TABLE "public"."cash_shifts" TO "anon";
GRANT ALL ON TABLE "public"."cash_shifts" TO "authenticated";
GRANT ALL ON TABLE "public"."cash_shifts" TO "service_role";



REVOKE ALL ON FUNCTION "public"."close_cash_shift"("p_shift_id" "uuid", "p_end_amount" numeric, "p_notes" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."close_cash_shift"("p_shift_id" "uuid", "p_end_amount" numeric, "p_notes" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."close_cash_shift"("p_shift_id" "uuid", "p_end_amount" numeric, "p_notes" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."close_cash_shift"("p_shift_id" "uuid", "p_end_amount" numeric, "p_notes" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."close_cash_shift_v2"("p_shift_id" "uuid", "p_end_amount" numeric, "p_notes" "text", "p_forced_reason" "text", "p_denomination_counts" "jsonb", "p_tender_counts" "jsonb") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."close_cash_shift_v2"("p_shift_id" "uuid", "p_end_amount" numeric, "p_notes" "text", "p_forced_reason" "text", "p_denomination_counts" "jsonb", "p_tender_counts" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."close_cash_shift_v2"("p_shift_id" "uuid", "p_end_amount" numeric, "p_notes" "text", "p_forced_reason" "text", "p_denomination_counts" "jsonb", "p_tender_counts" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."close_cash_shift_v2"("p_shift_id" "uuid", "p_end_amount" numeric, "p_notes" "text", "p_forced_reason" "text", "p_denomination_counts" "jsonb", "p_tender_counts" "jsonb") TO "service_role";



REVOKE ALL ON FUNCTION "public"."cod_post_delivery"("p_order_id" "uuid", "p_driver_id" "uuid", "p_occurred_at" timestamp with time zone) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."cod_post_delivery"("p_order_id" "uuid", "p_driver_id" "uuid", "p_occurred_at" timestamp with time zone) TO "anon";
GRANT ALL ON FUNCTION "public"."cod_post_delivery"("p_order_id" "uuid", "p_driver_id" "uuid", "p_occurred_at" timestamp with time zone) TO "authenticated";
GRANT ALL ON FUNCTION "public"."cod_post_delivery"("p_order_id" "uuid", "p_driver_id" "uuid", "p_occurred_at" timestamp with time zone) TO "service_role";



REVOKE ALL ON FUNCTION "public"."cod_settle_order"("p_order_id" "uuid", "p_occurred_at" timestamp with time zone) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."cod_settle_order"("p_order_id" "uuid", "p_occurred_at" timestamp with time zone) TO "anon";
GRANT ALL ON FUNCTION "public"."cod_settle_order"("p_order_id" "uuid", "p_occurred_at" timestamp with time zone) TO "authenticated";
GRANT ALL ON FUNCTION "public"."cod_settle_order"("p_order_id" "uuid", "p_occurred_at" timestamp with time zone) TO "service_role";



REVOKE ALL ON FUNCTION "public"."cod_settle_orders"("p_driver_id" "uuid", "p_order_ids" "uuid"[], "p_occurred_at" timestamp with time zone) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."cod_settle_orders"("p_driver_id" "uuid", "p_order_ids" "uuid"[], "p_occurred_at" timestamp with time zone) TO "anon";
GRANT ALL ON FUNCTION "public"."cod_settle_orders"("p_driver_id" "uuid", "p_order_ids" "uuid"[], "p_occurred_at" timestamp with time zone) TO "authenticated";
GRANT ALL ON FUNCTION "public"."cod_settle_orders"("p_driver_id" "uuid", "p_order_ids" "uuid"[], "p_occurred_at" timestamp with time zone) TO "service_role";



REVOKE ALL ON FUNCTION "public"."cogs_reconciliation_by_range"("p_start" "date", "p_end" "date") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."cogs_reconciliation_by_range"("p_start" "date", "p_end" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."cogs_reconciliation_by_range"("p_start" "date", "p_end" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."cogs_reconciliation_by_range"("p_start" "date", "p_end" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."company_from_branch"("p_branch_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."company_from_branch"("p_branch_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."company_from_branch"("p_branch_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."complete_warehouse_transfer"("p_transfer_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."complete_warehouse_transfer"("p_transfer_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."complete_warehouse_transfer"("p_transfer_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."complete_warehouse_transfer"("p_transfer_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."compute_customer_ar_balance"("p_customer_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."compute_customer_ar_balance"("p_customer_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."compute_customer_ar_balance"("p_customer_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."compute_customer_ar_balance_in_company"("p_customer_id" "uuid", "p_company_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."compute_customer_ar_balance_in_company"("p_customer_id" "uuid", "p_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."compute_customer_ar_balance_in_company"("p_customer_id" "uuid", "p_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."compute_order_tax_lines"("p_order_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."compute_order_tax_lines"("p_order_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."compute_order_tax_lines"("p_order_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."confirm_order_delivery"("p_payload" "jsonb") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."confirm_order_delivery"("p_payload" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."confirm_order_delivery"("p_payload" "jsonb") TO "service_role";



REVOKE ALL ON FUNCTION "public"."confirm_order_delivery"("p_order_id" "uuid", "p_items" "jsonb", "p_updated_data" "jsonb", "p_warehouse_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."confirm_order_delivery"("p_order_id" "uuid", "p_items" "jsonb", "p_updated_data" "jsonb", "p_warehouse_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."confirm_order_delivery"("p_order_id" "uuid", "p_items" "jsonb", "p_updated_data" "jsonb", "p_warehouse_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."confirm_order_delivery_with_credit"("p_payload" "jsonb") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."confirm_order_delivery_with_credit"("p_payload" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."confirm_order_delivery_with_credit"("p_payload" "jsonb") TO "service_role";



REVOKE ALL ON FUNCTION "public"."confirm_order_delivery_with_credit"("p_order_id" "uuid", "p_items" "jsonb", "p_updated_data" "jsonb", "p_warehouse_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."confirm_order_delivery_with_credit"("p_order_id" "uuid", "p_items" "jsonb", "p_updated_data" "jsonb", "p_warehouse_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."confirm_order_delivery_with_credit"("p_order_id" "uuid", "p_items" "jsonb", "p_updated_data" "jsonb", "p_warehouse_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."convert_qty"("p_qty" numeric, "p_from" "uuid", "p_to" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."convert_qty"("p_qty" numeric, "p_from" "uuid", "p_to" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."convert_qty"("p_qty" numeric, "p_from" "uuid", "p_to" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_accounting_document"("p_document_type" "text", "p_source_table" "text", "p_source_id" "text", "p_branch_id" "uuid", "p_company_id" "uuid", "p_memo" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."create_accounting_document"("p_document_type" "text", "p_source_table" "text", "p_source_id" "text", "p_branch_id" "uuid", "p_company_id" "uuid", "p_memo" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_accounting_document"("p_document_type" "text", "p_source_table" "text", "p_source_id" "text", "p_branch_id" "uuid", "p_company_id" "uuid", "p_memo" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_approval_request"("p_target_table" "text", "p_target_id" "text", "p_request_type" "text", "p_amount" numeric, "p_payload" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_approval_request"("p_target_table" "text", "p_target_id" "text", "p_request_type" "text", "p_amount" numeric, "p_payload" "jsonb") TO "service_role";



REVOKE ALL ON FUNCTION "public"."create_chart_account"("p_code" "text", "p_name" "text", "p_account_type" "text", "p_normal_balance" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."create_chart_account"("p_code" "text", "p_name" "text", "p_account_type" "text", "p_normal_balance" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."create_chart_account"("p_code" "text", "p_name" "text", "p_account_type" "text", "p_normal_balance" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_chart_account"("p_code" "text", "p_name" "text", "p_account_type" "text", "p_normal_balance" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."create_inventory_transfer"("p_from_warehouse_id" "uuid", "p_to_warehouse_id" "uuid", "p_items" "jsonb", "p_transfer_date" "date", "p_notes" "text", "p_idempotency_key" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."create_inventory_transfer"("p_from_warehouse_id" "uuid", "p_to_warehouse_id" "uuid", "p_items" "jsonb", "p_transfer_date" "date", "p_notes" "text", "p_idempotency_key" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."create_inventory_transfer"("p_from_warehouse_id" "uuid", "p_to_warehouse_id" "uuid", "p_items" "jsonb", "p_transfer_date" "date", "p_notes" "text", "p_idempotency_key" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_inventory_transfer"("p_from_warehouse_id" "uuid", "p_to_warehouse_id" "uuid", "p_items" "jsonb", "p_transfer_date" "date", "p_notes" "text", "p_idempotency_key" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."create_manual_journal_entry"("p_entry_date" timestamp with time zone, "p_memo" "text", "p_lines" "jsonb") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."create_manual_journal_entry"("p_entry_date" timestamp with time zone, "p_memo" "text", "p_lines" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_manual_journal_entry"("p_entry_date" timestamp with time zone, "p_memo" "text", "p_lines" "jsonb") TO "service_role";



REVOKE ALL ON FUNCTION "public"."create_order_secure"("p_items" "jsonb", "p_delivery_zone_id" "uuid", "p_payment_method" "text", "p_notes" "text", "p_address" "text", "p_location" "jsonb", "p_customer_name" "text", "p_phone_number" "text", "p_is_scheduled" boolean, "p_scheduled_at" timestamp with time zone, "p_coupon_code" "text", "p_points_redeemed_value" numeric) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."create_order_secure"("p_items" "jsonb", "p_delivery_zone_id" "uuid", "p_payment_method" "text", "p_notes" "text", "p_address" "text", "p_location" "jsonb", "p_customer_name" "text", "p_phone_number" "text", "p_is_scheduled" boolean, "p_scheduled_at" timestamp with time zone, "p_coupon_code" "text", "p_points_redeemed_value" numeric) TO "anon";
GRANT ALL ON FUNCTION "public"."create_order_secure"("p_items" "jsonb", "p_delivery_zone_id" "uuid", "p_payment_method" "text", "p_notes" "text", "p_address" "text", "p_location" "jsonb", "p_customer_name" "text", "p_phone_number" "text", "p_is_scheduled" boolean, "p_scheduled_at" timestamp with time zone, "p_coupon_code" "text", "p_points_redeemed_value" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_order_secure"("p_items" "jsonb", "p_delivery_zone_id" "uuid", "p_payment_method" "text", "p_notes" "text", "p_address" "text", "p_location" "jsonb", "p_customer_name" "text", "p_phone_number" "text", "p_is_scheduled" boolean, "p_scheduled_at" timestamp with time zone, "p_coupon_code" "text", "p_points_redeemed_value" numeric) TO "service_role";



GRANT ALL ON FUNCTION "public"."create_order_secure"("p_items" "jsonb", "p_delivery_zone_id" "uuid", "p_payment_method" "text", "p_notes" "text", "p_address" "text", "p_location" "jsonb", "p_customer_name" "text", "p_phone_number" "text", "p_is_scheduled" boolean, "p_scheduled_at" timestamp with time zone, "p_coupon_code" "text", "p_points_redeemed_value" numeric, "p_explicit_customer_id" "uuid", "p_order_source" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."create_order_secure"("p_items" "jsonb", "p_delivery_zone_id" "uuid", "p_payment_method" "text", "p_notes" "text", "p_address" "text", "p_location" "jsonb", "p_customer_name" "text", "p_phone_number" "text", "p_is_scheduled" boolean, "p_scheduled_at" timestamp with time zone, "p_coupon_code" "text", "p_points_redeemed_value" numeric, "p_explicit_customer_id" "uuid", "p_order_source" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_order_secure"("p_items" "jsonb", "p_delivery_zone_id" "uuid", "p_payment_method" "text", "p_notes" "text", "p_address" "text", "p_location" "jsonb", "p_customer_name" "text", "p_phone_number" "text", "p_is_scheduled" boolean, "p_scheduled_at" timestamp with time zone, "p_coupon_code" "text", "p_points_redeemed_value" numeric, "p_explicit_customer_id" "uuid", "p_order_source" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."create_order_secure_with_payment_proof"("p_items" "jsonb", "p_delivery_zone_id" "uuid", "p_payment_method" "text", "p_notes" "text", "p_address" "text", "p_location" "jsonb", "p_customer_name" "text", "p_phone_number" "text", "p_is_scheduled" boolean, "p_scheduled_at" timestamp with time zone, "p_coupon_code" "text", "p_points_redeemed_value" numeric, "p_payment_proof_type" "text", "p_payment_proof" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."create_order_secure_with_payment_proof"("p_items" "jsonb", "p_delivery_zone_id" "uuid", "p_payment_method" "text", "p_notes" "text", "p_address" "text", "p_location" "jsonb", "p_customer_name" "text", "p_phone_number" "text", "p_is_scheduled" boolean, "p_scheduled_at" timestamp with time zone, "p_coupon_code" "text", "p_points_redeemed_value" numeric, "p_payment_proof_type" "text", "p_payment_proof" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."create_order_secure_with_payment_proof"("p_items" "jsonb", "p_delivery_zone_id" "uuid", "p_payment_method" "text", "p_notes" "text", "p_address" "text", "p_location" "jsonb", "p_customer_name" "text", "p_phone_number" "text", "p_is_scheduled" boolean, "p_scheduled_at" timestamp with time zone, "p_coupon_code" "text", "p_points_redeemed_value" numeric, "p_payment_proof_type" "text", "p_payment_proof" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_order_secure_with_payment_proof"("p_items" "jsonb", "p_delivery_zone_id" "uuid", "p_payment_method" "text", "p_notes" "text", "p_address" "text", "p_location" "jsonb", "p_customer_name" "text", "p_phone_number" "text", "p_is_scheduled" boolean, "p_scheduled_at" timestamp with time zone, "p_coupon_code" "text", "p_points_redeemed_value" numeric, "p_payment_proof_type" "text", "p_payment_proof" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_order_secure_with_payment_proof"("p_items" "jsonb", "p_delivery_zone_id" "uuid", "p_payment_method" "text", "p_notes" "text", "p_address" "text", "p_location" "jsonb", "p_customer_name" "text", "p_phone_number" "text", "p_is_scheduled" boolean, "p_scheduled_at" timestamp with time zone, "p_coupon_code" "text", "p_points_redeemed_value" numeric, "p_payment_proof_type" "text", "p_payment_proof" "text", "p_order_source" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."create_order_secure_with_payment_proof"("p_items" "jsonb", "p_delivery_zone_id" "uuid", "p_payment_method" "text", "p_notes" "text", "p_address" "text", "p_location" "jsonb", "p_customer_name" "text", "p_phone_number" "text", "p_is_scheduled" boolean, "p_scheduled_at" timestamp with time zone, "p_coupon_code" "text", "p_points_redeemed_value" numeric, "p_payment_proof_type" "text", "p_payment_proof" "text", "p_order_source" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_order_secure_with_payment_proof"("p_items" "jsonb", "p_delivery_zone_id" "uuid", "p_payment_method" "text", "p_notes" "text", "p_address" "text", "p_location" "jsonb", "p_customer_name" "text", "p_phone_number" "text", "p_is_scheduled" boolean, "p_scheduled_at" timestamp with time zone, "p_coupon_code" "text", "p_points_redeemed_value" numeric, "p_payment_proof_type" "text", "p_payment_proof" "text", "p_order_source" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_order_secure_with_payment_proof"("p_items" "jsonb", "p_delivery_zone_id" "uuid", "p_payment_method" "text", "p_notes" "text", "p_address" "text", "p_location" "jsonb", "p_customer_name" "text", "p_phone_number" "text", "p_is_scheduled" boolean, "p_scheduled_at" timestamp with time zone, "p_coupon_code" "text", "p_points_redeemed_value" numeric, "p_payment_proof_type" "text", "p_payment_proof" "text", "p_order_source" "text", "p_explicit_customer_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."create_order_secure_with_payment_proof"("p_items" "jsonb", "p_delivery_zone_id" "uuid", "p_payment_method" "text", "p_notes" "text", "p_address" "text", "p_location" "jsonb", "p_customer_name" "text", "p_phone_number" "text", "p_is_scheduled" boolean, "p_scheduled_at" timestamp with time zone, "p_coupon_code" "text", "p_points_redeemed_value" numeric, "p_payment_proof_type" "text", "p_payment_proof" "text", "p_order_source" "text", "p_explicit_customer_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_order_secure_with_payment_proof"("p_items" "jsonb", "p_delivery_zone_id" "uuid", "p_payment_method" "text", "p_notes" "text", "p_address" "text", "p_location" "jsonb", "p_customer_name" "text", "p_phone_number" "text", "p_is_scheduled" boolean, "p_scheduled_at" timestamp with time zone, "p_coupon_code" "text", "p_points_redeemed_value" numeric, "p_payment_proof_type" "text", "p_payment_proof" "text", "p_order_source" "text", "p_explicit_customer_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."create_production_order"("p_inputs" "jsonb", "p_outputs" "jsonb", "p_notes" "text", "p_occurred_at" timestamp with time zone) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."create_production_order"("p_inputs" "jsonb", "p_outputs" "jsonb", "p_notes" "text", "p_occurred_at" timestamp with time zone) TO "anon";
GRANT ALL ON FUNCTION "public"."create_production_order"("p_inputs" "jsonb", "p_outputs" "jsonb", "p_notes" "text", "p_occurred_at" timestamp with time zone) TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_production_order"("p_inputs" "jsonb", "p_outputs" "jsonb", "p_notes" "text", "p_occurred_at" timestamp with time zone) TO "service_role";



REVOKE ALL ON FUNCTION "public"."create_purchase_return"("p_order_id" "uuid", "p_items" "jsonb", "p_reason" "text", "p_occurred_at" timestamp with time zone) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."create_purchase_return"("p_order_id" "uuid", "p_items" "jsonb", "p_reason" "text", "p_occurred_at" timestamp with time zone) TO "anon";
GRANT ALL ON FUNCTION "public"."create_purchase_return"("p_order_id" "uuid", "p_items" "jsonb", "p_reason" "text", "p_occurred_at" timestamp with time zone) TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_purchase_return"("p_order_id" "uuid", "p_items" "jsonb", "p_reason" "text", "p_occurred_at" timestamp with time zone) TO "service_role";



GRANT ALL ON FUNCTION "public"."create_reversal_entry"("p_entry_id" "uuid", "p_reason" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."create_reversal_entry"("p_entry_id" "uuid", "p_reason" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_reversal_entry"("p_entry_id" "uuid", "p_reason" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."deactivate_promotion"("p_promotion_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."deactivate_promotion"("p_promotion_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."deactivate_promotion"("p_promotion_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."deactivate_promotion"("p_promotion_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."decrypt_text"("p_encrypted" "bytea") TO "anon";
GRANT ALL ON FUNCTION "public"."decrypt_text"("p_encrypted" "bytea") TO "authenticated";
GRANT ALL ON FUNCTION "public"."decrypt_text"("p_encrypted" "bytea") TO "service_role";



GRANT ALL ON FUNCTION "public"."deduct_stock_on_delivery_v2"("p_order_id" "uuid", "p_items" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."deduct_stock_on_delivery_v2"("p_order_id" "uuid", "p_items" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."deduct_stock_on_delivery_v2"("p_order_id" "uuid", "p_items" "jsonb") TO "service_role";



REVOKE ALL ON FUNCTION "public"."deduct_stock_on_delivery_v2"("p_order_id" "uuid", "p_items" "jsonb", "p_warehouse_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."deduct_stock_on_delivery_v2"("p_order_id" "uuid", "p_items" "jsonb", "p_warehouse_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."deduct_stock_on_delivery_v2"("p_order_id" "uuid", "p_items" "jsonb", "p_warehouse_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."deduct_stock_on_delivery_v2"("p_order_id" "uuid", "p_items" "jsonb", "p_warehouse_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."delete_user_account"("target_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."delete_user_account"("target_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."delete_user_account"("target_user_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."dispatch_inventory_transfer"("p_transfer_id" "uuid", "p_idempotency_key" "text", "p_cancel" boolean) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."dispatch_inventory_transfer"("p_transfer_id" "uuid", "p_idempotency_key" "text", "p_cancel" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."dispatch_inventory_transfer"("p_transfer_id" "uuid", "p_idempotency_key" "text", "p_cancel" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."dispatch_inventory_transfer"("p_transfer_id" "uuid", "p_idempotency_key" "text", "p_cancel" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."encrypt_text"("p_text" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."encrypt_text"("p_text" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."encrypt_text"("p_text" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."enforce_purchase_items_editability"() TO "anon";
GRANT ALL ON FUNCTION "public"."enforce_purchase_items_editability"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."enforce_purchase_items_editability"() TO "service_role";



GRANT ALL ON FUNCTION "public"."enforce_purchase_orders_status_transition"() TO "anon";
GRANT ALL ON FUNCTION "public"."enforce_purchase_orders_status_transition"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."enforce_purchase_orders_status_transition"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."flag_payment_allocation_status"("p_payment_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."flag_payment_allocation_status"("p_payment_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."flag_payment_allocation_status"("p_payment_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."flag_payment_allocation_status"("p_payment_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."general_ledger"("p_account_code" "text", "p_start" "date", "p_end" "date", "p_cost_center_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."general_ledger"("p_account_code" "text", "p_start" "date", "p_end" "date", "p_cost_center_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."general_ledger"("p_account_code" "text", "p_start" "date", "p_end" "date", "p_cost_center_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."generate_accounting_period_snapshot"("p_period_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."generate_accounting_period_snapshot"("p_period_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."generate_accounting_period_snapshot"("p_period_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_accounting_period_snapshot"("p_period_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_invoice_number"() TO "anon";
GRANT ALL ON FUNCTION "public"."generate_invoice_number"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_invoice_number"() TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_transfer_number"() TO "anon";
GRANT ALL ON FUNCTION "public"."generate_transfer_number"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_transfer_number"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_account_id_by_code"("p_code" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_account_id_by_code"("p_code" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_account_id_by_code"("p_code" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_account_id_by_code"("p_code" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_active_promotions"("p_customer_id" "uuid", "p_warehouse_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_active_promotions"("p_customer_id" "uuid", "p_warehouse_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_active_promotions"("p_customer_id" "uuid", "p_warehouse_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_active_promotions"("p_customer_id" "uuid", "p_warehouse_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_admin_session_scope"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_admin_session_scope"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_admin_session_scope"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_admin_session_scope"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_base_currency"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_base_currency"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_base_currency"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_batch_recall_orders"("p_batch_id" "uuid", "p_warehouse_id" "uuid", "p_branch_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_batch_recall_orders"("p_batch_id" "uuid", "p_warehouse_id" "uuid", "p_branch_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_batch_recall_orders"("p_batch_id" "uuid", "p_warehouse_id" "uuid", "p_branch_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_batch_recall_orders"("p_batch_id" "uuid", "p_warehouse_id" "uuid", "p_branch_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_catalog_with_stock"("p_category" "text", "p_search" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_catalog_with_stock"("p_category" "text", "p_search" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_catalog_with_stock"("p_category" "text", "p_search" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_cod_audit"("p_order_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_cod_audit"("p_order_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_cod_audit"("p_order_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_cod_audit"("p_order_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_coupon_by_code"("p_code" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_coupon_by_code"("p_code" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_coupon_by_code"("p_code" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_coupon_by_code"("p_code" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_customer_credit_summary"("p_customer_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_customer_credit_summary"("p_customer_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_customer_credit_summary"("p_customer_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_daily_sales_stats"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_daily_sales_stats"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_daily_sales_stats"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_default_branch_id"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_default_branch_id"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_default_branch_id"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_default_company_id"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_default_company_id"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_default_company_id"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_driver_performance_stats"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_driver_performance_stats"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_driver_performance_stats"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_expiring_contracts"("days_threshold" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_expiring_contracts"("days_threshold" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_expiring_contracts"("days_threshold" integer) TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_fefo_pricing"("p_item_id" "uuid", "p_warehouse_id" "uuid", "p_quantity" numeric) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_fefo_pricing"("p_item_id" "uuid", "p_warehouse_id" "uuid", "p_quantity" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_fefo_pricing"("p_item_id" "uuid", "p_warehouse_id" "uuid", "p_quantity" numeric) TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_fefo_pricing"("p_item_id" "uuid", "p_warehouse_id" "uuid", "p_quantity" numeric, "p_customer_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_fefo_pricing"("p_item_id" "uuid", "p_warehouse_id" "uuid", "p_quantity" numeric, "p_customer_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_fefo_pricing"("p_item_id" "uuid", "p_warehouse_id" "uuid", "p_quantity" numeric, "p_customer_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_food_expired_in_stock_alert"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_food_expired_in_stock_alert"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_food_expired_in_stock_alert"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_food_expired_in_stock_alert"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_food_near_expiry_alert"("p_threshold_days" integer) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_food_near_expiry_alert"("p_threshold_days" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_food_near_expiry_alert"("p_threshold_days" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_food_near_expiry_alert"("p_threshold_days" integer) TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_food_reservation_block_reason"("p_item_id" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_food_reservation_block_reason"("p_item_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_food_reservation_block_reason"("p_item_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_food_reservation_block_reason"("p_item_id" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_food_sales_movements_report"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_warehouse_id" "uuid", "p_branch_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_food_sales_movements_report"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_warehouse_id" "uuid", "p_branch_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_food_sales_movements_report"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_warehouse_id" "uuid", "p_branch_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_food_sales_movements_report"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_warehouse_id" "uuid", "p_branch_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_fx_rate"("p_currency" "text", "p_date" "date", "p_rate_type" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_fx_rate"("p_currency" "text", "p_date" "date", "p_rate_type" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_fx_rate"("p_currency" "text", "p_date" "date", "p_rate_type" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_hourly_sales_stats"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_hourly_sales_stats"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_hourly_sales_stats"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean) TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_invoice_audit"("p_order_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_invoice_audit"("p_order_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_invoice_audit"("p_order_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_invoice_audit"("p_order_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_item_all_prices"("p_item_id" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_item_all_prices"("p_item_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_item_all_prices"("p_item_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_item_all_prices"("p_item_id" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_item_batches"("p_item_id" "uuid", "p_warehouse_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_item_batches"("p_item_id" "uuid", "p_warehouse_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_item_batches"("p_item_id" "uuid", "p_warehouse_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_item_batches"("p_item_id" "uuid", "p_warehouse_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_item_discount"("p_item_id" "text", "p_quantity" numeric, "p_customer_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_item_discount"("p_item_id" "text", "p_quantity" numeric, "p_customer_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_item_discount"("p_item_id" "text", "p_quantity" numeric, "p_customer_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_item_discount"("p_item_id" "text", "p_quantity" numeric, "p_customer_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_item_price"("p_item_id" "text", "p_quantity" numeric, "p_customer_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_item_price"("p_item_id" "text", "p_quantity" numeric, "p_customer_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_item_price"("p_item_id" "text", "p_quantity" numeric, "p_customer_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_item_price"("p_item_id" "text", "p_quantity" numeric, "p_customer_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_item_price_with_discount"("p_item_id" "uuid", "p_customer_id" "uuid", "p_quantity" numeric) TO "anon";
GRANT ALL ON FUNCTION "public"."get_item_price_with_discount"("p_item_id" "uuid", "p_customer_id" "uuid", "p_quantity" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_item_price_with_discount"("p_item_id" "uuid", "p_customer_id" "uuid", "p_quantity" numeric) TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_item_suggested_sell_price"("p_item_id" "text", "p_warehouse_id" "uuid", "p_cost_per_unit" numeric, "p_margin_pct" numeric) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_item_suggested_sell_price"("p_item_id" "text", "p_warehouse_id" "uuid", "p_cost_per_unit" numeric, "p_margin_pct" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_item_suggested_sell_price"("p_item_id" "text", "p_warehouse_id" "uuid", "p_cost_per_unit" numeric, "p_margin_pct" numeric) TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_open_reservations_report"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_warehouse_id" "uuid", "p_search" "text", "p_limit" integer, "p_offset" integer) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_open_reservations_report"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_warehouse_id" "uuid", "p_search" "text", "p_limit" integer, "p_offset" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_open_reservations_report"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_warehouse_id" "uuid", "p_search" "text", "p_limit" integer, "p_offset" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_open_reservations_report"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_warehouse_id" "uuid", "p_search" "text", "p_limit" integer, "p_offset" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_or_create_uom"("p_code" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_or_create_uom"("p_code" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_or_create_uom"("p_code" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_order_customer_type"("p_order_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_order_customer_type"("p_order_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_order_customer_type"("p_order_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_order_item_reservations"("p_order_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_order_item_reservations"("p_order_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_order_item_reservations"("p_order_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_order_item_reservations"("p_order_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_order_source_revenue"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_order_source_revenue"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_order_source_revenue"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean) TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_payment_method_stats"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_payment_method_stats"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_payment_method_stats"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean) TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_pos_offline_sales_dashboard"("p_state" "text", "p_limit" integer) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_pos_offline_sales_dashboard"("p_state" "text", "p_limit" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_pos_offline_sales_dashboard"("p_state" "text", "p_limit" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_pos_offline_sales_dashboard"("p_state" "text", "p_limit" integer) TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_product_sales_quantity_from_movements"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_product_sales_quantity_from_movements"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_product_sales_quantity_from_movements"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_product_sales_quantity_from_movements"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_product_sales_report_v9"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_product_sales_report_v9"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_product_sales_report_v9"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean) TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_promotion_expense_drilldown"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_min_amount" numeric) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_promotion_expense_drilldown"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_min_amount" numeric) TO "anon";
GRANT ALL ON FUNCTION "public"."get_promotion_expense_drilldown"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_min_amount" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_promotion_expense_drilldown"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_min_amount" numeric) TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_promotion_performance"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_promotion_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_promotion_performance"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_promotion_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_promotion_performance"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_promotion_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_promotion_usage_drilldown"("p_promotion_id" "uuid", "p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_promotion_usage_drilldown"("p_promotion_id" "uuid", "p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone) TO "anon";
GRANT ALL ON FUNCTION "public"."get_promotion_usage_drilldown"("p_promotion_id" "uuid", "p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_promotion_usage_drilldown"("p_promotion_id" "uuid", "p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone) TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_promotions_admin"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_promotions_admin"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_promotions_admin"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_promotions_admin"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_sales_by_category"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_sales_by_category"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_sales_by_category"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean) TO "service_role";



REVOKE ALL ON FUNCTION "public"."get_sales_report_orders"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean, "p_search" "text", "p_limit" integer, "p_offset" integer) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_sales_report_orders"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean, "p_search" "text", "p_limit" integer, "p_offset" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_sales_report_orders"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean, "p_search" "text", "p_limit" integer, "p_offset" integer) TO "service_role";
GRANT ALL ON FUNCTION "public"."get_sales_report_orders"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean, "p_search" "text", "p_limit" integer, "p_offset" integer) TO "anon";



REVOKE ALL ON FUNCTION "public"."get_sales_report_summary"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."get_sales_report_summary"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_sales_report_summary"("p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_zone_id" "uuid", "p_invoice_only" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."guard_admin_users_update"() TO "anon";
GRANT ALL ON FUNCTION "public"."guard_admin_users_update"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."guard_admin_users_update"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."has_admin_permission"("p" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."has_admin_permission"("p" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."has_admin_permission"("p" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."has_admin_permission"("p" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."haversine_distance_meters"("lat1" double precision, "lng1" double precision, "lat2" double precision, "lng2" double precision) TO "anon";
GRANT ALL ON FUNCTION "public"."haversine_distance_meters"("lat1" double precision, "lng1" double precision, "lat2" double precision, "lng2" double precision) TO "authenticated";
GRANT ALL ON FUNCTION "public"."haversine_distance_meters"("lat1" double precision, "lng1" double precision, "lat2" double precision, "lng2" double precision) TO "service_role";



GRANT ALL ON FUNCTION "public"."income_statement"("p_start" "date", "p_end" "date", "p_cost_center_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."income_statement"("p_start" "date", "p_end" "date", "p_cost_center_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."income_statement"("p_start" "date", "p_end" "date", "p_cost_center_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."income_statement_series"("p_start" "date", "p_end" "date", "p_cost_center_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."income_statement_series"("p_start" "date", "p_end" "date", "p_cost_center_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."income_statement_series"("p_start" "date", "p_end" "date", "p_cost_center_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."inv_batch_vs_stock_invariant"() TO "anon";
GRANT ALL ON FUNCTION "public"."inv_batch_vs_stock_invariant"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."inv_batch_vs_stock_invariant"() TO "service_role";



GRANT ALL ON FUNCTION "public"."inv_cogs_outside_inventory_movements"() TO "anon";
GRANT ALL ON FUNCTION "public"."inv_cogs_outside_inventory_movements"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."inv_cogs_outside_inventory_movements"() TO "service_role";



GRANT ALL ON FUNCTION "public"."inv_duplicate_sale_out_lines"() TO "anon";
GRANT ALL ON FUNCTION "public"."inv_duplicate_sale_out_lines"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."inv_duplicate_sale_out_lines"() TO "service_role";



GRANT ALL ON FUNCTION "public"."inv_duplicate_transfer_movements"() TO "anon";
GRANT ALL ON FUNCTION "public"."inv_duplicate_transfer_movements"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."inv_duplicate_transfer_movements"() TO "service_role";



GRANT ALL ON FUNCTION "public"."inv_expired_batches_with_remaining"() TO "anon";
GRANT ALL ON FUNCTION "public"."inv_expired_batches_with_remaining"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."inv_expired_batches_with_remaining"() TO "service_role";



GRANT ALL ON FUNCTION "public"."inv_journal_entries_for_transfer_movements"() TO "anon";
GRANT ALL ON FUNCTION "public"."inv_journal_entries_for_transfer_movements"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."inv_journal_entries_for_transfer_movements"() TO "service_role";



GRANT ALL ON FUNCTION "public"."inv_negative_batch_remaining"() TO "anon";
GRANT ALL ON FUNCTION "public"."inv_negative_batch_remaining"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."inv_negative_batch_remaining"() TO "service_role";



GRANT ALL ON FUNCTION "public"."inv_negative_stock"() TO "anon";
GRANT ALL ON FUNCTION "public"."inv_negative_stock"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."inv_negative_stock"() TO "service_role";



GRANT ALL ON FUNCTION "public"."inv_sale_out_from_expired_batches"() TO "anon";
GRANT ALL ON FUNCTION "public"."inv_sale_out_from_expired_batches"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."inv_sale_out_from_expired_batches"() TO "service_role";



GRANT ALL ON FUNCTION "public"."inv_transfer_batch_lineage_mismatch"() TO "anon";
GRANT ALL ON FUNCTION "public"."inv_transfer_batch_lineage_mismatch"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."inv_transfer_batch_lineage_mismatch"() TO "service_role";



GRANT ALL ON FUNCTION "public"."inv_transfer_global_qty_invariant"() TO "anon";
GRANT ALL ON FUNCTION "public"."inv_transfer_global_qty_invariant"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."inv_transfer_global_qty_invariant"() TO "service_role";



GRANT ALL ON FUNCTION "public"."inv_transfer_movements_in_cogs"() TO "anon";
GRANT ALL ON FUNCTION "public"."inv_transfer_movements_in_cogs"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."inv_transfer_movements_in_cogs"() TO "service_role";



GRANT ALL ON FUNCTION "public"."inv_transfer_qty_mismatch"() TO "anon";
GRANT ALL ON FUNCTION "public"."inv_transfer_qty_mismatch"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."inv_transfer_qty_mismatch"() TO "service_role";



GRANT ALL ON FUNCTION "public"."inv_transfer_state_mismatch"() TO "anon";
GRANT ALL ON FUNCTION "public"."inv_transfer_state_mismatch"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."inv_transfer_state_mismatch"() TO "service_role";



GRANT ALL ON FUNCTION "public"."inv_transfer_unit_cost_mismatch"() TO "anon";
GRANT ALL ON FUNCTION "public"."inv_transfer_unit_cost_mismatch"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."inv_transfer_unit_cost_mismatch"() TO "service_role";



GRANT ALL ON FUNCTION "public"."is_active_admin"() TO "anon";
GRANT ALL ON FUNCTION "public"."is_active_admin"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_active_admin"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."is_admin"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."is_admin"() TO "anon";
GRANT ALL ON FUNCTION "public"."is_admin"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_admin"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."is_in_closed_period"("p_ts" timestamp with time zone) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."is_in_closed_period"("p_ts" timestamp with time zone) TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_in_closed_period"("p_ts" timestamp with time zone) TO "service_role";



GRANT ALL ON FUNCTION "public"."is_maintenance_on"() TO "anon";
GRANT ALL ON FUNCTION "public"."is_maintenance_on"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_maintenance_on"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."is_owner"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."is_owner"() TO "anon";
GRANT ALL ON FUNCTION "public"."is_owner"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_owner"() TO "service_role";



GRANT ALL ON FUNCTION "public"."is_owner_or_manager"() TO "anon";
GRANT ALL ON FUNCTION "public"."is_owner_or_manager"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_owner_or_manager"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."is_staff"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."is_staff"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_staff"() TO "service_role";



GRANT ALL ON FUNCTION "public"."issue_invoice_on_delivery"() TO "anon";
GRANT ALL ON FUNCTION "public"."issue_invoice_on_delivery"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."issue_invoice_on_delivery"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."list_active_accounts"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."list_active_accounts"() TO "anon";
GRANT ALL ON FUNCTION "public"."list_active_accounts"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."list_active_accounts"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."list_approval_requests"("p_status" "text", "p_limit" integer) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."list_approval_requests"("p_status" "text", "p_limit" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."list_approval_requests"("p_status" "text", "p_limit" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."list_approval_requests"("p_status" "text", "p_limit" integer) TO "service_role";



REVOKE ALL ON FUNCTION "public"."list_approval_steps"("p_request_ids" "uuid"[]) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."list_approval_steps"("p_request_ids" "uuid"[]) TO "anon";
GRANT ALL ON FUNCTION "public"."list_approval_steps"("p_request_ids" "uuid"[]) TO "authenticated";
GRANT ALL ON FUNCTION "public"."list_approval_steps"("p_request_ids" "uuid"[]) TO "service_role";



REVOKE ALL ON FUNCTION "public"."list_chart_of_accounts"("p_include_inactive" boolean) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."list_chart_of_accounts"("p_include_inactive" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."list_chart_of_accounts"("p_include_inactive" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."list_chart_of_accounts"("p_include_inactive" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."log_admin_changes"() TO "anon";
GRANT ALL ON FUNCTION "public"."log_admin_changes"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."log_admin_changes"() TO "service_role";



GRANT ALL ON FUNCTION "public"."log_coa_changes"() TO "anon";
GRANT ALL ON FUNCTION "public"."log_coa_changes"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."log_coa_changes"() TO "service_role";



GRANT ALL ON FUNCTION "public"."log_currencies_changes"() TO "anon";
GRANT ALL ON FUNCTION "public"."log_currencies_changes"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."log_currencies_changes"() TO "service_role";



GRANT ALL ON FUNCTION "public"."log_customer_changes"() TO "anon";
GRANT ALL ON FUNCTION "public"."log_customer_changes"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."log_customer_changes"() TO "service_role";



GRANT ALL ON FUNCTION "public"."log_fx_rates_changes"() TO "anon";
GRANT ALL ON FUNCTION "public"."log_fx_rates_changes"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."log_fx_rates_changes"() TO "service_role";



GRANT ALL ON FUNCTION "public"."log_menu_item_changes"() TO "anon";
GRANT ALL ON FUNCTION "public"."log_menu_item_changes"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."log_menu_item_changes"() TO "service_role";



GRANT ALL ON FUNCTION "public"."log_settings_changes"() TO "anon";
GRANT ALL ON FUNCTION "public"."log_settings_changes"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."log_settings_changes"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."manage_menu_item_stock"("p_item_id" "uuid", "p_quantity" numeric, "p_unit" "text", "p_reason" "text", "p_user_id" "uuid", "p_low_stock_threshold" numeric, "p_is_wastage" boolean, "p_batch_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."manage_menu_item_stock"("p_item_id" "uuid", "p_quantity" numeric, "p_unit" "text", "p_reason" "text", "p_user_id" "uuid", "p_low_stock_threshold" numeric, "p_is_wastage" boolean, "p_batch_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."manage_menu_item_stock"("p_item_id" "uuid", "p_quantity" numeric, "p_unit" "text", "p_reason" "text", "p_user_id" "uuid", "p_low_stock_threshold" numeric, "p_is_wastage" boolean, "p_batch_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."manage_menu_item_stock"("p_item_id" "uuid", "p_quantity" numeric, "p_unit" "text", "p_reason" "text", "p_user_id" "uuid", "p_low_stock_threshold" numeric, "p_is_wastage" boolean, "p_batch_id" "uuid") TO "anon";



GRANT ALL ON FUNCTION "public"."notify_delivery_assignment_change"() TO "anon";
GRANT ALL ON FUNCTION "public"."notify_delivery_assignment_change"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."notify_delivery_assignment_change"() TO "service_role";



GRANT ALL ON FUNCTION "public"."notify_order_created"() TO "anon";
GRANT ALL ON FUNCTION "public"."notify_order_created"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."notify_order_created"() TO "service_role";



GRANT ALL ON FUNCTION "public"."notify_order_status_change"() TO "anon";
GRANT ALL ON FUNCTION "public"."notify_order_status_change"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."notify_order_status_change"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."open_cash_shift_for_cashier"("p_cashier_id" "uuid", "p_start_amount" numeric) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."open_cash_shift_for_cashier"("p_cashier_id" "uuid", "p_start_amount" numeric) TO "anon";
GRANT ALL ON FUNCTION "public"."open_cash_shift_for_cashier"("p_cashier_id" "uuid", "p_start_amount" numeric) TO "authenticated";
GRANT ALL ON FUNCTION "public"."open_cash_shift_for_cashier"("p_cashier_id" "uuid", "p_start_amount" numeric) TO "service_role";



REVOKE ALL ON FUNCTION "public"."order_delivered_at"("p_order_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."order_delivered_at"("p_order_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."order_delivered_at"("p_order_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."order_delivered_at"("p_order_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."orders_validate_delivery_zone_radius"() TO "anon";
GRANT ALL ON FUNCTION "public"."orders_validate_delivery_zone_radius"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."orders_validate_delivery_zone_radius"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."owner_finalize_approval_request"("p_request_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."owner_finalize_approval_request"("p_request_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."owner_finalize_approval_request"("p_request_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."owner_finalize_approval_request"("p_request_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."pgrst_ddl_watch"() TO "anon";
GRANT ALL ON FUNCTION "public"."pgrst_ddl_watch"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."pgrst_ddl_watch"() TO "service_role";



GRANT ALL ON FUNCTION "public"."pgrst_drop_watch"() TO "anon";
GRANT ALL ON FUNCTION "public"."pgrst_drop_watch"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."pgrst_drop_watch"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."post_cash_shift_close"("p_shift_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."post_cash_shift_close"("p_shift_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."post_cash_shift_close"("p_shift_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."post_cash_shift_close"("p_shift_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."post_import_expense"("p_import_expense_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."post_import_expense"("p_import_expense_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."post_inventory_movement"("p_movement_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."post_inventory_movement"("p_movement_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."post_inventory_movement"("p_movement_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."post_invoice_issued"("p_order_id" "uuid", "p_issued_at" timestamp with time zone) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."post_invoice_issued"("p_order_id" "uuid", "p_issued_at" timestamp with time zone) TO "anon";
GRANT ALL ON FUNCTION "public"."post_invoice_issued"("p_order_id" "uuid", "p_issued_at" timestamp with time zone) TO "authenticated";
GRANT ALL ON FUNCTION "public"."post_invoice_issued"("p_order_id" "uuid", "p_issued_at" timestamp with time zone) TO "service_role";



REVOKE ALL ON FUNCTION "public"."post_order_delivery"("p_order_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."post_order_delivery"("p_order_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."post_payment"("p_payment_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."post_payment"("p_payment_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."post_payment"("p_payment_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."post_payment"("p_payment_id" "uuid") TO "authenticated";



REVOKE ALL ON FUNCTION "public"."post_production_order"("p_order_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."post_production_order"("p_order_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."post_production_order"("p_order_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."post_production_order"("p_order_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."post_supplier_invoice_variance"("p_invoice_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."post_supplier_invoice_variance"("p_invoice_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."post_supplier_invoice_variance"("p_invoice_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."prevent_audit_log_modification"() TO "anon";
GRANT ALL ON FUNCTION "public"."prevent_audit_log_modification"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."prevent_audit_log_modification"() TO "service_role";



GRANT ALL ON FUNCTION "public"."prevent_multiple_owners"() TO "anon";
GRANT ALL ON FUNCTION "public"."prevent_multiple_owners"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."prevent_multiple_owners"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."process_expired_items"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."process_expired_items"() TO "anon";
GRANT ALL ON FUNCTION "public"."process_expired_items"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."process_expired_items"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."process_expiry_light"("p_warehouse_id" "uuid", "p_now" timestamp with time zone) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."process_expiry_light"("p_warehouse_id" "uuid", "p_now" timestamp with time zone) TO "anon";
GRANT ALL ON FUNCTION "public"."process_expiry_light"("p_warehouse_id" "uuid", "p_now" timestamp with time zone) TO "authenticated";
GRANT ALL ON FUNCTION "public"."process_expiry_light"("p_warehouse_id" "uuid", "p_now" timestamp with time zone) TO "service_role";



REVOKE ALL ON FUNCTION "public"."process_sales_return"("p_return_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."process_sales_return"("p_return_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."process_sales_return"("p_return_id" "uuid") TO "service_role";
GRANT ALL ON FUNCTION "public"."process_sales_return"("p_return_id" "uuid") TO "anon";



REVOKE ALL ON FUNCTION "public"."profit_and_loss_by_period"("p_period_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."profit_and_loss_by_period"("p_period_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."profit_and_loss_by_period"("p_period_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."profit_and_loss_by_period"("p_period_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."profit_and_loss_by_range"("p_start" "date", "p_end" "date") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."profit_and_loss_by_range"("p_start" "date", "p_end" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."profit_and_loss_by_range"("p_start" "date", "p_end" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."profit_and_loss_by_range"("p_start" "date", "p_end" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."purchase_items_after_change"() TO "anon";
GRANT ALL ON FUNCTION "public"."purchase_items_after_change"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."purchase_items_after_change"() TO "service_role";



GRANT ALL ON FUNCTION "public"."purchase_items_set_total_cost"() TO "anon";
GRANT ALL ON FUNCTION "public"."purchase_items_set_total_cost"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."purchase_items_set_total_cost"() TO "service_role";



GRANT ALL ON FUNCTION "public"."purchase_orders_recalc_after_insert"() TO "anon";
GRANT ALL ON FUNCTION "public"."purchase_orders_recalc_after_insert"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."purchase_orders_recalc_after_insert"() TO "service_role";



GRANT ALL ON FUNCTION "public"."purchase_receipt_items_set_total_cost"() TO "anon";
GRANT ALL ON FUNCTION "public"."purchase_receipt_items_set_total_cost"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."purchase_receipt_items_set_total_cost"() TO "service_role";



GRANT ALL ON FUNCTION "public"."purchase_return_items_after_change"() TO "anon";
GRANT ALL ON FUNCTION "public"."purchase_return_items_after_change"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."purchase_return_items_after_change"() TO "service_role";



GRANT ALL ON FUNCTION "public"."purchase_return_items_set_total_cost"() TO "anon";
GRANT ALL ON FUNCTION "public"."purchase_return_items_set_total_cost"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."purchase_return_items_set_total_cost"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."purge_purchase_order"("p_order_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."purge_purchase_order"("p_order_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."purge_purchase_order"("p_order_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."purge_purchase_order"("p_order_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."qc_inspect_batch"("p_batch_id" "uuid", "p_result" "text", "p_notes" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."qc_inspect_batch"("p_batch_id" "uuid", "p_result" "text", "p_notes" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."qc_inspect_batch"("p_batch_id" "uuid", "p_result" "text", "p_notes" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."qc_release_batch"("p_batch_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."qc_release_batch"("p_batch_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."qc_release_batch"("p_batch_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."rebuild_order_line_items"("p_order_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."rebuild_order_line_items"("p_order_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."rebuild_order_line_items"("p_order_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."recalc_purchase_order_totals"("p_order_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."recalc_purchase_order_totals"("p_order_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."recalc_purchase_order_totals"("p_order_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."receive_inventory_transfer"("p_transfer_id" "uuid", "p_idempotency_key" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."receive_inventory_transfer"("p_transfer_id" "uuid", "p_idempotency_key" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."receive_inventory_transfer"("p_transfer_id" "uuid", "p_idempotency_key" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."receive_inventory_transfer"("p_transfer_id" "uuid", "p_idempotency_key" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."receive_purchase_order"("p_order_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."receive_purchase_order"("p_order_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."receive_purchase_order"("p_order_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."receive_purchase_order_partial"("p_order_id" "uuid", "p_items" "jsonb", "p_occurred_at" timestamp with time zone) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."receive_purchase_order_partial"("p_order_id" "uuid", "p_items" "jsonb", "p_occurred_at" timestamp with time zone) TO "authenticated";
GRANT ALL ON FUNCTION "public"."receive_purchase_order_partial"("p_order_id" "uuid", "p_items" "jsonb", "p_occurred_at" timestamp with time zone) TO "service_role";



REVOKE ALL ON FUNCTION "public"."recompute_stock_for_item"("p_item_id" "text", "p_warehouse_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."recompute_stock_for_item"("p_item_id" "text", "p_warehouse_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."recompute_stock_for_item"("p_item_id" "text", "p_warehouse_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."record_expense_accrual"("p_expense_id" "uuid", "p_amount" numeric, "p_occurred_at" timestamp with time zone) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."record_expense_accrual"("p_expense_id" "uuid", "p_amount" numeric, "p_occurred_at" timestamp with time zone) TO "anon";
GRANT ALL ON FUNCTION "public"."record_expense_accrual"("p_expense_id" "uuid", "p_amount" numeric, "p_occurred_at" timestamp with time zone) TO "authenticated";
GRANT ALL ON FUNCTION "public"."record_expense_accrual"("p_expense_id" "uuid", "p_amount" numeric, "p_occurred_at" timestamp with time zone) TO "service_role";



REVOKE ALL ON FUNCTION "public"."record_expense_payment"("p_expense_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."record_expense_payment"("p_expense_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone) TO "anon";
GRANT ALL ON FUNCTION "public"."record_expense_payment"("p_expense_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone) TO "authenticated";
GRANT ALL ON FUNCTION "public"."record_expense_payment"("p_expense_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone) TO "service_role";



REVOKE ALL ON FUNCTION "public"."record_import_expense_payment"("p_import_expense_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."record_import_expense_payment"("p_import_expense_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone) TO "anon";
GRANT ALL ON FUNCTION "public"."record_import_expense_payment"("p_import_expense_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone) TO "authenticated";
GRANT ALL ON FUNCTION "public"."record_import_expense_payment"("p_import_expense_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone) TO "service_role";



REVOKE ALL ON FUNCTION "public"."record_order_payment"("p_order_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone, "p_idempotency_key" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."record_order_payment"("p_order_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone, "p_idempotency_key" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."record_order_payment"("p_order_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone, "p_idempotency_key" "text") TO "service_role";
GRANT ALL ON FUNCTION "public"."record_order_payment"("p_order_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone, "p_idempotency_key" "text") TO "anon";



REVOKE ALL ON FUNCTION "public"."record_order_payment"("p_order_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone, "p_idempotency_key" "text", "p_currency" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."record_order_payment"("p_order_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone, "p_idempotency_key" "text", "p_currency" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."record_order_payment"("p_order_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone, "p_idempotency_key" "text", "p_currency" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."record_order_payment"("p_order_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone, "p_idempotency_key" "text", "p_currency" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."record_purchase_order_payment"("p_purchase_order_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone, "p_data" "jsonb") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."record_purchase_order_payment"("p_purchase_order_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone, "p_data" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."record_purchase_order_payment"("p_purchase_order_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone, "p_data" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."record_purchase_order_payment"("p_purchase_order_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone, "p_data" "jsonb") TO "service_role";



REVOKE ALL ON FUNCTION "public"."record_purchase_order_payment"("p_purchase_order_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone, "p_data" "jsonb", "p_currency" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."record_purchase_order_payment"("p_purchase_order_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone, "p_data" "jsonb", "p_currency" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."record_purchase_order_payment"("p_purchase_order_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone, "p_data" "jsonb", "p_currency" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."record_purchase_order_payment"("p_purchase_order_id" "uuid", "p_amount" numeric, "p_method" "text", "p_occurred_at" timestamp with time zone, "p_data" "jsonb", "p_currency" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."record_shift_cash_movement"("p_shift_id" "uuid", "p_direction" "text", "p_amount" numeric, "p_reason" "text", "p_occurred_at" timestamp with time zone) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."record_shift_cash_movement"("p_shift_id" "uuid", "p_direction" "text", "p_amount" numeric, "p_reason" "text", "p_occurred_at" timestamp with time zone) TO "anon";
GRANT ALL ON FUNCTION "public"."record_shift_cash_movement"("p_shift_id" "uuid", "p_direction" "text", "p_amount" numeric, "p_reason" "text", "p_occurred_at" timestamp with time zone) TO "authenticated";
GRANT ALL ON FUNCTION "public"."record_shift_cash_movement"("p_shift_id" "uuid", "p_direction" "text", "p_amount" numeric, "p_reason" "text", "p_occurred_at" timestamp with time zone) TO "service_role";



REVOKE ALL ON FUNCTION "public"."record_wastage_light"("p_item_id" "uuid", "p_warehouse_id" "uuid", "p_quantity" numeric, "p_batch_id" "uuid", "p_unit" "text", "p_reason" "text", "p_occurred_at" timestamp with time zone) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."record_wastage_light"("p_item_id" "uuid", "p_warehouse_id" "uuid", "p_quantity" numeric, "p_batch_id" "uuid", "p_unit" "text", "p_reason" "text", "p_occurred_at" timestamp with time zone) TO "anon";
GRANT ALL ON FUNCTION "public"."record_wastage_light"("p_item_id" "uuid", "p_warehouse_id" "uuid", "p_quantity" numeric, "p_batch_id" "uuid", "p_unit" "text", "p_reason" "text", "p_occurred_at" timestamp with time zone) TO "authenticated";
GRANT ALL ON FUNCTION "public"."record_wastage_light"("p_item_id" "uuid", "p_warehouse_id" "uuid", "p_quantity" numeric, "p_batch_id" "uuid", "p_unit" "text", "p_reason" "text", "p_occurred_at" timestamp with time zone) TO "service_role";



REVOKE ALL ON FUNCTION "public"."register_pos_offline_sale_created"("p_offline_id" "text", "p_order_id" "uuid", "p_created_at" timestamp with time zone, "p_warehouse_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."register_pos_offline_sale_created"("p_offline_id" "text", "p_order_id" "uuid", "p_created_at" timestamp with time zone, "p_warehouse_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."register_pos_offline_sale_created"("p_offline_id" "text", "p_order_id" "uuid", "p_created_at" timestamp with time zone, "p_warehouse_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."register_pos_offline_sale_created"("p_offline_id" "text", "p_order_id" "uuid", "p_created_at" timestamp with time zone, "p_warehouse_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."reject_approval_request"("p_request_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."reject_approval_request"("p_request_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."release_reserved_stock_for_order"("p_items" "jsonb", "p_order_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."release_reserved_stock_for_order"("p_items" "jsonb", "p_order_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."release_reserved_stock_for_order"("p_items" "jsonb", "p_order_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."release_reserved_stock_for_order"("p_items" "jsonb", "p_order_id" "uuid", "p_warehouse_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."release_reserved_stock_for_order"("p_items" "jsonb", "p_order_id" "uuid", "p_warehouse_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."release_reserved_stock_for_order"("p_items" "jsonb", "p_order_id" "uuid", "p_warehouse_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."request_offline_reconciliation"("p_offline_id" "text", "p_reason" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."request_offline_reconciliation"("p_offline_id" "text", "p_reason" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."request_offline_reconciliation"("p_offline_id" "text", "p_reason" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."request_offline_reconciliation"("p_offline_id" "text", "p_reason" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."reserve_stock_for_order"("p_payload" "jsonb") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."reserve_stock_for_order"("p_payload" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."reserve_stock_for_order"("p_payload" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."reserve_stock_for_order"("p_items" "jsonb", "p_order_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."reserve_stock_for_order"("p_items" "jsonb", "p_order_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."reserve_stock_for_order"("p_items" "jsonb", "p_order_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."reserve_stock_for_order"("p_items" "jsonb", "p_order_id" "uuid", "p_warehouse_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."reserve_stock_for_order"("p_items" "jsonb", "p_order_id" "uuid", "p_warehouse_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."reserve_stock_for_order"("p_items" "jsonb", "p_order_id" "uuid", "p_warehouse_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."reserve_stock_for_order"("p_items" "jsonb", "p_order_id" "uuid", "p_warehouse_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."retry_offline_pos_sale"("p_offline_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."retry_offline_pos_sale"("p_offline_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."retry_offline_pos_sale"("p_offline_id" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."reverse_journal_entry"("p_journal_entry_id" "uuid", "p_reason" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."reverse_journal_entry"("p_journal_entry_id" "uuid", "p_reason" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."reverse_journal_entry"("p_journal_entry_id" "uuid", "p_reason" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."reverse_payment_journal"("p_payment_id" "uuid", "p_reason" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."reverse_payment_journal"("p_payment_id" "uuid", "p_reason" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."reverse_payment_journal"("p_payment_id" "uuid", "p_reason" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."reverse_payment_journal"("p_payment_id" "uuid", "p_reason" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."rpc_echo_text"("p_text" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."rpc_echo_text"("p_text" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."rpc_echo_text"("p_text" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."rpc_echo_text"("p_text" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."rpc_has_function"("p_name" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."rpc_has_function"("p_name" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."rpc_has_function"("p_name" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."rpc_has_function"("p_name" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."rpc_list_public_functions"("p_like" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."rpc_list_public_functions"("p_like" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."rpc_list_public_functions"("p_like" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."rpc_list_public_functions"("p_like" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."rpc_reload_postgrest_schema"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."rpc_reload_postgrest_schema"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."rpc_reload_postgrest_schema"() TO "service_role";



GRANT ALL ON FUNCTION "public"."run_expiry_job"() TO "anon";
GRANT ALL ON FUNCTION "public"."run_expiry_job"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."run_expiry_job"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."run_fx_revaluation"("p_period_end" "date") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."run_fx_revaluation"("p_period_end" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."run_fx_revaluation"("p_period_end" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."run_fx_revaluation"("p_period_end" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."set_audit_reason"("p_reason" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."set_audit_reason"("p_reason" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_audit_reason"("p_reason" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."set_base_currency"("p_code" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."set_base_currency"("p_code" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."set_base_currency"("p_code" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_base_currency"("p_code" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."set_chart_account_active"("p_account_id" "uuid", "p_is_active" boolean) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."set_chart_account_active"("p_account_id" "uuid", "p_is_active" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."set_chart_account_active"("p_account_id" "uuid", "p_is_active" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_chart_account_active"("p_account_id" "uuid", "p_is_active" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."set_transfer_number"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_transfer_number"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_transfer_number"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_updated_at"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."sync_ar_on_invoice"("p_order_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."sync_ar_on_invoice"("p_order_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."sync_ar_on_invoice"("p_order_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."sync_expense_cost_center"() TO "anon";
GRANT ALL ON FUNCTION "public"."sync_expense_cost_center"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."sync_expense_cost_center"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."sync_offline_pos_sale"("p_offline_id" "text", "p_order_id" "uuid", "p_order_data" "jsonb", "p_items" "jsonb", "p_warehouse_id" "uuid", "p_payments" "jsonb") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."sync_offline_pos_sale"("p_offline_id" "text", "p_order_id" "uuid", "p_order_data" "jsonb", "p_items" "jsonb", "p_warehouse_id" "uuid", "p_payments" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."sync_offline_pos_sale"("p_offline_id" "text", "p_order_id" "uuid", "p_order_data" "jsonb", "p_items" "jsonb", "p_warehouse_id" "uuid", "p_payments" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."sync_offline_pos_sale"("p_offline_id" "text", "p_order_id" "uuid", "p_order_data" "jsonb", "p_items" "jsonb", "p_warehouse_id" "uuid", "p_payments" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."sync_purchase_order_paid_amount_from_payments"("p_order_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."sync_purchase_order_paid_amount_from_payments"("p_order_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."sync_purchase_order_paid_amount_from_payments"("p_order_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."transfer_total_cost"("p_transfer_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."transfer_total_cost"("p_transfer_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."transfer_total_cost"("p_transfer_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_accounting_period_generate_snapshot_on_close"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_accounting_period_generate_snapshot_on_close"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_accounting_period_generate_snapshot_on_close"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_accounting_period_snapshots_immutable"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_accounting_period_snapshots_immutable"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_accounting_period_snapshots_immutable"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_after_journal_entry_insert_flag_payment"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_after_journal_entry_insert_flag_payment"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_after_journal_entry_insert_flag_payment"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."trg_apply_import_shipment_landed_cost_on_delivered"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."trg_apply_import_shipment_landed_cost_on_delivered"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_apply_import_shipment_landed_cost_on_delivered"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_apply_import_shipment_landed_cost_on_delivered"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_audit_journal_entries_insert"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_audit_journal_entries_insert"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_audit_journal_entries_insert"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_audit_journal_lines_insert"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_audit_journal_lines_insert"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_audit_journal_lines_insert"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_batch_balances_expiry_immutable"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_batch_balances_expiry_immutable"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_batch_balances_expiry_immutable"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_batches_pricing_defaults"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_batches_pricing_defaults"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_batches_pricing_defaults"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_block_journal_entries_in_closed_period"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_block_journal_entries_in_closed_period"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_block_journal_entries_in_closed_period"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_block_journal_in_closed_period"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_block_journal_in_closed_period"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_block_journal_in_closed_period"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_block_journal_lines_in_closed_period"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_block_journal_lines_in_closed_period"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_block_journal_lines_in_closed_period"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_block_manual_entry_changes"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_block_manual_entry_changes"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_block_manual_entry_changes"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_block_manual_line_changes"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_block_manual_line_changes"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_block_manual_line_changes"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_block_sale_below_cost"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_block_sale_below_cost"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_block_sale_below_cost"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_block_sale_on_qc"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_block_sale_on_qc"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_block_sale_on_qc"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_block_system_journal_entry_mutation"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_block_system_journal_entry_mutation"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_block_system_journal_entry_mutation"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_block_system_journal_lines_mutation"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_block_system_journal_lines_mutation"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_block_system_journal_lines_mutation"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_check_journal_balance"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_check_journal_balance"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_check_journal_balance"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_check_journal_entry_balance_on_entry"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_check_journal_entry_balance_on_entry"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_check_journal_entry_balance_on_entry"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_check_order_closed_period"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_check_order_closed_period"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_check_order_closed_period"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_check_po_closed_period"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_check_po_closed_period"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_check_po_closed_period"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_check_shift_closed_period"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_check_shift_closed_period"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_check_shift_closed_period"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_check_simple_date_closed_period"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_check_simple_date_closed_period"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_check_simple_date_closed_period"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."trg_close_import_shipment"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."trg_close_import_shipment"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_coa_require_ifrs_mapping"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_coa_require_ifrs_mapping"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_coa_require_ifrs_mapping"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_consume_order_item_reservation_on_sale_out"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_consume_order_item_reservation_on_sale_out"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_consume_order_item_reservation_on_sale_out"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_delivered_order_requires_journal_entry"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_delivered_order_requires_journal_entry"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_delivered_order_requires_journal_entry"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_enforce_approval_branch"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_enforce_approval_branch"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_enforce_approval_branch"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_enforce_base_currency_singleton"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_enforce_base_currency_singleton"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_enforce_base_currency_singleton"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_enforce_discount_approval"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_enforce_discount_approval"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_enforce_discount_approval"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_enforce_po_approval"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_enforce_po_approval"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_enforce_po_approval"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_enforce_receipt_approval"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_enforce_receipt_approval"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_enforce_receipt_approval"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_enforce_transfer_approval"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_enforce_transfer_approval"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_enforce_transfer_approval"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_enforce_writeoff_approval"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_enforce_writeoff_approval"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_enforce_writeoff_approval"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_forbid_delete_batch"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_forbid_delete_batch"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_forbid_delete_batch"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_forbid_disable_batch"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_forbid_disable_batch"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_forbid_disable_batch"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_forbid_update_delete"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_forbid_update_delete"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_forbid_update_delete"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_freeze_ledger_tables"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_freeze_ledger_tables"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_freeze_ledger_tables"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_freeze_posting_engine"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_freeze_posting_engine"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_freeze_posting_engine"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_immutable_block"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_immutable_block"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_immutable_block"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_inventory_movement_requires_journal_entry"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_inventory_movement_requires_journal_entry"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_inventory_movement_requires_journal_entry"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."trg_inventory_movements_ensure_batch_exists"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."trg_inventory_movements_ensure_batch_exists"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_inventory_movements_ensure_batch_exists"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_inventory_movements_ensure_batch_exists"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."trg_inventory_movements_purchase_in_defaults"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."trg_inventory_movements_purchase_in_defaults"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_inventory_movements_purchase_in_defaults"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_inventory_movements_purchase_in_defaults"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_inventory_movements_purchase_in_immutable"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_inventory_movements_purchase_in_immutable"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_inventory_movements_purchase_in_immutable"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_inventory_movements_purchase_in_no_delete"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_inventory_movements_purchase_in_no_delete"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_inventory_movements_purchase_in_no_delete"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."trg_inventory_movements_purchase_in_sync_batch_balances"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."trg_inventory_movements_purchase_in_sync_batch_balances"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_inventory_movements_purchase_in_sync_batch_balances"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_inventory_movements_purchase_in_sync_batch_balances"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_journal_entries_hard_rules"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_journal_entries_hard_rules"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_journal_entries_hard_rules"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_journal_entries_immutable"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_journal_entries_immutable"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_journal_entries_immutable"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_journal_entries_set_document"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_journal_entries_set_document"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_journal_entries_set_document"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_journal_lines_immutable"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_journal_lines_immutable"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_journal_lines_immutable"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_journal_lines_sync_ar_open_item"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_journal_lines_sync_ar_open_item"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_journal_lines_sync_ar_open_item"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_ledger_audit_log_immutable"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_ledger_audit_log_immutable"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_ledger_audit_log_immutable"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_lock_approval_requests"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_lock_approval_requests"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_lock_approval_requests"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_lock_approval_steps"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_lock_approval_steps"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_lock_approval_steps"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_menu_items_lock_after_first_movement"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_menu_items_lock_after_first_movement"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_menu_items_lock_after_first_movement"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_menu_items_sot_sync_validate"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_menu_items_sot_sync_validate"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_menu_items_sot_sync_validate"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_orders_promotion_guards"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_orders_promotion_guards"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_orders_promotion_guards"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_orders_require_sale_out_on_delivered"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_orders_require_sale_out_on_delivered"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_orders_require_sale_out_on_delivered"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_payment_requires_journal_entry"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_payment_requires_journal_entry"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_payment_requires_journal_entry"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."trg_post_import_expense"() FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."trg_post_import_expense"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_post_inventory_movement"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_post_inventory_movement"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_post_inventory_movement"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_post_order_delivery"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_post_order_delivery"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_post_order_delivery"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_post_payment"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_post_payment"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_post_payment"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_product_audit_log"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_product_audit_log"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_product_audit_log"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_promotion_items_lock_after_usage"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_promotion_items_lock_after_usage"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_promotion_items_lock_after_usage"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_promotion_usage_enforce_valid"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_promotion_usage_enforce_valid"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_promotion_usage_enforce_valid"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_promotions_enforce_active_window_and_approval"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_promotions_enforce_active_window_and_approval"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_promotions_enforce_active_window_and_approval"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_promotions_lock_after_usage"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_promotions_lock_after_usage"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_promotions_lock_after_usage"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_purchase_items_set_costs"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_purchase_items_set_costs"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_purchase_items_set_costs"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_purchase_orders_fx_lock"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_purchase_orders_fx_lock"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_purchase_orders_fx_lock"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_recall_batch_update"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_recall_batch_update"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_recall_batch_update"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_sale_out_require_batch"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_sale_out_require_batch"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_sale_out_require_batch"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_set_approval_request_scope"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_set_approval_request_scope"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_set_approval_request_scope"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_set_journal_entry_status"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_set_journal_entry_status"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_set_journal_entry_status"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_set_movement_branch_scope"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_set_movement_branch_scope"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_set_movement_branch_scope"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_set_order_branch_scope"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_set_order_branch_scope"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_set_order_branch_scope"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_set_order_fx"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_set_order_fx"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_set_order_fx"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_set_payment_branch_scope"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_set_payment_branch_scope"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_set_payment_branch_scope"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_set_payment_fx"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_set_payment_fx"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_set_payment_fx"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_set_po_branch_scope"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_set_po_branch_scope"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_set_po_branch_scope"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_set_qty_base_inventory_movements"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_set_qty_base_inventory_movements"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_set_qty_base_inventory_movements"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_set_qty_base_purchase_items"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_set_qty_base_purchase_items"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_set_qty_base_purchase_items"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_set_qty_base_receipt_items"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_set_qty_base_receipt_items"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_set_qty_base_receipt_items"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_set_qty_base_transfer_items"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_set_qty_base_transfer_items"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_set_qty_base_transfer_items"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_set_receipt_branch_scope"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_set_receipt_branch_scope"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_set_receipt_branch_scope"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_set_supplier_invoice_branch_scope"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_set_supplier_invoice_branch_scope"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_set_supplier_invoice_branch_scope"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_set_transfer_branch_scope"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_set_transfer_branch_scope"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_set_transfer_branch_scope"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_sync_batch_balances_from_batches"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_sync_batch_balances_from_batches"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_sync_batch_balances_from_batches"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_sync_discount_approval_to_order"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_sync_discount_approval_to_order"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_sync_discount_approval_to_order"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_sync_discount_approval_to_promotion"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_sync_discount_approval_to_promotion"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_sync_discount_approval_to_promotion"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_sync_offline_reconciliation_approval"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_sync_offline_reconciliation_approval"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_sync_offline_reconciliation_approval"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_sync_order_line_items"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_sync_order_line_items"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_sync_order_line_items"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_sync_po_approval_to_purchase_order"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_sync_po_approval_to_purchase_order"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_sync_po_approval_to_purchase_order"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_sync_purchase_order_paid_amount"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_sync_purchase_order_paid_amount"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_sync_purchase_order_paid_amount"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_trace_batch_sales"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_trace_batch_sales"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_trace_batch_sales"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_validate_base_currency_config"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_validate_base_currency_config"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_validate_base_currency_config"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_validate_reserved_batches"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_validate_reserved_batches"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_validate_reserved_batches"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."trial_balance"("p_start" "date", "p_end" "date", "p_cost_center_id" "uuid") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."trial_balance"("p_start" "date", "p_end" "date", "p_cost_center_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."trial_balance"("p_start" "date", "p_end" "date", "p_cost_center_id" "uuid") TO "service_role";



REVOKE ALL ON FUNCTION "public"."trial_balance_by_range"("p_start" "date", "p_end" "date") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."trial_balance_by_range"("p_start" "date", "p_end" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."trial_balance_by_range"("p_start" "date", "p_end" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."trial_balance_by_range"("p_start" "date", "p_end" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."trigger_encrypt_customer_data"() TO "anon";
GRANT ALL ON FUNCTION "public"."trigger_encrypt_customer_data"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trigger_encrypt_customer_data"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."update_chart_account"("p_account_id" "uuid", "p_code" "text", "p_name" "text", "p_account_type" "text", "p_normal_balance" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."update_chart_account"("p_account_id" "uuid", "p_code" "text", "p_name" "text", "p_account_type" "text", "p_normal_balance" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."update_chart_account"("p_account_id" "uuid", "p_code" "text", "p_name" "text", "p_account_type" "text", "p_normal_balance" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_chart_account"("p_account_id" "uuid", "p_code" "text", "p_name" "text", "p_account_type" "text", "p_normal_balance" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "service_role";



REVOKE ALL ON FUNCTION "public"."upsert_promotion"("p_promotion" "jsonb", "p_items" "jsonb", "p_activate" boolean) FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."upsert_promotion"("p_promotion" "jsonb", "p_items" "jsonb", "p_activate" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."upsert_promotion"("p_promotion" "jsonb", "p_items" "jsonb", "p_activate" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."upsert_promotion"("p_promotion" "jsonb", "p_items" "jsonb", "p_activate" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."uuid_from_text"("p_text" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."uuid_from_text"("p_text" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."uuid_from_text"("p_text" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."void_delivered_order"("p_order_id" "uuid", "p_reason" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."void_delivered_order"("p_order_id" "uuid", "p_reason" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."void_delivered_order"("p_order_id" "uuid", "p_reason" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."void_delivered_order"("p_order_id" "uuid", "p_reason" "text") TO "service_role";



REVOKE ALL ON FUNCTION "public"."void_journal_entry"("p_entry_id" "uuid", "p_reason" "text") FROM PUBLIC;
GRANT ALL ON FUNCTION "public"."void_journal_entry"("p_entry_id" "uuid", "p_reason" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."void_journal_entry"("p_entry_id" "uuid", "p_reason" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."void_journal_entry"("p_entry_id" "uuid", "p_reason" "text") TO "service_role";



GRANT ALL ON TABLE "public"."accounting_documents" TO "anon";
GRANT ALL ON TABLE "public"."accounting_documents" TO "authenticated";
GRANT ALL ON TABLE "public"."accounting_documents" TO "service_role";



GRANT ALL ON TABLE "public"."accounting_light_entries" TO "anon";
GRANT ALL ON TABLE "public"."accounting_light_entries" TO "authenticated";
GRANT ALL ON TABLE "public"."accounting_light_entries" TO "service_role";



GRANT ALL ON TABLE "public"."accounting_period_snapshots" TO "service_role";
GRANT SELECT,INSERT ON TABLE "public"."accounting_period_snapshots" TO "authenticated";



GRANT ALL ON TABLE "public"."accounting_periods" TO "anon";
GRANT ALL ON TABLE "public"."accounting_periods" TO "authenticated";
GRANT ALL ON TABLE "public"."accounting_periods" TO "service_role";



GRANT ALL ON TABLE "public"."addons" TO "anon";
GRANT ALL ON TABLE "public"."addons" TO "authenticated";
GRANT ALL ON TABLE "public"."addons" TO "service_role";



GRANT ALL ON TABLE "public"."admin_users" TO "anon";
GRANT ALL ON TABLE "public"."admin_users" TO "authenticated";
GRANT ALL ON TABLE "public"."admin_users" TO "service_role";



GRANT ALL ON TABLE "public"."ads" TO "anon";
GRANT ALL ON TABLE "public"."ads" TO "authenticated";
GRANT ALL ON TABLE "public"."ads" TO "service_role";



GRANT ALL ON TABLE "public"."app_settings" TO "anon";
GRANT ALL ON TABLE "public"."app_settings" TO "authenticated";
GRANT ALL ON TABLE "public"."app_settings" TO "service_role";



GRANT ALL ON TABLE "public"."approval_policies" TO "anon";
GRANT ALL ON TABLE "public"."approval_policies" TO "authenticated";
GRANT ALL ON TABLE "public"."approval_policies" TO "service_role";



GRANT ALL ON TABLE "public"."approval_policy_steps" TO "anon";
GRANT ALL ON TABLE "public"."approval_policy_steps" TO "authenticated";
GRANT ALL ON TABLE "public"."approval_policy_steps" TO "service_role";



GRANT ALL ON TABLE "public"."approval_requests" TO "anon";
GRANT ALL ON TABLE "public"."approval_requests" TO "authenticated";
GRANT ALL ON TABLE "public"."approval_requests" TO "service_role";



GRANT ALL ON TABLE "public"."approval_steps" TO "anon";
GRANT ALL ON TABLE "public"."approval_steps" TO "authenticated";
GRANT ALL ON TABLE "public"."approval_steps" TO "service_role";



GRANT ALL ON TABLE "public"."ar_allocations" TO "anon";
GRANT ALL ON TABLE "public"."ar_allocations" TO "authenticated";
GRANT ALL ON TABLE "public"."ar_allocations" TO "service_role";



GRANT ALL ON TABLE "public"."ar_open_items" TO "anon";
GRANT ALL ON TABLE "public"."ar_open_items" TO "authenticated";
GRANT ALL ON TABLE "public"."ar_open_items" TO "service_role";



GRANT ALL ON TABLE "public"."ar_payment_status" TO "anon";
GRANT ALL ON TABLE "public"."ar_payment_status" TO "authenticated";
GRANT ALL ON TABLE "public"."ar_payment_status" TO "service_role";



GRANT ALL ON TABLE "public"."chart_of_accounts" TO "anon";
GRANT ALL ON TABLE "public"."chart_of_accounts" TO "authenticated";
GRANT ALL ON TABLE "public"."chart_of_accounts" TO "service_role";



GRANT SELECT,INSERT,REFERENCES,TRIGGER,TRUNCATE,MAINTAIN ON TABLE "public"."journal_entries" TO "anon";
GRANT SELECT,INSERT,REFERENCES,TRIGGER,TRUNCATE,MAINTAIN ON TABLE "public"."journal_entries" TO "authenticated";
GRANT ALL ON TABLE "public"."journal_entries" TO "service_role";



GRANT SELECT,INSERT,REFERENCES,TRIGGER,TRUNCATE,MAINTAIN ON TABLE "public"."journal_lines" TO "anon";
GRANT SELECT,INSERT,REFERENCES,TRIGGER,TRUNCATE,MAINTAIN ON TABLE "public"."journal_lines" TO "authenticated";
GRANT ALL ON TABLE "public"."journal_lines" TO "service_role";



GRANT ALL ON TABLE "public"."audit_general_ledger" TO "anon";
GRANT ALL ON TABLE "public"."audit_general_ledger" TO "authenticated";
GRANT ALL ON TABLE "public"."audit_general_ledger" TO "service_role";



GRANT ALL ON TABLE "public"."audit_journal_entries_with_source" TO "anon";
GRANT ALL ON TABLE "public"."audit_journal_entries_with_source" TO "authenticated";
GRANT ALL ON TABLE "public"."audit_journal_entries_with_source" TO "service_role";



GRANT ALL ON TABLE "public"."audit_period_snapshots" TO "anon";
GRANT ALL ON TABLE "public"."audit_period_snapshots" TO "authenticated";
GRANT ALL ON TABLE "public"."audit_period_snapshots" TO "service_role";



GRANT ALL ON TABLE "public"."audit_trial_balance_all_time" TO "anon";
GRANT ALL ON TABLE "public"."audit_trial_balance_all_time" TO "authenticated";
GRANT ALL ON TABLE "public"."audit_trial_balance_all_time" TO "service_role";



GRANT ALL ON TABLE "public"."banks" TO "anon";
GRANT ALL ON TABLE "public"."banks" TO "authenticated";
GRANT ALL ON TABLE "public"."banks" TO "service_role";



GRANT ALL ON TABLE "public"."batch_balances" TO "anon";
GRANT ALL ON TABLE "public"."batch_balances" TO "authenticated";
GRANT ALL ON TABLE "public"."batch_balances" TO "service_role";



GRANT ALL ON TABLE "public"."batch_recalls" TO "anon";
GRANT ALL ON TABLE "public"."batch_recalls" TO "authenticated";
GRANT ALL ON TABLE "public"."batch_recalls" TO "service_role";



GRANT ALL ON TABLE "public"."batch_reservations" TO "anon";
GRANT ALL ON TABLE "public"."batch_reservations" TO "authenticated";
GRANT ALL ON TABLE "public"."batch_reservations" TO "service_role";



GRANT ALL ON TABLE "public"."batch_sales_trace" TO "anon";
GRANT ALL ON TABLE "public"."batch_sales_trace" TO "authenticated";
GRANT ALL ON TABLE "public"."batch_sales_trace" TO "service_role";



GRANT ALL ON TABLE "public"."batches" TO "anon";
GRANT ALL ON TABLE "public"."batches" TO "authenticated";
GRANT ALL ON TABLE "public"."batches" TO "service_role";



GRANT ALL ON TABLE "public"."branches" TO "anon";
GRANT ALL ON TABLE "public"."branches" TO "authenticated";
GRANT ALL ON TABLE "public"."branches" TO "service_role";



GRANT ALL ON TABLE "public"."challenges" TO "anon";
GRANT ALL ON TABLE "public"."challenges" TO "authenticated";
GRANT ALL ON TABLE "public"."challenges" TO "service_role";



GRANT ALL ON TABLE "public"."cod_settlement_orders" TO "anon";
GRANT ALL ON TABLE "public"."cod_settlement_orders" TO "authenticated";
GRANT ALL ON TABLE "public"."cod_settlement_orders" TO "service_role";



GRANT ALL ON TABLE "public"."cod_settlements" TO "anon";
GRANT ALL ON TABLE "public"."cod_settlements" TO "authenticated";
GRANT ALL ON TABLE "public"."cod_settlements" TO "service_role";



GRANT ALL ON TABLE "public"."companies" TO "anon";
GRANT ALL ON TABLE "public"."companies" TO "authenticated";
GRANT ALL ON TABLE "public"."companies" TO "service_role";



GRANT ALL ON TABLE "public"."cost_centers" TO "anon";
GRANT ALL ON TABLE "public"."cost_centers" TO "authenticated";
GRANT ALL ON TABLE "public"."cost_centers" TO "service_role";



GRANT ALL ON TABLE "public"."coupons" TO "anon";
GRANT ALL ON TABLE "public"."coupons" TO "authenticated";
GRANT ALL ON TABLE "public"."coupons" TO "service_role";



GRANT ALL ON TABLE "public"."currencies" TO "anon";
GRANT ALL ON TABLE "public"."currencies" TO "authenticated";
GRANT ALL ON TABLE "public"."currencies" TO "service_role";



GRANT ALL ON TABLE "public"."customer_special_prices" TO "anon";
GRANT ALL ON TABLE "public"."customer_special_prices" TO "authenticated";
GRANT ALL ON TABLE "public"."customer_special_prices" TO "service_role";



GRANT ALL ON TABLE "public"."customer_tax_profiles" TO "anon";
GRANT ALL ON TABLE "public"."customer_tax_profiles" TO "authenticated";
GRANT ALL ON TABLE "public"."customer_tax_profiles" TO "service_role";



GRANT ALL ON TABLE "public"."customers" TO "anon";
GRANT ALL ON TABLE "public"."customers" TO "authenticated";
GRANT ALL ON TABLE "public"."customers" TO "service_role";



GRANT ALL ON TABLE "public"."customers_decrypted" TO "anon";
GRANT ALL ON TABLE "public"."customers_decrypted" TO "authenticated";
GRANT ALL ON TABLE "public"."customers_decrypted" TO "service_role";



GRANT ALL ON TABLE "public"."delivery_zones" TO "anon";
GRANT ALL ON TABLE "public"."delivery_zones" TO "authenticated";
GRANT ALL ON TABLE "public"."delivery_zones" TO "service_role";



GRANT ALL ON TABLE "public"."driver_ledger" TO "anon";
GRANT ALL ON TABLE "public"."driver_ledger" TO "authenticated";
GRANT ALL ON TABLE "public"."driver_ledger" TO "service_role";



GRANT ALL ON TABLE "public"."expenses" TO "anon";
GRANT ALL ON TABLE "public"."expenses" TO "authenticated";
GRANT ALL ON TABLE "public"."expenses" TO "service_role";



GRANT ALL ON TABLE "public"."freshness_levels" TO "anon";
GRANT ALL ON TABLE "public"."freshness_levels" TO "authenticated";
GRANT ALL ON TABLE "public"."freshness_levels" TO "service_role";



GRANT ALL ON TABLE "public"."fx_rates" TO "anon";
GRANT ALL ON TABLE "public"."fx_rates" TO "authenticated";
GRANT ALL ON TABLE "public"."fx_rates" TO "service_role";



GRANT ALL ON TABLE "public"."fx_revaluation_audit" TO "anon";
GRANT ALL ON TABLE "public"."fx_revaluation_audit" TO "authenticated";
GRANT ALL ON TABLE "public"."fx_revaluation_audit" TO "service_role";



GRANT ALL ON TABLE "public"."import_expenses" TO "anon";
GRANT ALL ON TABLE "public"."import_expenses" TO "authenticated";
GRANT ALL ON TABLE "public"."import_expenses" TO "service_role";



GRANT ALL ON TABLE "public"."import_shipments" TO "anon";
GRANT ALL ON TABLE "public"."import_shipments" TO "authenticated";
GRANT ALL ON TABLE "public"."import_shipments" TO "service_role";



GRANT ALL ON TABLE "public"."import_shipments_items" TO "anon";
GRANT ALL ON TABLE "public"."import_shipments_items" TO "authenticated";
GRANT ALL ON TABLE "public"."import_shipments_items" TO "service_role";



GRANT ALL ON TABLE "public"."inventory_movements" TO "anon";
GRANT ALL ON TABLE "public"."inventory_movements" TO "authenticated";
GRANT ALL ON TABLE "public"."inventory_movements" TO "service_role";



GRANT ALL ON TABLE "public"."inventory_transfer_items" TO "anon";
GRANT ALL ON TABLE "public"."inventory_transfer_items" TO "authenticated";
GRANT ALL ON TABLE "public"."inventory_transfer_items" TO "service_role";



GRANT ALL ON TABLE "public"."inventory_transfers" TO "anon";
GRANT ALL ON TABLE "public"."inventory_transfers" TO "authenticated";
GRANT ALL ON TABLE "public"."inventory_transfers" TO "service_role";



GRANT ALL ON SEQUENCE "public"."invoice_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."invoice_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."invoice_seq" TO "service_role";



GRANT ALL ON TABLE "public"."invoice_tolerances" TO "anon";
GRANT ALL ON TABLE "public"."invoice_tolerances" TO "authenticated";
GRANT ALL ON TABLE "public"."invoice_tolerances" TO "service_role";



GRANT ALL ON TABLE "public"."item_categories" TO "anon";
GRANT ALL ON TABLE "public"."item_categories" TO "authenticated";
GRANT ALL ON TABLE "public"."item_categories" TO "service_role";



GRANT ALL ON TABLE "public"."item_groups" TO "anon";
GRANT ALL ON TABLE "public"."item_groups" TO "authenticated";
GRANT ALL ON TABLE "public"."item_groups" TO "service_role";



GRANT ALL ON TABLE "public"."item_tax_profiles" TO "anon";
GRANT ALL ON TABLE "public"."item_tax_profiles" TO "authenticated";
GRANT ALL ON TABLE "public"."item_tax_profiles" TO "service_role";



GRANT ALL ON TABLE "public"."item_uom" TO "anon";
GRANT ALL ON TABLE "public"."item_uom" TO "authenticated";
GRANT ALL ON TABLE "public"."item_uom" TO "service_role";



GRANT ALL ON TABLE "public"."job_runs" TO "anon";
GRANT ALL ON TABLE "public"."job_runs" TO "authenticated";
GRANT ALL ON TABLE "public"."job_runs" TO "service_role";



GRANT ALL ON TABLE "public"."job_schedules" TO "anon";
GRANT ALL ON TABLE "public"."job_schedules" TO "authenticated";
GRANT ALL ON TABLE "public"."job_schedules" TO "service_role";



GRANT ALL ON TABLE "public"."landed_cost_audit" TO "anon";
GRANT ALL ON TABLE "public"."landed_cost_audit" TO "authenticated";
GRANT ALL ON TABLE "public"."landed_cost_audit" TO "service_role";



GRANT ALL ON TABLE "public"."ledger_audit_log" TO "service_role";
GRANT SELECT ON TABLE "public"."ledger_audit_log" TO "authenticated";



GRANT ALL ON TABLE "public"."ledger_entries" TO "anon";
GRANT ALL ON TABLE "public"."ledger_entries" TO "authenticated";
GRANT ALL ON TABLE "public"."ledger_entries" TO "service_role";



GRANT ALL ON TABLE "public"."ledger_lines" TO "anon";
GRANT ALL ON TABLE "public"."ledger_lines" TO "authenticated";
GRANT ALL ON TABLE "public"."ledger_lines" TO "service_role";



GRANT ALL ON TABLE "public"."menu_items" TO "anon";
GRANT ALL ON TABLE "public"."menu_items" TO "authenticated";
GRANT ALL ON TABLE "public"."menu_items" TO "service_role";



GRANT ALL ON TABLE "public"."notifications" TO "anon";
GRANT ALL ON TABLE "public"."notifications" TO "authenticated";
GRANT ALL ON TABLE "public"."notifications" TO "service_role";



GRANT ALL ON TABLE "public"."order_events" TO "anon";
GRANT ALL ON TABLE "public"."order_events" TO "authenticated";
GRANT ALL ON TABLE "public"."order_events" TO "service_role";



GRANT ALL ON TABLE "public"."order_item_cogs" TO "anon";
GRANT ALL ON TABLE "public"."order_item_cogs" TO "authenticated";
GRANT ALL ON TABLE "public"."order_item_cogs" TO "service_role";



GRANT ALL ON TABLE "public"."order_item_reservations" TO "anon";
GRANT ALL ON TABLE "public"."order_item_reservations" TO "authenticated";
GRANT ALL ON TABLE "public"."order_item_reservations" TO "service_role";



GRANT ALL ON TABLE "public"."order_line_items" TO "anon";
GRANT ALL ON TABLE "public"."order_line_items" TO "authenticated";
GRANT ALL ON TABLE "public"."order_line_items" TO "service_role";



GRANT ALL ON TABLE "public"."order_tax_lines" TO "anon";
GRANT ALL ON TABLE "public"."order_tax_lines" TO "authenticated";
GRANT ALL ON TABLE "public"."order_tax_lines" TO "service_role";



GRANT ALL ON TABLE "public"."orders" TO "anon";
GRANT ALL ON TABLE "public"."orders" TO "authenticated";
GRANT ALL ON TABLE "public"."orders" TO "service_role";



GRANT ALL ON TABLE "public"."payments" TO "anon";
GRANT ALL ON TABLE "public"."payments" TO "authenticated";
GRANT ALL ON TABLE "public"."payments" TO "service_role";



GRANT ALL ON TABLE "public"."pos_offline_sales" TO "anon";
GRANT ALL ON TABLE "public"."pos_offline_sales" TO "authenticated";
GRANT ALL ON TABLE "public"."pos_offline_sales" TO "service_role";



GRANT ALL ON TABLE "public"."price_history" TO "anon";
GRANT ALL ON TABLE "public"."price_history" TO "authenticated";
GRANT ALL ON TABLE "public"."price_history" TO "service_role";



GRANT ALL ON TABLE "public"."price_tiers" TO "anon";
GRANT ALL ON TABLE "public"."price_tiers" TO "authenticated";
GRANT ALL ON TABLE "public"."price_tiers" TO "service_role";



GRANT ALL ON TABLE "public"."product_audit_log" TO "anon";
GRANT ALL ON TABLE "public"."product_audit_log" TO "authenticated";
GRANT ALL ON TABLE "public"."product_audit_log" TO "service_role";



GRANT ALL ON TABLE "public"."production_order_inputs" TO "anon";
GRANT ALL ON TABLE "public"."production_order_inputs" TO "authenticated";
GRANT ALL ON TABLE "public"."production_order_inputs" TO "service_role";



GRANT ALL ON TABLE "public"."production_order_outputs" TO "anon";
GRANT ALL ON TABLE "public"."production_order_outputs" TO "authenticated";
GRANT ALL ON TABLE "public"."production_order_outputs" TO "service_role";



GRANT ALL ON TABLE "public"."production_orders" TO "anon";
GRANT ALL ON TABLE "public"."production_orders" TO "authenticated";
GRANT ALL ON TABLE "public"."production_orders" TO "service_role";



GRANT ALL ON TABLE "public"."promotion_items" TO "anon";
GRANT ALL ON TABLE "public"."promotion_items" TO "authenticated";
GRANT ALL ON TABLE "public"."promotion_items" TO "service_role";



GRANT ALL ON TABLE "public"."promotion_usage" TO "anon";
GRANT ALL ON TABLE "public"."promotion_usage" TO "authenticated";
GRANT ALL ON TABLE "public"."promotion_usage" TO "service_role";



GRANT ALL ON TABLE "public"."promotions" TO "anon";
GRANT ALL ON TABLE "public"."promotions" TO "authenticated";
GRANT ALL ON TABLE "public"."promotions" TO "service_role";



GRANT ALL ON TABLE "public"."purchase_items" TO "anon";
GRANT ALL ON TABLE "public"."purchase_items" TO "authenticated";
GRANT ALL ON TABLE "public"."purchase_items" TO "service_role";



GRANT ALL ON SEQUENCE "public"."purchase_order_number_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."purchase_order_number_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."purchase_order_number_seq" TO "service_role";



GRANT ALL ON TABLE "public"."purchase_orders" TO "anon";
GRANT ALL ON TABLE "public"."purchase_orders" TO "authenticated";
GRANT ALL ON TABLE "public"."purchase_orders" TO "service_role";



GRANT ALL ON TABLE "public"."purchase_receipt_items" TO "anon";
GRANT ALL ON TABLE "public"."purchase_receipt_items" TO "authenticated";
GRANT ALL ON TABLE "public"."purchase_receipt_items" TO "service_role";



GRANT ALL ON TABLE "public"."purchase_receipts" TO "anon";
GRANT ALL ON TABLE "public"."purchase_receipts" TO "authenticated";
GRANT ALL ON TABLE "public"."purchase_receipts" TO "service_role";



GRANT ALL ON TABLE "public"."purchase_return_items" TO "anon";
GRANT ALL ON TABLE "public"."purchase_return_items" TO "authenticated";
GRANT ALL ON TABLE "public"."purchase_return_items" TO "service_role";



GRANT ALL ON TABLE "public"."purchase_returns" TO "anon";
GRANT ALL ON TABLE "public"."purchase_returns" TO "authenticated";
GRANT ALL ON TABLE "public"."purchase_returns" TO "service_role";



GRANT ALL ON TABLE "public"."qc_checks" TO "anon";
GRANT ALL ON TABLE "public"."qc_checks" TO "authenticated";
GRANT ALL ON TABLE "public"."qc_checks" TO "service_role";



GRANT ALL ON TABLE "public"."reviews" TO "anon";
GRANT ALL ON TABLE "public"."reviews" TO "authenticated";
GRANT ALL ON TABLE "public"."reviews" TO "service_role";



GRANT ALL ON TABLE "public"."sales_returns" TO "anon";
GRANT ALL ON TABLE "public"."sales_returns" TO "authenticated";
GRANT ALL ON TABLE "public"."sales_returns" TO "service_role";



GRANT ALL ON TABLE "public"."stock_history" TO "anon";
GRANT ALL ON TABLE "public"."stock_history" TO "authenticated";
GRANT ALL ON TABLE "public"."stock_history" TO "service_role";



GRANT ALL ON TABLE "public"."stock_management" TO "anon";
GRANT ALL ON TABLE "public"."stock_management" TO "authenticated";
GRANT ALL ON TABLE "public"."stock_management" TO "service_role";



GRANT ALL ON TABLE "public"."stock_wastage" TO "anon";
GRANT ALL ON TABLE "public"."stock_wastage" TO "authenticated";
GRANT ALL ON TABLE "public"."stock_wastage" TO "service_role";



GRANT ALL ON TABLE "public"."supplier_contracts" TO "anon";
GRANT ALL ON TABLE "public"."supplier_contracts" TO "authenticated";
GRANT ALL ON TABLE "public"."supplier_contracts" TO "service_role";



GRANT ALL ON TABLE "public"."supplier_credit_note_allocations" TO "anon";
GRANT ALL ON TABLE "public"."supplier_credit_note_allocations" TO "authenticated";
GRANT ALL ON TABLE "public"."supplier_credit_note_allocations" TO "service_role";



GRANT ALL ON TABLE "public"."supplier_credit_notes" TO "anon";
GRANT ALL ON TABLE "public"."supplier_credit_notes" TO "authenticated";
GRANT ALL ON TABLE "public"."supplier_credit_notes" TO "service_role";



GRANT ALL ON TABLE "public"."supplier_evaluations" TO "anon";
GRANT ALL ON TABLE "public"."supplier_evaluations" TO "authenticated";
GRANT ALL ON TABLE "public"."supplier_evaluations" TO "service_role";



GRANT ALL ON TABLE "public"."supplier_invoice_lines" TO "anon";
GRANT ALL ON TABLE "public"."supplier_invoice_lines" TO "authenticated";
GRANT ALL ON TABLE "public"."supplier_invoice_lines" TO "service_role";



GRANT ALL ON TABLE "public"."supplier_invoices" TO "anon";
GRANT ALL ON TABLE "public"."supplier_invoices" TO "authenticated";
GRANT ALL ON TABLE "public"."supplier_invoices" TO "service_role";



GRANT ALL ON TABLE "public"."suppliers" TO "anon";
GRANT ALL ON TABLE "public"."suppliers" TO "authenticated";
GRANT ALL ON TABLE "public"."suppliers" TO "service_role";



GRANT REFERENCES,TRIGGER,TRUNCATE,MAINTAIN ON TABLE "public"."system_audit_logs" TO "anon";
GRANT ALL ON TABLE "public"."system_audit_logs" TO "authenticated";
GRANT ALL ON TABLE "public"."system_audit_logs" TO "service_role";



GRANT ALL ON TABLE "public"."tax_jurisdictions" TO "anon";
GRANT ALL ON TABLE "public"."tax_jurisdictions" TO "authenticated";
GRANT ALL ON TABLE "public"."tax_jurisdictions" TO "service_role";



GRANT ALL ON TABLE "public"."tax_rates" TO "anon";
GRANT ALL ON TABLE "public"."tax_rates" TO "authenticated";
GRANT ALL ON TABLE "public"."tax_rates" TO "service_role";



GRANT ALL ON TABLE "public"."three_way_match_results" TO "anon";
GRANT ALL ON TABLE "public"."three_way_match_results" TO "authenticated";
GRANT ALL ON TABLE "public"."three_way_match_results" TO "service_role";



GRANT ALL ON TABLE "public"."transfer_recipients" TO "anon";
GRANT ALL ON TABLE "public"."transfer_recipients" TO "authenticated";
GRANT ALL ON TABLE "public"."transfer_recipients" TO "service_role";



GRANT ALL ON TABLE "public"."unit_types" TO "anon";
GRANT ALL ON TABLE "public"."unit_types" TO "authenticated";
GRANT ALL ON TABLE "public"."unit_types" TO "service_role";



GRANT ALL ON TABLE "public"."uom" TO "anon";
GRANT ALL ON TABLE "public"."uom" TO "authenticated";
GRANT ALL ON TABLE "public"."uom" TO "service_role";



GRANT ALL ON TABLE "public"."uom_conversions" TO "anon";
GRANT ALL ON TABLE "public"."uom_conversions" TO "authenticated";
GRANT ALL ON TABLE "public"."uom_conversions" TO "service_role";



GRANT ALL ON TABLE "public"."user_challenge_progress" TO "anon";
GRANT ALL ON TABLE "public"."user_challenge_progress" TO "authenticated";
GRANT ALL ON TABLE "public"."user_challenge_progress" TO "service_role";



GRANT ALL ON TABLE "public"."v_balance_sheet" TO "anon";
GRANT ALL ON TABLE "public"."v_balance_sheet" TO "authenticated";
GRANT ALL ON TABLE "public"."v_balance_sheet" TO "service_role";



GRANT ALL ON TABLE "public"."v_batch_balances" TO "anon";
GRANT ALL ON TABLE "public"."v_batch_balances" TO "authenticated";
GRANT ALL ON TABLE "public"."v_batch_balances" TO "service_role";



GRANT ALL ON TABLE "public"."v_cash_in_transit_balance" TO "anon";
GRANT ALL ON TABLE "public"."v_cash_in_transit_balance" TO "authenticated";
GRANT ALL ON TABLE "public"."v_cash_in_transit_balance" TO "service_role";



GRANT ALL ON TABLE "public"."v_driver_ledger_balances" TO "anon";
GRANT ALL ON TABLE "public"."v_driver_ledger_balances" TO "authenticated";
GRANT ALL ON TABLE "public"."v_driver_ledger_balances" TO "service_role";



GRANT ALL ON TABLE "public"."v_cod_reconciliation_check" TO "anon";
GRANT ALL ON TABLE "public"."v_cod_reconciliation_check" TO "authenticated";
GRANT ALL ON TABLE "public"."v_cod_reconciliation_check" TO "service_role";



GRANT ALL ON TABLE "public"."v_cod_unsettled_orders" TO "anon";
GRANT ALL ON TABLE "public"."v_cod_unsettled_orders" TO "authenticated";
GRANT ALL ON TABLE "public"."v_cod_unsettled_orders" TO "service_role";



GRANT ALL ON TABLE "public"."v_cogs_movements" TO "anon";
GRANT ALL ON TABLE "public"."v_cogs_movements" TO "authenticated";
GRANT ALL ON TABLE "public"."v_cogs_movements" TO "service_role";



GRANT ALL ON TABLE "public"."v_cogs_reconciliation" TO "anon";
GRANT ALL ON TABLE "public"."v_cogs_reconciliation" TO "authenticated";
GRANT ALL ON TABLE "public"."v_cogs_reconciliation" TO "service_role";



GRANT ALL ON TABLE "public"."v_food_batch_balances" TO "anon";
GRANT ALL ON TABLE "public"."v_food_batch_balances" TO "authenticated";
GRANT ALL ON TABLE "public"."v_food_batch_balances" TO "service_role";



GRANT ALL ON TABLE "public"."v_note_expenses" TO "anon";
GRANT ALL ON TABLE "public"."v_note_expenses" TO "authenticated";
GRANT ALL ON TABLE "public"."v_note_expenses" TO "service_role";



GRANT ALL ON TABLE "public"."v_note_inventory" TO "anon";
GRANT ALL ON TABLE "public"."v_note_inventory" TO "authenticated";
GRANT ALL ON TABLE "public"."v_note_inventory" TO "service_role";



GRANT ALL ON TABLE "public"."v_note_revenue" TO "anon";
GRANT ALL ON TABLE "public"."v_note_revenue" TO "authenticated";
GRANT ALL ON TABLE "public"."v_note_revenue" TO "service_role";



GRANT ALL ON TABLE "public"."v_note_vat" TO "anon";
GRANT ALL ON TABLE "public"."v_note_vat" TO "authenticated";
GRANT ALL ON TABLE "public"."v_note_vat" TO "service_role";



GRANT ALL ON TABLE "public"."v_profit_and_loss" TO "anon";
GRANT ALL ON TABLE "public"."v_profit_and_loss" TO "authenticated";
GRANT ALL ON TABLE "public"."v_profit_and_loss" TO "service_role";



GRANT ALL ON TABLE "public"."v_sellable_products" TO "anon";
GRANT ALL ON TABLE "public"."v_sellable_products" TO "authenticated";
GRANT ALL ON TABLE "public"."v_sellable_products" TO "service_role";



GRANT ALL ON TABLE "public"."v_trial_balance" TO "anon";
GRANT ALL ON TABLE "public"."v_trial_balance" TO "authenticated";
GRANT ALL ON TABLE "public"."v_trial_balance" TO "service_role";



GRANT ALL ON TABLE "public"."v_trial_balance_totals" TO "anon";
GRANT ALL ON TABLE "public"."v_trial_balance_totals" TO "authenticated";
GRANT ALL ON TABLE "public"."v_trial_balance_totals" TO "service_role";



GRANT ALL ON TABLE "public"."warehouse_transfer_items" TO "anon";
GRANT ALL ON TABLE "public"."warehouse_transfer_items" TO "authenticated";
GRANT ALL ON TABLE "public"."warehouse_transfer_items" TO "service_role";



GRANT ALL ON TABLE "public"."warehouse_transfers" TO "anon";
GRANT ALL ON TABLE "public"."warehouse_transfers" TO "authenticated";
GRANT ALL ON TABLE "public"."warehouse_transfers" TO "service_role";



GRANT ALL ON TABLE "public"."warehouses" TO "anon";
GRANT ALL ON TABLE "public"."warehouses" TO "authenticated";
GRANT ALL ON TABLE "public"."warehouses" TO "service_role";



ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "service_role";







